```json
{
  "rust_files": {
    "nautilus_adapter/lighter/config.rs": "use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LighterConfig {\n    pub api_key: Option<String>,\n    pub api_secret: Option<String>,\n    pub chain_id: String,\n    #[serde(default = \"default_base_url\")]\n    pub base_url: String,\n    #[serde(default = \"default_ws_url\")]\n    pub ws_url: String,\n    pub timeout_ms: Option<u64>,\n}\n\nfn default_base_url() -> String {\n    \"https://api.lighter.xyz\".to_string()\n}\n\nfn default_ws_url() -> String {\n    \"wss://api.lighter.xyz/ws\".to_string()\n}\n\n#[derive(Debug, Clone)]\npub struct Credential {\n    pub api_key: String,\n    pub api_secret: String,\n}\n\nimpl Credential {\n    pub fn from_env() -> Option<Self> {\n        let api_key = std::env::var(\"Lighter_API_KEY\").ok()?;\n        let api_secret = std::env::var(\"Lighter_API_SECRET\").ok()?;\n        Some(Self { api_key, api_secret })\n    }\n}",
    "nautilus_adapter/lighter/error.rs": "use thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum LighterAdapterError {\n    #[error(\"HTTP request failed: {0}\")]\n    HttpError(#[from] hyper::Error),\n    #[error(\"JSON serialization/deserialization error: {0}\")]\n    JsonError(#[from] serde_json::Error),\n    #[error(\"IO error: {0}\")]\n    IoError(#[from] std::io::Error),\n    #[error(\"Invalid API Key or Secret\")]\n    InvalidCredentials,\n    #[error(\"Authentication failed: {0}\")]\n    AuthError(String),\n    #[error(\"Rate limit exceeded\")]\n    RateLimitExceeded,\n    #[error(\"Exchange returned error: {code} - {msg}\")]\n    ExchangeError { code: i32, msg: String },\n    #[error(\"WebSocket connection closed: {0}\")]\n    WebSocketClosed(String),\n    #[error(\"Timestamp format error\")]\n    TimestampError,\n    #[error(\"Invalid signature\")]\n    InvalidSignature,\n    #[error(\"UTF-8 conversion error\")]\n    Utf8Error(#[from] std::string::FromUtf8Error),\n}\n\npub type Result<T> = std::result::Result<T, LighterAdapterError>;",
    "nautilus_adapter/lighter/http/signing.rs": "use crate::error::Result;\nuse hmac::{Hmac, Mac};\nuse sha2::Sha256;\nuse std::time::{SystemTime, UNIX_EPOCH};\n\ntype HmacSha256 = Hmac<Sha256>;\n\npub fn generate_timestamp() -> u64 {\n    SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .expect(\"Time went backwards\")\n        .as_millis() as u64\n}\n\npub struct Signer {\n    api_secret: String,\n}\n\nimpl Signer {\n    pub fn new(api_secret: String) -> Self {\n        Self { api_secret }\n    }\n\n    /// Signature payload: timestamp + method + requestPath + body\n    pub fn sign(&self, timestamp: u64, method: &str, path: &str, body: &str) -> Result<String> {\n        let payload = format!(\"{}{}{}{}\", timestamp, method, path, body);\n        \n        let mut mac = HmacSha256::new_from_slice(self.api_secret.as_bytes())\n            .map_err(|_| crate::error::LighterAdapterError::InvalidCredentials)?;\n        mac.update(payload.as_bytes());\n        \n        let result = mac.finalize();\n        let code_bytes = result.into_bytes();\n        \n        Ok(hex::encode(code_bytes))\n    }\n}",
    "nautilus_adapter/lighter/http/client.rs": "use crate::config::Credential;\nuse crate::error::{LighterAdapterError, Result};\nuse crate::http::signing::{generate_timestamp, Signer};\nuse hyper::header::{HeaderName, HeaderValue, CONTENT_TYPE};\nuse hyper::Method;\nuse hyper::{Request, Response, StatusCode};\nuse hyper::body::Incoming;\nuse hyper_rustls::HttpsConnector;\nuse hyper_util::client::legacy::connect::HttpConnector;\nuse hyper_util::client::legacy::Client;\nuse hyper_util::rt::TokioExecutor;\nuse serde::de::DeserializeOwned;\nuse serde::Serialize;\n\npub struct HttpClient {\n    inner: Client<HttpsConnector<HttpConnector>, Incoming>,\n    base_url: String,\n    chain_id: String,\n    credential: Option<Credential>,\n    signer: Option<Signer>,\n}\n\nimpl HttpClient {\n    pub fn new(base_url: String, chain_id: String, credential: Option<Credential>) -> Self {\n        let https = hyper_rustls::HttpsConnectorBuilder::new()\n            .with_native_roots()\n            .unwrap()\n            .https_or_http()\n            .enable_http1()\n            .build();\n\n        let inner = Client::builder(TokioExecutor::new()).build(https);\n\n        let signer = credential.as_ref().map(|c| Signer::new(c.api_secret.clone()));\n\n        Self {\n            inner,\n            base_url,\n            chain_id,\n            credential,\n            signer,\n        }\n    }\n\n    async fn send_request(\n        &self,\n        method: Method,\n        path: &str,\n        body_bytes: Vec<u8>,\n        auth: bool,\n    ) -> Result<Response<Incoming>> {\n        let url = format!(\"{}{}\", self.base_url, path);\n        \n        // Calculate signature if auth is required\n        let timestamp = generate_timestamp();\n        let body_str = String::from_utf8(body_bytes.clone())?;\n        \n        let signature = if auth {\n            if let Some(signer) = &self.signer {\n                Some(signer.sign(timestamp, method.as_str(), path, &body_str)?)\n            } else {\n                return Err(LighterAdapterError::InvalidCredentials);\n            }\n        } else {\n            None\n        };\n\n        let mut request_builder = Request::builder()\n            .method(method)\n            .uri(&url);\n\n        // Set Headers\n        request_builder = request_builder.header(\"x-lighter-chain-id\", &self.chain_id);\n        request_builder = request_builder.header(CONTENT_TYPE, HeaderValue::from_static(\"application/json\"));\n        \n        if auth {\n            if let Some(cred) = &self.credential {\n                request_builder = request_builder.header(\"x-api-key\", &cred.api_key);\n                request_builder = request_builder.header(\"x-timestamp\", timestamp.to_string());\n                if let Some(sig) = signature {\n                    request_builder = request_builder.header(\"x-signature\", sig);\n                }\n            }\n        }\n\n        let request = request_builder.body(body_bytes.into())?;\n        let response = self.inner.request(request).await?;\n        \n        let status = response.status();\n        if !status.is_success() {\n            let error_bytes = hyper::body::to_bytes(response.into_body()).await?;\n            let error_msg = String::from_utf8_lossy(&error_bytes).to_string();\n            \n            if status == StatusCode::UNAUTHORIZED || status == StatusCode::FORBIDDEN {\n                return Err(LighterAdapterError::AuthError(error_msg));\n            } else if status == StatusCode::TOO_MANY_REQUESTS {\n                return Err(LighterAdapterError::RateLimitExceeded);\n            } else {\n                return Err(LighterAdapterError::ExchangeError {\n                    code: status.as_u16() as i32,\n                    msg: error_msg,\n                });\n            }\n        }\n\n        Ok(response)\n    }\n\n    pub async fn get<T: DeserializeOwned>(&self, path: &str, auth: bool) -> Result<T> {\n        let response = self.send_request(Method::GET, path, vec![], auth).await?;\n        let body_bytes = hyper::body::to_bytes(response.into_body()).await?;\n        serde_json::from_slice(&body_bytes).map_err(Into::into)\n    }\n\n    pub async fn post<T: DeserializeOwned, B: Serialize>(\n        &self,\n        path: &str,\n        body: B,\n        auth: bool,\n    ) -> Result<T> {\n        let json_body = serde_json::to_vec(&body)?;\n        let response = self\n            .send_request(Method::POST, path, json_body, auth)\n            .await?;\n        let body_bytes = hyper::body::to_bytes(response.into_body()).await?;\n        serde_json::from_slice(&body_bytes).map_err(Into::into)\n    }\n}",
    "nautilus_adapter/lighter/websocket/client.rs": "use crate::config::Credential;\nuse crate::error::{LighterAdapterError, Result};\nuse crate::http::signing::{generate_timestamp, Signer};\nuse futures_util::{SinkExt, StreamExt};\nuse serde_json::Value;\nuse tokio_tungstenite::tungstenite::protocol::Message;\nuse tokio_tungstenite::{connect_async, WebSocketStream};\n\ntype WsStream = WebSocketStream<tokio_tungstenite::MaybeTlsStream<tokio::net::TcpStream>>;\n\npub struct WsClient {\n    url: String,\n    credential: Option<Credential>,\n}\n\nimpl WsClient {\n    pub fn new(url: String, credential: Option<Credential>) -> Self {\n        Self { url, credential }\n    }\n\n    pub async fn connect(&self) -> Result<WsStream> {\n        let url = url::Url::parse(&self.url)\n            .map_err(|e| LighterAdapterError::AuthError(format!(\"Invalid WS URL: {}\", e)))?;\n        let (ws_stream, _) = connect_async(url).await?;\n        Ok(ws_stream)\n    }\n\n    pub async fn authenticate(&self, ws_stream: &mut WsStream) -> Result<()> {\n        if let Some(cred) = &self.credential {\n            let timestamp = generate_timestamp();\n            \n            let signer = Signer::new(cred.api_secret.clone());\n            // Standard WS signing path usually derived from the URL path\n            let signature = signer.sign(timestamp, \"GET\", \"/ws\", \"\")?;\n\n            let auth_payload = serde_json::json!({\n                \"type\": \"auth\",\n                \"apiKey\": cred.api_key,\n                \"timestamp\": timestamp,\n                \"signature\": signature\n            });\n\n            ws_stream.send(Message::Text(auth_payload.to_string())).await?;\n            \n            match ws_stream.next().await {\n                Some(Ok(Message::Text(text))) => {\n                    let json: Value = serde_json::from_str(&text)?;\n                    if json[\"type\"] == \"auth\" && json[\"success\"] == true {\n                        Ok(())\n                    } else {\n                        Err(LighterAdapterError::AuthError(format!(\"WS Auth failed: {}\", text)))\n                    }\n                },\n                Some(Ok(_)) => Err(LighterAdapterError::AuthError(\"Unexpected message type\".to_string())),\n                Some(Err(e)) => Err(LighterAdapterError::WebSocketClosed(e.to_string())),\n                None => Err(LighterAdapterError::WebSocketClosed(\"Connection closed\".to_string())),\n            }\n        } else {\n            Ok(()) // Public mode\n        }\n    }\n}",
    "nautilus_adapter/lighter/parsing/models.rs": "use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct Ticker {\n    pub symbol: String,\n    #[serde(rename = \"lastPrice\")]\n    pub last_price: String,\n    pub volume: String,\n    #[serde(rename = \"priceStep\")]\n    pub price_step: String,\n    #[serde(rename = \"sizeStep\")]\n    pub size_step: String,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct OrderbookLevel {\n    pub price: String,\n    pub quantity: String,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct Orderbook {\n    pub asks: Vec<OrderbookLevel>,\n    pub bids: Vec<OrderbookLevel>,\n    pub timestamp: i64,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct LighterOrder {\n    #[serde(rename = \"orderId\")]\n    pub order_id: String,\n    pub status: String,\n    pub symbol: String,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct WsMessage {\n    #[serde(rename = \"type\")]\n    pub msg_type: String,\n    pub data: Value,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct Trade {\n    pub id: String,\n    pub price: String,\n    pub quantity: String,\n    pub side: String,\n    pub timestamp: i64,\n}",
    "nautilus_adapter/lighter/python/mod.rs": "use pyo3::prelude::*;\nuse pyo3::types::PyDict;\nuse crate::config::{Credential, LighterConfig};\nuse crate::http::client::HttpClient;\nuse crate::parsing::models::Ticker;\n\n#[pymodule]\nfn lighter_adapter(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<PyLighterClient>()?;\n    Ok(())\n}\n\n#[pyclass(name = \"LighterClient\")]\npub struct PyLighterClient {\n    client: HttpClient,\n}\n\n#[pymethods]\nimpl PyLighterClient {\n    #[new]\n    #[pyo3(signature = (api_key=None, api_secret=None, chain_id=\"137\"))] \n    fn new(api_key: Option<String>, api_secret: Option<String>, chain_id: String) -> PyResult<Self> {\n        let config = LighterConfig {\n            api_key: api_key.clone(),\n            api_secret: api_secret.clone(),\n            chain_id,\n            base_url: \"https://api.lighter.xyz\".to_string(),\n            ws_url: \"wss://api.lighter.xyz/ws\".to_string(),\n            timeout_ms: Some(5000),\n        };\n\n        let creds = if config.api_key.is_some() && config.api_secret.is_some() {\n            Some(Credential {\n                api_key: config.api_key.unwrap(),\n                api_secret: config.api_secret.unwrap(),\n            })\n        } else {\n            None\n        };\n\n        let client = HttpClient::new(config.base_url, config.chain_id, creds);\n        Ok(Self { client })\n    }\n\n    fn get_tickers<'py>(&self, py: Python<'py>) -> PyResult<&'py PyAny> {\n        let client = self.client.clone();\n        pyo3_asyncio::tokio::future_into_py(py, async move {\n            let result = client.get::<Vec<Ticker>>(\"/v1/tickers\", false).await;\n            Python::with_gil(|py| {\n                match result {\n                    Ok(tickers) => {\n                        let py_list: Vec<PyObject> = tickers.into_iter().map(|t| {\n                            let dict = PyDict::new(py);\n                            dict.set_item(\"symbol\", t.symbol).unwrap();\n                            dict.set_item(\"lastPrice\", t.last_price).unwrap();\n                            dict.set_item(\"volume\", t.volume).unwrap();\n                            dict.set_item(\"priceStep\", t.price_step).unwrap();\n                            dict.set_item(\"sizeStep\", t.size_step).unwrap();\n                            dict.into()\n                        }).collect();\n                        Ok(py_list)\n                    },\n                    Err(e) => Err(pyo3::exceptions::PyRuntimeError::new_err(e.to_string())),\n                }\n            })\n        })\n    }\n}",
    "nautilus_adapter/lighter/lib.rs": "pub mod config;\npub mod error;\npub mod http;\npub mod parsing;\npub mod websocket;\n\n#[cfg(feature = \"python\")]\npub mod python;\n"
  }
}
```