```json
{
  "python_files": {
    "config.py": "from nautilus_trader.config import LiveConfig\nfrom nautilus_trader.core.correctness import PyCondition\nfrom nautilus_trader.model.identifiers import Venue\n\n\n# Constants\nVENUE = Venue(\"LIGHTER\")\nDEFAULT_CHAIN_ID = \"137\"  # Polygon Mainnet\n\n\nclass LighterConfig(LiveConfig, frozen=True):\n    \"\"\"\n    Configuration for the Lighter DEX adapter.\n    \"\"\"\n\n    api_key: str\n    api_secret: str\n    chain_id: str = DEFAULT_CHAIN_ID\n    rest_base_url: str = \"https://api.lighter.xyz\"\n    ws_public_url: str = \"wss://api.lighter.xyz/ws\"\n    ws_private_url: str = \"wss://api.lighter.xyz/ws\"\n\n    def __post_init__(self) -> None:\n        PyCondition.valid_string(self.api_key, \"api_key\")\n        PyCondition.valid_string(self.api_secret, \"api_secret\")\n        PyCondition.valid_string(self.chain_id, \"chain_id\")",
    "constants.py": "from nautilus_trader.model.enums import OrderSide, OrderStatus, OrderType\n\n# Exchange Identity\nVENUE = \"LIGHTER\"\nEXCHANGE_NAME = \"Lighter\"\n\n# HTTP Headers\nHEADER_CHAIN_ID = \"x-lighter-chain-id\"\nHEADER_API_KEY = \"x-api-key\"\nHEADER_TIMESTAMP = \"x-timestamp\"\nHEADER_SIGNATURE = \"x-signature\"\n\n# Order Types (Lighter supports LIMIT and MARKET)\nSUPPORTED_ORDER_TYPES = {\n    OrderType.LIMIT,\n    OrderType.MARKET,\n}\n\n# Order State Mapping (Lighter internal strings -> Nautilus OrderStatus)\n# Mapping assumption based on standard exchange behavior and schema states\nORDER_STATUS_MAP = {\n    \"NEW\": OrderStatus.ACCEPTED,\n    \"PARTIALLY_FILLED\": OrderStatus.WORKING,  # Typically WORKING in Nautilus while partial fills occur\n    \"FILLED\": OrderStatus.FILLED,\n    \"CANCELLED\": OrderStatus.CANCELED,\n    \"REJECTED\": OrderStatus.REJECTED,\n    \"EXPIRED\": OrderStatus.EXPIRED,\n}\n\n# WebSocket Channels\nWS_PUBLIC_CHANNELS = [\n    \"orderbook\",\n    \"trades\",\n]\n\n# Rate Limits\nDEFAULT_RATE_LIMIT = (\"1m\", 120)",
    "data.py": "from typing import Optional\n\nfrom nautilus_trader.core.data import Data\nfrom nautilus_trader.model.identifiers import InstrumentId, TradeId\nfrom nautilus_trader.model.objects import Price, Quantity\nfrom nautilus_trader.model.data import OrderBookDelta\n\n\nclass LighterTicker(Data):\n    \"\"\"\n    Represents a ticker update from Lighter.\n    \"\"\"\n    def __init__(\n        self,\n        instrument_id: InstrumentId,\n        last_price: Price,\n        volume: Quantity,\n        price_step: Price,\n        size_step: Quantity,\n        ts_event: int,\n        ts_init: int,\n    ) -> None:\n        super().__init__(ts_event=ts_event, ts_init=ts_init)\n        self.instrument_id = instrument_id\n        self.last_price = last_price\n        self.volume = volume\n        self.price_step = price_step\n        self.size_step = size_step\n\n\nclass LighterOrderBookSnapshot(Data):\n    \"\"\"\n    Represents a full order book snapshot from Lighter REST API.\n    \"\"\"\n    def __init__(\n        self,\n        instrument_id: InstrumentId,\n        bids: list[tuple[Price, Quantity]],\n        asks: list[tuple[Price, Quantity]],\n        ts_event: int,\n        ts_init: int,\n    ) -> None:\n        super().__init__(ts_event=ts_event, ts_init=ts_init)\n        self.instrument_id = instrument_id\n        self.bids = bids\n        self.asks = asks\n\n\nclass LighterTrade(Data):\n    \"\"\"\n    Represents a trade tick from Lighter.\n    \"\"\"\n    def __init__(\n        self,\n        instrument_id: InstrumentId,\n        price: Price,\n        size: Quantity,\n        aggressor_side: OrderSide,\n        trade_id: TradeId,\n        ts_event: int,\n        ts_init: int,\n    ) -> None:\n        super().__init__(ts_event=ts_event, ts_init=ts_init)\n        self.instrument_id = instrument_id\n        self.price = price\n        self.size = size\n        self.aggressor_side = aggressor_side\n        self.trade_id = trade_id",
    "execution.py": "import hmac\nimport hashlib\n\nfrom nautilus_trader.core.correctness import PyCondition\nfrom nautilus_trader.core.message import Event\nfrom nautilus_trader.execution.client import ExecutionClient\nfrom nautilus_trader.execution.messages import CancelOrder, SubmitOrder\nfrom nautilus_trader.model.enums import OrderSide, OrderType, TimeInForce, OrderStatus\nfrom nautilus_trader.model.identifiers import ClientOrderId, InstrumentId, VenueOrderId\nfrom nautilus_trader.model.orders import LimitOrder, MarketOrder\n\nfrom nautilus_trader.adapters.lighter.config import LighterConfig\nfrom nautilus_trader.adapters.lighter.constants import (\n    VENUE,\n    HEADER_CHAIN_ID,\n    HEADER_API_KEY,\n    HEADER_TIMESTAMP,\n    HEADER_SIGNATURE,\n    ORDER_STATUS_MAP,\n)\n\n\nclass LighterExecutionClient(ExecutionClient):\n    \"\"\"\n    Provides execution functionality for the Lighter DEX.\n    \"\"\"\n\n    def __init__(self, config: LighterConfig) -> None:\n        super().__init__(name=VENUE, config=config)\n        self._config = config\n        # In a real implementation, initialize HTTP client here\n        # self._http_client = ...\n\n    def _generate_signature(self, method: str, path: str, body: str, timestamp: int) -> str:\n        \"\"\"\n        Generate SHA256 signature for authenticated requests.\n        Payload format: timestamp + method + requestPath + body\n        \"\"\"\n        payload = f\"{timestamp}{method}{path}{body}\"\n        message = payload.encode(\"utf-8\")\n        secret = self._config.api_secret.encode(\"utf-8\")\n        return hmac.new(secret, message, hashlib.sha256).hexdigest()\n\n    def _get_headers(self, method: str, path: str, body: str = \"\") -> dict:\n        \"\"\"\n        Construct headers including authentication.\n        \"\"\"\n        timestamp = self._clock.timestamp_ms()\n        signature = self._generate_signature(method, path, body, timestamp)\n\n        return {\n            HEADER_CHAIN_ID: self._config.chain_id,\n            HEADER_API_KEY: self._config.api_key,\n            HEADER_TIMESTAMP: str(timestamp),\n            HEADER_SIGNATURE: signature,\n        }\n\n    def submit_order(self, command: SubmitOrder) -> None:\n        PyCondition.not_none(command, \"command\")\n        PyCondition.not_none(command.order, \"command.order\")\n        order = command.order\n\n        self._log.debug(f\"Submitting order: {order}\")\n\n        if isinstance(order, LimitOrder):\n            self._submit_limit_order(order)\n        elif isinstance(order, MarketOrder):\n            self._submit_market_order(order)\n        else:\n            self._log.error(f\"Cannot submit order type {type(order)}\")\n\n    def _submit_limit_order(self, order: LimitOrder) -> None:\n        path = \"/v1/order\"\n        method = \"POST\"\n        \n        # Construct payload according to schema\n        payload = {\n            \"chainId\": self._config.chain_id,\n            \"symbol\": order.instrument_id.symbol.value, # Format BASE-QUOTE\n            \"side\": order.side.value.upper(),\n            \"type\": \"LIMIT\",\n            \"price\": str(order.price),\n            \"quantity\": str(order.quantity),\n            \"clientOrderId\": order.client_order_id.value,\n            \"tif\": \"GTC\", # Schema defaults cancel behavior to GTC\n        }\n        \n        # Implementation note: JSON dump payload to string for body if needed for signature\n        # Logic to send HTTP request would go here\n        # response = self._http_client.post(...)\n        # self._handle_order_response(response, order)\n        pass\n\n    def _submit_market_order(self, order: MarketOrder) -> None:\n        path = \"/v1/order\"\n        method = \"POST\"\n        \n        payload = {\n            \"chainId\": self._config.chain_id,\n            \"symbol\": order.instrument_id.symbol.value,\n            \"side\": order.side.value.upper(),\n            \"type\": \"MARKET\",\n            \"quantity\": str(order.quantity),\n            \"clientOrderId\": order.client_order_id.value,\n        }\n        \n        # Logic to send HTTP request would go here\n        pass\n\n    def cancel_order(self, command: CancelOrder) -> None:\n        PyCondition.not_none(command, \"command\")\n        self._log.debug(f\"Canceling order: {command}\")\n        # Cancel logic not explicitly defined in REST endpoints schema, \n        # but standard behavior implied by order_model.\n        pass\n\n    def _handle_order_response(self, response: dict, order) -> None:\n        \"\"\"\n        Parse order response and generate events.\n        \"\"\"\n        # Example response parsing based on schema fields\n        # order_id = response.get(\"orderId\")\n        # status_str = response.get(\"status\")\n        # status = ORDER_STATUS_MAP.get(status_str)\n        # \n        # if status:\n        #    venue_order_id = VenueOrderId(str(order_id))\n        #    self._generate_order_accepted(order.client_order_id, venue_order_id, ...)\n        pass",
    "factories.py": "from nautilus_trader.adapters.lighter.config import LighterConfig\nfrom nautilus_trader.adapters.lighter.data import LighterDataClient\nfrom nautilus_trader.adapters.lighter.execution import LighterExecutionClient\nfrom nautilus_trader.core.correctness import PyCondition\nfrom nautilus_trader.live.factories import LiveDataClientFactory, LiveExecutionClientFactory\n\n\nclass LighterDataClientFactory(LiveDataClientFactory):\n    \"\"\"\n    Factory for creating LighterDataClient instances.\n    \"\"\"\n\n    def create(self, **kwargs) -> \"LighterDataClient\":\n        config = LighterConfig(**kwargs)\n        return LighterDataClient(config=config)\n\n\nclass LighterExecutionClientFactory(LiveExecutionClientFactory):\n    \"\"\"\n    Factory for creating LighterExecutionClient instances.\n    \"\"\"\n\n    def create(self, **kwargs) -> \"LighterExecutionClient\":\n        config = LighterConfig(**kwargs)\n        return LighterExecutionClient(config=config)",
    "providers.py": "from typing import Optional\n\nfrom nautilus_trader.adapters.lighter.config import LighterConfig\nfrom nautilus_trader.adapters.lighter.data import LighterDataClient\nfrom nautilus_trader.core.correctness import PyCondition\nfrom nautilus_trader.model.data import Instrument\nfrom nautilus_trader.model.enums import AssetClass\nfrom nautilus_trader.model.identifiers import InstrumentId, Symbol, Venue\nfrom nautilus_trader.model.objects import Money, Price, Quantity\n\n\nclass LighterInstrumentProvider:\n    \"\"\"\n    Provides instruments for the Lighter DEX.\n    \"\"\"\n\n    def __init__(self, client: \"LighterDataClient\", config: LighterConfig):\n        self._client = client\n        self._config = config\n        self._cache: dict[str, Instrument] = {}\n\n    async def load_all_async(self) -> list[Instrument]:\n        \"\"\"\n        Load all instruments from the exchange via the Tickers endpoint.\n        \"\"\"\n        self._log.info(\"Loading instruments for Lighter.\")\n        \n        # Fetch tickers to discover instruments\n        instruments = []\n        \n        # Logic to call REST endpoint: /v1/tickers?chainId=chainId\n        # tickers = await self._client.get_tickers()\n        # for ticker in tickers:\n        #    instrument = self._parse_instrument(ticker)\n        #    instruments.append(instrument)\n        \n        return instruments\n\n    def get(self, instrument_id: InstrumentId) -> Optional[Instrument]:\n        return self._cache.get(instrument_id.value)\n\n    def _parse_instrument(self, ticker_data: dict) -> Instrument:\n        \"\"\"\n        Parse ticker data into Nautilus Instrument object.\n        Schema: symbol, lastPrice, volume, priceStep, sizeStep\n        Metadata: price_precision=8, quantity_precision=8, contract_size=1\n        \"\"\"\n        symbol_str = ticker_data.get(\"symbol\")\n        PyCondition.valid_string(symbol_str, \"symbol\")\n        \n        # Assuming format BASE-QUOTE\n        symbol = Symbol(symbol_str)\n        venue = Venue(VENUE)\n        instrument_id = InstrumentId(symbol, venue)\n        \n        price_precision = 8 # From schema\n        size_precision = 8  # From schema\n        price_increment = Price.from_str(ticker_data.get(\"priceStep\", \"0.00000001\"))\n        size_increment = Quantity.from_str(ticker_data.get(\"sizeStep\", \"0.00000001\"))\n        \n        # Construct Spot Instrument (since perps/futures are false)\n        # Note: Asset Class and asset info requires mapping BASE and QUOTE strings\n        # This is a placeholder for the full Instrument construction which requires\n        # detailed asset definitions not fully provided in the simplified schema.\n        \n        return Instrument(\n            instrument_id=instrument_id,\n            raw_symbol=symbol_str,\n            asset_class=AssetClass.SPOT,\n            # ... additional parameters required by Instrument class\n        )"
  }
}
```