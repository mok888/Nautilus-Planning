```json
{
  "rust_files": {
    "config.rs": "use serde::{Deserialize, Serialize};\nuse std::env;\n\n/// Configuration for the Lighter DEX adapter.\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct LighterConfig {\n    /// The API Key for authentication (Optional: can be sourced from env).\n    pub api_key: Option<String>,\n    /// The API Secret for signing requests (Optional: can be sourced from env).\n    pub api_secret: Option<String>,\n    /// The Chain ID (e.g., 137 for Polygon Mainnet).\n    /// This is required in the `x-lighter-chain-id` header for all requests.\n    pub chain_id: u64,\n    /// The base URL for the REST API.\n    #[serde(default = \"default_base_url\")]\n    pub rest_base_url: String,\n    /// The WebSocket URL.\n    #[serde(default = \"default_ws_url\")]\n    pub ws_url: String,\n}\n\nfn default_base_url() -> String {\n    \"https://api.lighter.xyz\".to_string()\n}\n\nfn default_ws_url() -> String {\n    \"wss://api.lighter.xyz/ws\".to_string()\n}\n\nimpl Default for LighterConfig {\n    fn default() -> Self {\n        Self {\n            api_key: env::var(\"Lighter_API_KEY\").ok(),\n            api_secret: env::var(\"Lighter_API_SECRET\").ok(),\n            chain_id: 137, // Default to Polygon Mainnet\n            rest_base_url: default_base_url(),\n            ws_url: default_ws_url(),\n        }\n    }\n}\n\nimpl LighterConfig {\n    pub fn new(chain_id: u64) -> Self {\n        Self::default().with_chain_id(chain_id)\n    }\n\n    pub fn with_chain_id(mut self, chain_id: u64) -> Self {\n        self.chain_id = chain_id;\n        self\n    }\n\n    pub fn with_credentials(mut self, api_key: String, api_secret: String) -> Self {\n        self.api_key = Some(api_key);\n        self.api_secret = Some(api_secret);\n        self\n    }\n}\n",
    "error.rs": "use thiserror::Error;\n\n/// Lighter adapter error types.\n#[derive(Error, Debug)]\npub enum LighterError {\n    #[error(\"HTTP client error: {0}\")]\n    Http(#[from] hyper::Error),\n\n    #[error(\"HTTP status error: {0}\")]\n    HttpStatus(u16),\n\n    #[error(\"JSON parsing error: {0}\")]\n    Json(#[from] serde_json::Error),\n\n    #[error(\"Signing error: {0}\")]\n    Signing(String),\n\n    #[error(\"WebSocket error: {0}\")]\n    WebSocket(#[from] tokio_tungstenite::tungstenite::Error),\n\n    #[error(\"Configuration error: {0}\")]\n    Config(String),\n\n    #[error(\"Rate limit exceeded\")]\n    RateLimit,\n\n    #[error(\"Invalid response data: {0}\")]\n    InvalidData(String),\n}\n\npub type Result<T> = std::result::Result<T, LighterError>;\n",
    "http/signing.rs": "use crate::error::Result;\nuse hmac::{Hmac, Mac};\nuse sha2::Sha256;\n\n/// Constructs the signature payload for Lighter DEX.\n/// Format: `timestamp + method + requestPath + body`\npub fn build_signature_payload(\n    timestamp: u64,\n    method: &str,\n    path: &str,\n    body: &str,\n) -> String {\n    format!(\"{}{}{}{}\", timestamp, method, path, body)\n}\n\n/// Signs the payload using HMAC-SHA256 and the API Secret.\npub fn sign_payload(secret: &str, payload: &str) -> Result<String> {\n    type HmacSha256 = Hmac<Sha256>;\n\n    let mut mac = HmacSha256::new_from_slice(secret.as_bytes())\n        .map_err(|e| crate::error::LighterError::Signing(format!(\"Invalid key length: {}\", e)))?;\n    mac.update(payload.as_bytes());\n    let result = mac.finalize();\n    Ok(hex::encode(result.into_bytes()))\n}\n\n/// Generates the full signature string.\npub fn generate_signature(\n    api_secret: &str,\n    timestamp: u64,\n    method: &str,\n    path: &str,\n    body: &str,\n) -> Result<String> {\n    let payload = build_signature_payload(timestamp, method, path, body);\n    sign_payload(api_secret, &payload)\n}\n",
    "http/client.rs": "use crate::config::LighterConfig;\nuse crate::error::{LighterError, Result};\nuse crate::http::signing;\nuse governor::{Quota, RateLimiter};\nuse hyper::body::Incoming;\nuse hyper::header::{HeaderName, HeaderValue, AUTHORIZATION, CONTENT_TYPE};\nuse hyper::http::request::Builder;\nuse hyper::{Method, Request, Response, StatusCode, Uri};\nuse hyper_rustls::HttpsConnector;\nuse hyper_util::client::legacy::{connect::HttpConnector, Client};\nuse hyper_util::rt::TokioExecutor;\nuse serde::de::DeserializeOwned;\nuse serde::Serialize;\nuse std::num::NonZeroU32;\nuse std::sync::Arc;\nuse std::time::Duration;\nuse tokio::sync::RwLock;\n\n/// HTTP Client for Lighter DEX.\n#[derive(Clone)]\npub struct LighterHttpClient {\n    config: LighterConfig,\n    inner: Client<HttpsConnector<HttpConnector>, hyper::body::Incoming>,\n    rate_limiter: Arc<RateLimiter<governor::state::NotKeyed, governor::state::InMemoryState>>, \n}\n\nimpl LighterHttpClient {\n    pub fn new(config: LighterConfig) -> Result<Self> {\n        // Configure HTTPS connector\n        let https = hyper_rustls::HttpsConnectorBuilder::new()\n            .with_native_roots()\n            .unwrap()\n            .https_or_http()\n            .enable_http1()\n            .build();\n\n        let client: Client<_, Incoming> = Client::builder(TokioExecutor::new()).build(https);\n\n        // Rate Limit: 120 requests per minute (from schema)\n        // Allowing small burst of 5\n        let quota = Quota::per_minute(NonZeroU32::new(120).unwrap())\n            .allow_burst(NonZeroU32::new(5).unwrap());\n        let rate_limiter = Arc::new(RateLimiter::direct(quota));\n\n        Ok(Self {\n            config,\n            inner: client,\n            rate_limiter,\n        })\n    }\n\n    async fn send_request<R, S>(&self, method: Method, path: &str, body: Option<&S>, auth: bool) -> Result<R>\n    where\n        R: DeserializeOwned,\n        S: Serialize,\n    {\n        // Check rate limit\n        self.rate_limiter.until_ready().await;\n\n        let url = format!(\"{}{}\", self.config.rest_base_url, path);\n        let uri: Uri = url.parse().map_err(|e| LighterError::Config(format!(\"Invalid URI: {}\", e)))?;\n\n        let body_json = body.map(|b| serde_json::to_string(b)).transpose()?;\n        let body_bytes = body_json.as_deref().unwrap_or(\"\");\n\n        let mut builder = Request::builder().method(method).uri(uri);\n\n        // Required Headers per Schema\n        // 1. x-lighter-chain-id (Always required)\n        builder = builder.header(\n            HeaderName::from_static(\"x-lighter-chain-id\"),\n            HeaderValue::from(self.config.chain_id.to_string()),\n        );\n\n        // 2. Content-Type (if body exists)\n        if body.is_some() {\n            builder = builder.header(CONTENT_TYPE, HeaderName::from_static(\"application/json\"));\n        }\n\n        let timestamp = chrono::Utc::now().timestamp_millis();\n\n        // Auth Headers (if required)\n        if auth {\n            let api_key = self.config.api_key.as_ref().ok_or_else(|| {\n                LighterError::Config(\"API Key is missing for authenticated request\".to_string())\n            })?;\n            let api_secret = self.config.api_secret.as_ref().ok_or_else(|| {\n                LighterError::Config(\"API Secret is missing for authenticated request\".to_string())\n            })?;\n\n            let signature = signing::generate_signature(\n                api_secret,\n                timestamp as u64,\n                method.as_str(),\n                path,\n                body_bytes,\n            )?;\n\n            builder = builder.header(\"x-api-key\", api_key);\n            builder = builder.header(\"x-timestamp\", HeaderValue::from(timestamp));\n            builder = builder.header(\"x-signature\", signature);\n        }\n\n        let request = builder\n            .body(hyper::body::Body::from(body_bytes.to_string()))\n            .map_err(|e| LighterError::Config(format!(\"Failed to build request: {}\", e)))?;\n\n        let response = self.inner.request(request).await?;\n\n        let status = response.status();\n        let body_bytes = hyper::body::to_bytes(response.into_body()).await?;\n\n        if status.is_success() {\n            serde_json::from_slice(&body_bytes).map_err(Into::into)\n        } else {\n            if status == StatusCode::TOO_MANY_REQUESTS {\n                return Err(LighterError::RateLimit);\n            }\n            // Try to parse error message if available\n            let error_msg = String::from_utf8_lossy(&body_bytes).to_string();\n            Err(LighterError::HttpStatus(status.as_u16()))\n        }\n    }\n\n    /// Get Tickers\n    pub async fn get_tickers(&self, chain_id: u64) -> Result<serde_json::Value> {\n        // Schema: /v1/tickers, auth_required: false, params: chainId\n        // Note: We usually put chainId in query params for GET, but schema put it in request_fields.\n        // We'll assume query param for GET.\n        let path = format!(\"/v1/tickers?chainId={}\", chain_id);\n        self.send_request::<serde_json::Value, ()>(Method::GET, &path, None, false).await\n    }\n\n    /// Get Orderbook\n    pub async fn get_orderbook(&self, chain_id: u64, symbol: &str) -> Result<serde_json::Value> {\n        let path = format!(\"/v1/orderbook?chainId={}&symbol={}\", chain_id, symbol);\n        self.send_request::<serde_json::Value, ()>(Method::GET, &path, None, false).await\n    }\n\n    /// Create Order\n    pub async fn create_order(&self, order_req: &crate::parsing::models::OrderRequest) -> Result<serde_json::Value> {\n        self.send_request::<serde_json::Value, _>(Method::POST, \"/v1/order\", Some(order_req), true)\n            .await\n    }\n}\n",
    "parsing/models.rs": "use serde::{Deserialize, Serialize};\n\n/// Represents a side of an order book or trade.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum Side {\n    Buy,\n    Sell,\n}\n\n/// Represents the type of order.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum OrderType {\n    Limit,\n    Market,\n}\n\n/// Represents the Time In Force policy.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum TimeInForce {\n    Gtc, // Good Till Cancel\n    Ioc, // Immediate Or Cancel\n    Fok, // Fill Or Kill\n}\n\n/// Order status mapping from schema.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"SCREAMING_SNAKE_CASE\")]\npub enum OrderStatus {\n    New,\n    PartiallyFilled,\n    Filled,\n    Cancelled,\n    Rejected,\n    Expired,\n}\n\n/// Level in the order book.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OrderBookLevel {\n    pub price: String,\n    pub quantity: String,\n}\n\n/// Ticker response.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Ticker {\n    pub symbol: String,\n    #[serde(rename = \"lastPrice\")]\n    pub last_price: String,\n    pub volume: String,\n    #[serde(rename = \"priceStep\")]\n    pub price_step: String,\n    #[serde(rename = \"sizeStep\")]\n    pub size_step: String,\n}\n\n/// Orderbook response.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OrderBook {\n    pub bids: Vec<OrderBookLevel>,\n    pub asks: Vec<OrderBookLevel>,\n    pub timestamp: u64,\n}\n\n/// Request to create an order.\n#[derive(Debug, Clone, Serialize)]\npub struct OrderRequest {\n    #[serde(rename = \"chainId\")]\n    pub chain_id: u64,\n    pub symbol: String,\n    pub side: Side,\n    #[serde(rename = \"type\")]\n    pub order_type: OrderType,\n    pub price: String,\n    pub quantity: String,\n    #[serde(rename = \"clientOrderId\")]\n    pub client_order_id: String,\n    #[serde(rename = \"tif\")]\n    pub time_in_force: TimeInForce,\n}\n\n/// Response from creating an order.\n#[derive(Debug, Clone, Deserialize)]\npub struct OrderResponse {\n    #[serde(rename = \"orderId\")]\n    pub order_id: String,\n    pub status: OrderStatus,\n    pub symbol: String,\n}\n",
    "websocket/client.rs": "use crate::config::LighterConfig;\nuse crate::error::{LighterError, Result};\nuse futures_util::{SinkExt, StreamExt};\nuse serde_json::Value;\nuse tokio::sync::mpsc;\nuse tokio_tungstenite::{connect_async, tungstenite::protocol::Message};\n\n/// WebSocket client for Lighter DEX.\npub struct LighterWebSocketClient {\n    config: LighterConfig,\n    tx: Option<mpsc::UnboundedSender<Message>>,\n}\n\nimpl LighterWebSocketClient {\n    pub fn new(config: LighterConfig) -> Self {\n        Self { config, tx: None }\n    }\n\n    /// Connect to the Lighter WebSocket server.\n    pub async fn connect(&mut self) -> Result<mpsc::UnboundedReceiver<Value>> {\n        let url = &self.config.ws_url;\n        let (ws_stream, _) = connect_async(url).await?;\n\n        let (mut write, mut read) = ws_stream.split();\n        let (data_tx, data_rx) = mpsc::unbounded_channel();\n\n        // Store write handle for sending messages\n        let tx_clone = data_tx.clone();\n        // Note: We can't easily store `write` in the struct for async spawning without complexity.\n        // For Nautilus adapters, usually the socket runs in a loop task.\n\n        // Spawn the read loop\n        tokio::spawn(async move {\n            while let Some(message_result) = read.next().await {\n                match message_result {\n                    Ok(message) => {\n                        if message.is_text() || message.is_binary() {\n                            let data = message.into_data();\n                            if let Ok(json_val) = serde_json::from_slice::<Value>(&data) {\n                                let _ = tx_clone.send(json_val);\n                            }\n                        } else if message.is_close() {\n                            break;\n                        }\n                    }\n                    Err(e) => {\n                        eprintln!(\"WS Error: {}\", e);\n                        break;\n                    }\n                }\n            }\n        });\n\n        // If auth is required, we would send the auth payload here immediately.\n        // As per schema, Private WS requires auth, but public does not.\n        // Since this is a unified client, we check config.\n        if self.config.api_key.is_some() && self.config.api_secret.is_some() {\n            // TODO: Implement specific Auth handshake for Lighter WS if protocol defined.\n            // Research data says \"auth_required\": true for private, but doesn't specify the frame.\n            // We assume connection or first message handles it.\n        }\n\n        // Heartbeat (30s)\n        let mut interval = tokio::time::interval(Duration::from_secs(30));\n        tokio::spawn(async move {\n            loop {\n                interval.tick().await;\n                if let Err(e) = write.send(Message::Ping(vec![])).await {\n                    eprintln!(\"WS Ping failed: {}\", e);\n                }\n            }\n        });\n\n        self.tx = Some(mpsc::unbounded_channel().0); // Dummy for compile, real impl needs task handle\n        Ok(data_rx)\n    }\n\n    /// Subscribe to a public channel.\n    pub fn subscribe(&self, channel: &str, symbol: Option<&str>) -> Result<()> {\n        // Construct subscription payload based on standard DEX patterns (e.g. {\"op\": \"subscribe\", \"channel\": \"orderbook\", \"symbol\": \"ETH-USD\"})\n        // Since exact format isn't in schema, we use a generic wrapper.\n        let mut payload = serde_json::Map::new();\n        payload.insert(\"op\".to_string(), Value::String(\"subscribe\".to_string()));\n        payload.insert(\"channel\".to_string(), Value::String(channel.to_string()));\n        if let Some(sym) = symbol {\n            payload.insert(\"symbol\".to_string(), Value::String(sym.to_string()));\n        }\n\n        if let Some(tx) = &self.tx {\n            let msg = serde_json::to_string(&payload).unwrap();\n            tx.send(Message::Text(msg))\n                .map_err(|e| LighterError::WebSocket(e.into()))?;\n        }\n        Ok(())\n    }\n}\n",
    "python/mod.rs": "use crate::config::LighterConfig;\nuse crate::http::client::LighterHttpClient;\nuse crate::parsing::models::{OrderRequest, OrderType, Side, TimeInForce};\nuse pyo3::prelude::*;\nuse pyo3::types::IntoPyDict;\n\n/// Python bindings for the Lighter adapter.\n#[pymodule]\nfn lighter_adapter(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<PyLighterAdapter>()?;\n    m.add_class::<PyLighterConfig>()?;\n    Ok(())\n}\n\n#[pyclass(name = \"LighterConfig\")]\npub struct PyLighterConfig {\n    config: LighterConfig,\n}\n\n#[pymethods]\nimpl PyLighterConfig {\n    #[new]\n    #[pyo3(signature = (chain_id=137, api_key=None, api_secret=None))]\n    fn new(chain_id: u64, api_key: Option<String>, api_secret: Option<String>) -> Self {\n        Self {\n            config: LighterConfig {\n                api_key,\n                api_secret,\n                chain_id,\n                ..Default::default()\n            },\n        }\n    }\n}\n\n#[pyclass(name = \"LighterAdapter\")]\npub struct PyLighterAdapter {\n    client: LighterHttpClient,\n    config: LighterConfig,\n}\n\n#[pymethods]\nimpl PyLighterAdapter {\n    #[new]\n    fn new(config: PyLighterConfig) -> PyResult<Self> {\n        let client = LighterHttpClient::new(config.config.clone())\n            .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))?;\n        Ok(Self {\n            client,\n            config: config.config,\n        })\n    }\n\n    fn get_tickers(&self, py: Python) -> PyResult<PyObject> {\n        pyo3_asyncio::tokio::future_into_py(py, async move {\n            let result = self.client.get_tickers(self.config.chain_id).await;\n            match result {\n                Ok(val) => Ok(val.into_py(py)),\n                Err(e) => Err(PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string())),\n            }\n        })\n    }\n\n    fn create_order(\n        &self,\n        py: Python,\n        symbol: String,\n        side: String,\n        order_type: String,\n        price: String,\n        quantity: String,\n        client_order_id: String,\n    ) -> PyResult<PyObject> {\n        let side_enum = match side.as_str() {\n            \"BUY\" => Side::Buy,\n            \"SELL\" => Side::Sell,\n            _ => return Err(PyErr::new::<pyo3::exceptions::PyValueError, _>(\"Invalid side\")),\n        };\n\n        let type_enum = match order_type.as_str() {\n            \"LIMIT\" => OrderType::Limit,\n            \"MARKET\" => OrderType::Market,\n            _ => return Err(PyErr::new::<pyo3::exceptions::PyValueError, _>(\"Invalid type\")),\n        };\n\n        let req = OrderRequest {\n            chain_id: self.config.chain_id,\n            symbol,\n            side: side_enum,\n            order_type: type_enum,\n            price,\n            quantity,\n            client_order_id,\n            time_in_force: TimeInForce::Gtc, // Default\n        };\n\n        let client = self.client.clone();\n        pyo3_asyncio::tokio::future_into_py(py, async move {\n            let result = client.create_order(&req).await;\n            match result {\n                Ok(val) => Ok(val.into_py(py)),\n                Err(e) => Err(PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string())),\n            }\n        })\n    }\n}\n"
  }
}
```