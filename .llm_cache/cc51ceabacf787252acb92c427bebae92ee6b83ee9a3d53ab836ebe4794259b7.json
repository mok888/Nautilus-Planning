```json
{
  "rust_files": {
    "src/config.rs": "use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LighterConfig {\n    pub api_key: String,\n    pub secret_key: String,\n    #[serde(default = \"default_chain_id\")]\n    pub chain_id: String,\n    #[serde(default = \"default_base_url\")]\n    pub base_url: String,\n    #[serde(default = \"default_ws_url\")]\n    pub ws_url: String,\n}\n\nfn default_chain_id() -> String {\n    \"137\".to_string() // Polygon Mainnet\n}\n\nfn default_base_url() -> String {\n    \"https://api.lighter.xyz\".to_string()\n}\n\nfn default_ws_url() -> String {\n    \"wss://api.lighter.xyz/ws\".to_string()\n}",
    "src/error.rs": "use thiserror::Error;\n\npub type Result<T> = std::result::Result<T, LighterError>;\n\n#[derive(Debug, Error)]\npub enum LighterError {\n    #[error(\"Network error: {0}\")]\n    Network(#[from] hyper::Error),\n    \n    #[error(\"HTTP error: {0}\")]\n    Http(String),\n    \n    #[error(\"Serialization error: {0}\")]\n    Serialization(#[from] serde_json::Error),\n    \n    #[error(\"Signing error: {0}\")]\n    Signing(String),\n    \n    #[error(\"Rate limit exceeded\")]\n    RateLimitExceeded,\n    \n    #[error(\"Authentication failed\")]\n    Authentication,\n    \n    #[error(\"Invalid response from exchange: {0}\")]\n    InvalidResponse(String),\n    \n    #[error(\"WebSocket error: {0}\")]\n    WebSocket(#[from] tokio_tungstenite::tungstenite::Error),\n}",
    "src/parsing/models.rs": "use serde::{Deserialize, Serialize};\n\n// --- Tickers ---\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct Ticker {\n    pub symbol: String,\n    #[serde(rename = \"lastPrice\")]\n    pub last_price: String,\n    pub volume: String,\n    #[serde(rename = \"priceStep\")]\n    pub price_step: String,\n    #[serde(rename = \"sizeStep\")]\n    pub size_step: String,\n}\n\n// --- Orderbook ---\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct OrderBook {\n    pub asks: Vec<[String; 2]>, // [price, size]\n    pub bids: Vec<[String; 2]>, // [price, size]\n    pub timestamp: u64,\n}\n\n// --- Order ---\n\n#[derive(Debug, Clone, Serialize)]\npub struct CreateOrderRequest {\n    #[serde(rename = \"chainId\")]\n    pub chain_id: String,\n    pub symbol: String,\n    pub side: String, // \"BUY\" or \"SELL\"\n    #[serde(rename = \"type\")]\n    pub order_type: String, // \"LIMIT\" or \"MARKET\"\n    pub price: String,\n    pub quantity: String,\n    #[serde(rename = \"clientOrderId\")]\n    pub client_order_id: String,\n    pub tif: String, // Time in Force, e.g., \"GTC\"\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct OrderResponse {\n    #[serde(rename = \"orderId\")]\n    pub order_id: String,\n    pub status: String,\n    pub symbol: String,\n}",
    "src/http/signing.rs": "use crate::config::LighterConfig;\nuse crate::error::Result;\nuse chrono::Utc;\nuse hmac::{Hmac, Mac};\nuse sha2::Sha256;\n\ntype HmacSha256 = Hmac<Sha256>;\n\npub fn generate_signature(\n    config: &LighterConfig,\n    method: &str,\n    path: &str,\n    body: &str,\n) -> Result<(String, String)> {\n    let timestamp = Utc::now().timestamp_millis().to_string();\n    \n    // Construct payload: timestamp + method + requestPath + body\n    let payload = format!(\"{}{}{}{}\", timestamp, method, path, body);\n    \n    let mut mac = HmacSha256::new_from_slice(config.secret_key.as_bytes())\n        .map_err(|e| crate::error::LighterError::Signing(e.to_string()))?;\n    \n    mac.update(payload.as_bytes());\n    let signature = hex::encode(mac.finalize().into_bytes());\n    \n    Ok((timestamp, signature))\n}",
    "src/http/client.rs": "use crate::config::LighterConfig;\nuse crate::error::{LighterError, Result};\nuse crate::http::signing::generate_signature;\nuse crate::parsing models::{OrderBook, OrderResponse, Ticker};\n\nuse hyper::body::{Bytes, Incoming};\nuse hyper::header::{AUTHORIZATION, CONTENT_TYPE};\nuse hyper::Request;\nuse hyper::{Method, StatusCode, Uri};\nuse hyper_util::client::legacy::connect::HttpConnector;\nuse hyper_util::client::legacy::Client;\nuse hyper_util::rt::TokioExecutor;\nuse http_body_util::{BodyExt, Full};\nuse hyper_rustls::HttpsConnector;\nuse governor::{\n    clock::DefaultClock,\n    state::{InMemoryState, NotKeyed},\n    Quota, RateLimiter,\n};\nuse serde::de::DeserializeOwned;\nuse std::num::NonZeroU32;\nuse std::sync::Arc;\nuse std::time::Duration;\n\npub struct HttpClient {\n    config: LighterConfig,\n    client: Client<HttpsConnector<HttpConnector>, Full<Bytes>>,\n    rate_limiter: Arc<RateLimiter<NotKeyed, InMemoryState, DefaultClock>>,\n}\n\nimpl HttpClient {\n    pub fn new(config: LighterConfig) -> Self {\n        let https = hyper_rustls::HttpsConnectorBuilder::new()\n            .with_native_roots()\n            .https_or_http()\n            .enable_http1()\n            .build();\n\n        let client: Client<_, Full<Bytes>> = Client::builder(TokioExecutor::new()).build(https);\n\n        // Rate limit: 120 requests per minute = 2 per second\n        let quota = Quota::per_minute(NonZeroU32::new(120).unwrap());\n        let rate_limiter = RateLimiter::direct(quota);\n\n        Self {\n            config,\n            client,\n            rate_limiter: Arc::new(rate_limiter),\n        }\n    }\n\n    async fn request<B, R, O>(&self, method: Method, path: &str, body: B) -> Result<O>\n    where\n        B: serde::Serialize,\n        O: DeserializeOwned,\n    {\n        // Rate limiting check (blocking for simplicity in this layer, non-blocking available via governor)\n        self.rate_limiter.until_ready().await;\n\n        let body_json = if method == Method::POST || method == Method::PUT {\n            serde_json::to_string(&body)?\n        } else {\n            String::new()\n        };\n\n        let (timestamp, signature) = generate_signature(&self.config, method.as_str(), path, &body_json)?;\n\n        let url_str = format!(\"{}{}\", self.config.base_url, path);\n        let uri: Uri = url_str.parse().map_err(|e| LighterError::Http(e.to_string()))?;\n\n        let mut req_builder = Request::builder()\n            .method(method)\n            .uri(uri)\n            .header(\"x-lighter-chain-id\", &self.config.chain_id)\n            .header(\"x-api-key\", &self.config.api_key)\n            .header(\"x-timestamp\", timestamp)\n            .header(\"x-signature\", signature)\n            .header(CONTENT_TYPE, \"application/json\");\n\n        let req = if method == Method::POST || method == Method::PUT {\n            req_builder\n                .body(Full::new(Bytes::from(body_json)))\n                .map_err(|e| LighterError::Http(e.to_string()))?\n        } else {\n            req_builder\n                .body(Full::new(Bytes::new()))\n                .map_err(|e| LighterError::Http(e.to_string()))?\n        };\n\n        let res = self.client.request(req).await?;\n\n        if res.status() != StatusCode::OK {\n            let status = res.status();\n            let body_bytes = res.collect().await?.to_bytes();\n            let err_str = String::from_utf8_lossy(&body_bytes).to_string();\n            return Err(LighterError::Http(format!(\n                \"Status: {}, Body: {}\",\n                status, err_str\n            )));\n        }\n\n        let body_bytes = res.collect().await?.to_bytes();\n        let parsed: O = serde_json::from_slice(&body_bytes)?;\n        Ok(parsed)\n    }\n\n    // --- Endpoints ---\n\n    pub async fn get_tickers(&self) -> Result<Vec<Ticker>> {\n        // Note: schema says request_fields: chainId. usually query param.\n        // We assume chainId is handled in header for this specific API based on notes, \n        // but if query param needed, we append to path.\n        self.request::<(), _, Vec<Ticker>>(Method::GET, \"/v1/tickers\", ()).await\n    }\n\n    pub async fn get_orderbook(&self, symbol: &str) -> Result<OrderBook> {\n        // Placeholder for query param construction if needed by path logic\n        let path = format!(\"/v1/orderbook?chainId={}&symbol={}\", self.config.chain_id, symbol);\n        self.request::<(), _, OrderBook>(Method::GET, &path, ()).await\n    }\n\n    pub async fn create_order(&self, order_req: crate::parsing::models::CreateOrderRequest) -> Result<OrderResponse> {\n        self.request(Method::POST, \"/v1/order\", order_req).await\n    }\n}",
    "src/websocket/client.rs": "use crate::config::LighterConfig;\nuse crate::error::{LighterError, Result};\nuse crate::http::signing::generate_signature;\nuse futures_util::{SinkExt, StreamExt};\nuse serde_json::Value;\nuse tokio_tungstenite::{connect_async, tungstenite::Message};\n\npub struct WebSocketClient {\n    config: LighterConfig,\n}\n\nimpl WebSocketClient {\n    pub fn new(config: LighterConfig) -> Self {\n        Self { config }\n    }\n\n    pub async fn connect_public(&self) -> Result<impl StreamExt<Item = Result<Message>>> {\n        let url = format!(\"{}\", self.config.ws_url);\n        let (ws_stream, _) = connect_async(url).await?;\n        Ok(ws_stream)\n    }\n\n    pub async fn connect_private(&self) -> Result<impl StreamExt<Item = Result<Message>>> {\n        let url = format!(\"{}\", self.config.ws_url);\n        let (mut ws_stream, _) = connect_async(url).await?;\n\n        // Auth Payload Construction\n        // DEX WebSocket auth usually mirrors REST signature\n        let path = \"/ws\"; // Virtual path for signing\n        let body = \"\";\n        let (timestamp, signature) = generate_signature(&self.config, \"GET\", path, body)?;\n\n        let auth_msg = serde_json::json!({\n            \"method\": \"auth\",\n            \"apiKey\": self.config.api_key,\n            \"timestamp\": timestamp,\n            \"signature\": signature,\n            \"chainId\": self.config.chain_id\n        });\n\n        ws_stream\n            .send(Message::Text(auth_msg.to_string()))\n            .await?;\n\n        Ok(ws_stream)\n    }\n\n    pub async fn subscribe_orderbook(&self, symbol: &str) -> Result<String> {\n        Ok(serde_json::json!({\n            \"method\": \"subscribe\",\n            \"channel\": \"orderbook\",\n            \"symbol\": symbol\n        }).to_string())\n    }\n}",
    "src/python/mod.rs": "use crate::config::LighterConfig;\nuse crate::http::HttpClient;\nuse crate::parsing::models::{CreateOrderRequest, OrderResponse, Ticker};\nuse pyo3::exceptions::PyException;\nuse pyo3::prelude::*;\nuse std::collections::HashMap;\n\n#[pyclass(name = \"LighterConfig\")]\n#[derive(Clone)]\npub struct PyLighterConfig {\n    #[pyo3(get, set)]\n    pub api_key: String,\n    #[pyo3(get, set)]\n    pub secret_key: String,\n    #[pyo3(get, set)]\n    pub chain_id: Option<String>,\n    #[pyo3(get, set)]\n    pub base_url: Option<String>,\n}\n\nimpl From<PyLighterConfig> for LighterConfig {\n    fn from(val: PyLighterConfig) -> Self {\n        LighterConfig {\n            api_key: val.api_key,\n            secret_key: val.secret_key,\n            chain_id: val.chain_id.unwrap_or_else(|| \"137\".to_string()),\n            base_url: val.base_url.unwrap_or_else(|| \"https://api.lighter.xyz\".to_string()),\n            ws_url: \"wss://api.lighter.xyz/ws\".to_string(),\n        }\n    }\n}\n\n#[pyclass(name = \"LighterClient\")]\npub struct PyLighterClient {\n    inner: HttpClient,\n}\n\n#[pymethods]\nimpl PyLighterClient {\n    #[new]\n    fn new(config: PyLighterConfig) -> PyResult<Self> {\n        let rust_config = LighterConfig::from(config);\n        Ok(Self {\n            inner: HttpClient::new(rust_config),\n        })\n    }\n\n    fn get_tickers(&self, py: Python) -> PyResult<Vec<HashMap<String, String>>> {\n        py.allow_threads(|| {\n            tokio::runtime::Runtime::new()\n                .map_err(|e| PyException::new_err(e.to_string()))?\n                .block_on(async {\n                    let tickers = self.inner.get_tickers().await\n                        .map_err(|e| PyException::new_err(e.to_string()))?;\n                    \n                    Ok(tickers.into_iter().map(|t| {\n                        let mut map = HashMap::new();\n                        map.insert(\"symbol\".to_string(), t.symbol);\n                        map.insert(\"lastPrice\".to_string(), t.last_price);\n                        map.insert(\"volume\".to_string(), t.volume);\n                        map.insert(\"priceStep\".to_string(), t.price_step);\n                        map.insert(\"sizeStep\".to_string(), t.size_step);\n                        map\n                    }).collect())\n                })\n        })\n    }\n\n    fn create_order(&self, py: Python, symbol: String, side: String, price: String, quantity: String, client_order_id: String) -> PyResult<HashMap<String, String>> {\n        py.allow_threads(|| {\n            let req = CreateOrderRequest {\n                chain_id: self.inner.config.chain_id.clone(), // Accessing internal config detail for brevity\n                symbol,\n                side,\n                order_type: \"LIMIT\".to_string(), // Default for this stub\n                price,\n                quantity,\n                client_order_id,\n                tif: \"GTC\".to_string(),\n            };\n            \n            tokio::runtime::Runtime::new()\n                .map_err(|e| PyException::new_err(e.to_string()))?\n                .block_on(async {\n                    let res = self.inner.create_order(req).await\n                        .map_err(|e| PyException::new_err(e.to_string()))?;\n                    \n                    let mut map = HashMap::new();\n                    map.insert(\"orderId\".to_string(), res.order_id);\n                    map.insert(\"status\".to_string(), res.status);\n                    map.insert(\"symbol\".to_string(), res.symbol);\n                    Ok(map)\n                })\n        })\n    }\n}\n\n#[pymodule]\nfn nautilus_lighter(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<PyLighterConfig>()?;\n    m.add_class::<PyLighterClient>()?;\n    Ok(())\n}",
    "Cargo.toml": "[package]\nname = \"nautilus-lighter\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\nname = \"nautilus_lighter\"\ncrate-type = [\"cdylib\", \"rlib\"]\n\n[dependencies]\ntokio = { version = \"1.36\", features = [\"full\"] }\nhyper = { version = \"1.2\", features = [\"client\", \"http1\"] }\nhyper-util = { version = \"0.1\", features = [\"client\", \"client-legacy\", \"tokio\"] }\nhyper-rustls = \"0.26\"\nhttp-body-util = \"0.1\"\ntower = \"0.4\"\ngovernor = \"0.6\"\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\nhmac = \"0.12\"\nsha2 = \"0.10\"\nhex = \"0.4\"\nthiserror = \"1.0\"\nchrono = \"0.4\"\npyo3 = { version = \"0.20\", features = [\"extension-module\"] }\ntokio-tungstenite = \"0.21\"\nfutures-util = \"0.3\"\n\n[profile.release]\nopt-level = 3\n"
  }
}
```