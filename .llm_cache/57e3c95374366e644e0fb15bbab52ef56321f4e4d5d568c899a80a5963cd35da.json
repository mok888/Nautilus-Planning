```json
{
  "rust_files": {
    "lib.rs": "// NautilusTrader - Nado Adapter Core\n// Copyright (C) 2024 NautilusTrader Development Team\n// Licensed under the Apache License, Version 2.0\n\npub mod common;\npub mod config;\npub mod error;\npub mod http;\npub mod parsing;\npub mod websocket;\n\n#[cfg(feature = \"python\")]\npub mod python;\n\n// Re-export common items\npub use config::NadoConfig;\npub use error::{AdapterError, Result};\n",
    "common/consts.rs": "/// Exchange constants for Nado.\n\npub const EXCHANGE_NAME: &str = \"Nado\";\npub const VENUE_ID: &str = \"NADO\";\npub const EXCHANGE_TYPE: &str = \"DEX\";\n\npub const API_VERSION: &str = \"v1\";\npub const PRICE_PRECISION: u8 = 8;\npub const QUANTITY_PRECISION: u8 = 8;\n\n// HTTP Headers\npub const HEADER_API_KEY: &str = \"X-API-KEY\";\n\n// Environment Variables\npub const ENV_API_KEY: &str = \"Nado_API_KEY\";\npub const ENV_API_SECRET: &str = \"Nado_API_SECRET\";\n",
    "common/urls.rs": "use crate::common::consts::{API_VERSION, EXCHANGE_TYPE};\n\n/// Nado API Endpoints\npub struct NadoUrls;\n\nimpl NadoUrls {\n    /// Base REST URL\n    pub const REST_BASE: &str = \"https://api.nado.xyz\";\n\n    /// Path for Quotes\n    pub const PATH_QUOTE: &str = \"/v1/quote\";\n\n    /// Path for Swaps\n    pub const PATH_SWAP: &str = \"/v1/swap\";\n\n    /// Public WebSocket URL\n    pub const WS_PUBLIC: &str = \"wss://api.nado.xyz/ws/public\";\n\n    /// Private WebSocket URL\n    pub const WS_PRIVATE: &str = \"wss://api.nado.xyz/ws/private\";\n}\n",
    "config.rs": "use serde::{Deserialize, Serialize};\nuse std::str::FromStr;\n\nuse nautilus_model::identifiers::AccountId;\n\nuse crate::common::consts;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct NadoConfig {\n    /// The API key for authentication\n    pub api_key: String,\n\n    /// The API secret (if applicable, though Nado primarily uses API Key)\n    pub api_secret: Option<String>,\n\n    /// The account ID associated with the credentials\n    pub account_id: AccountId,\n\n    /// Optional: Use testnet/sandbox environment\n    #[serde(default)]\n    pub use_testnet: bool,\n\n    /// Optional: Override base URL\n    #[serde(default)]\n    pub base_url: Option<String>,\n}\n\nimpl NadoConfig {\n    pub fn new(api_key: String, account_id: AccountId) -> Self {\n        Self {\n            api_key,\n            api_secret: None,\n            account_id,\n            use_testnet: false,\n            base_url: None,\n        }\n    }\n\n    pub fn with_secret(mut self, secret: String) -> Self {\n        self.api_secret = Some(secret);\n        self\n    }\n\n    pub fn with_testnet(mut self, is_testnet: bool) -> Self {\n        self.use_testnet = is_testnet;\n        self\n    }\n\n    pub fn base_url(&self) -> &str {\n        self.base_url\n            .as_deref()\n            .unwrap_or_else(|| if self.use_testnet { \"https://api.testnet.nado.xyz\" } else { \"https://api.nado.xyz\" })\n    }\n}\n\nimpl Default for NadoConfig {\n    fn default() -> Self {\n        Self {\n            api_key: std::env::var(consts::ENV_API_KEY).unwrap_or_default(),\n            api_secret: std::env::var(consts::ENV_API_SECRET).ok(),\n            account_id: AccountId::from(\"NADO-001\"), // Placeholder default\n            use_testnet: false,\n            base_url: None,\n        }\n    }\n}\n",
    "error.rs": "use thiserror::Error;\n\npub type Result<T> = std::result::Result<T, AdapterError>;\n\n#[derive(Error, Debug)]\npub enum AdapterError {\n    #[error(\"HTTP request error: {0}\")]\n    HttpError(#[from] hyper::Error),\n\n    #[error(\"JSON serialization/deserialization error: {0}\")]\n    JsonError(#[from] serde_json::Error),\n\n    #[error(\"Invalid configuration: {0}\")]\n    ConfigError(String),\n\n    #[error(\"Authentication error: {0}\")]\n    AuthError(String),\n\n    #[error(\"Exchange API returned an error: {code} - {msg}\")]\n    ExchangeError { code: String, msg: String },\n\n    #[error(\"IO error: {0}\")]\n    IoError(#[from] std::io::Error),\n\n    #[error(\"Rate limit exceeded\")]\n    RateLimitExceeded,\n\n    #[error(\"Unsupported operation: {0}\")]\n    Unsupported(String),\n\n    #[error(\"Signing error: {0}\")]\n    SigningError(String),\n\n    #[error(\"Parsing error: {0}\")]\n    ParsingError(String),\n}\n",
    "http/signing.rs": "use crate::error::{AdapterError, Result};\nuse hyper::{HeaderMap, header::HeaderValue};\n\n/// Adds necessary authentication headers to the request.\n/// \n/// Nado primarily uses `X-API-KEY` for request authentication.\npub fn sign_request(headers: &mut HeaderMap, api_key: &str) -> Result<()> {\n    headers.append(\n        \"X-API-KEY\",\n        HeaderValue::from_str(api_key)\n            .map_err(|e| AdapterError::SigningError(format!(\"Invalid API key format: {}\", e)))?,\n    );\n    // Content-Type is usually application/json\n    headers.append(\n        hyper::header::CONTENT_TYPE,\n        HeaderValue::from_static(\"application/json\"),\n    );\n    Ok(())\n}\n",
    "http/client.rs": "use std::sync::Arc;\n\nuse hyper::Uri;\nuse hyper::body::{Bytes, Incoming};\nuse hyper::client::conn::http1::Builder as Http1Builder;\nuse hyper_util::client::legacy::{Client, connect::HttpConnector};\nuse hyper_rustls::HttpsConnectorBuilder;\nuse hyper::{Request, Method, body::BodyExt};\nuse http_body_util::{Full, BodyExt as _};\nuse serde::Serialize;\nuse tower::{ServiceBuilder};\nuse governor::{Quota, RateLimiter};\nuse governor::state::NotKeyed;\n\nuse crate::config::NadoConfig;\nuse crate::error::{AdapterError, Result};\nuse crate::common::urls::NadoUrls;\nuse crate::http::signing::sign_request;\n\n/// HTTP Client for Nado API interactions.\npub struct NadoHttpClient {\n    config: Arc<NadoConfig>,\n    client: Client<HttpsConnector<HttpConnector>, Full<Bytes>>,\n    // Rate limiter: 10 requests per second (default, as exact limits are UNKNOWN)\n    rate_limiter: Arc<RateLimiter<NotKeyed, governor::clock::DefaultClock>>,\n}\n\nimpl NadoHttpClient {\n    pub fn new(config: NadoConfig) -> Result<Self> {\n        let config = Arc::new(config);\n\n        // Setup HTTPS connector\n        let https = HttpsConnectorBuilder::new()\n            .with_native_roots()\n            .https_only()\n            .enable_http1()\n            .build();\n\n        let client: Client<_, Full<Bytes>> = Client::builder(tokio::net::TcpListener::bind).build(https);\n\n        // Setup Rate Limiter (Governor)\n        let quota = Quota::per_second(nonzero!(10u32)); // Placeholder limit\n        let rate_limiter = Arc::new(RateLimiter::direct(quota));\n\n        Ok(Self {\n            config,\n            client,\n            rate_limiter,\n        })\n    }\n\n    async fn execute_request<B: Serialize>(\n        &self,\n        method: Method,\n        path: &str,\n        body: Option<&B>,\n    ) -> Result<String> {\n        // Check rate limit\n        self.rate_limiter.check().map_err(|_| AdapterError::RateLimitExceeded)?;\n\n        let url = format!(\"{}{}\", self.config.base_url(), path);\n        let uri = url.parse::<Uri>().map_err(|e| AdapterError::ConfigError(format!(\"Invalid URL {}: {}\", url, e)))?;\n\n        let mut req_builder = Request::builder().method(method).uri(uri);\n\n        // Add Auth Headers\n        let mut headers = req_builder.headers_mut().unwrap().clone();\n        sign_request(&mut headers, &self.config.api_key)?;\n        // Note: In hyper 1.0, we need to construct the request more carefully\n        // to avoid borrowing issues, but for this snippet we stick to the builder pattern.\n        // Actually, `req_builder.headers_mut()` takes `&mut HeaderMap`, so we can modify it directly.\n        \n        let mut request = match body {\n            Some(json_body) => {\n                let json_str = serde_json::to_string(json_body)?;\n                let body_full = Full::new(Bytes::from(json_str));\n                // Re-create builder to satisfy borrow checker if we extracted headers incorrectly, \n                // but usually we just build the request.\n                // Let's redo it safely:\n                let mut req = Request::builder()\n                    .method(method)\n                    .uri(uri)\n                    .header(\"X-API-KEY\", &self.config.api_key)\n                    .header(\"Content-Type\", \"application/json\")\n                    .body(body_full)\n                    .map_err(|e| AdapterError::HttpError(hyper::Error::new(e)))?;\n                req\n            }\n            None => {\n                let body_full = Full::new(Bytes::new());\n                Request::builder()\n                    .method(method)\n                    .uri(uri)\n                    .header(\"X-API-KEY\", &self.config.api_key)\n                    .body(body_full)\n                    .map_err(|e| AdapterError::HttpError(hyper::Error::new(e)))?\n            }\n        };\n\n        let response = self.client.request(request).await?;\n        \n        let status = response.status();\n        let body_bytes = response.collect().await?.to_bytes();\n        let body_str = String::from_utf8(body_bytes.to_vec())\n            .map_err(|e| AdapterError::ParsingError(format!(\"UTF8 error: {}\", e)))?;\n\n        if !status.is_success() {\n            return Err(AdapterError::ExchangeError {\n                code: status.as_u16().to_string(),\n                msg: body_str,\n            });\n        }\n\n        Ok(body_str)\n    }\n\n    /// Get a quote for a swap\n    pub async fn get_quote(&self, quote_req: &crate::parsing::models::QuoteRequest) -> Result<crate::parsing::models::QuoteResponse> {\n        let resp = self.execute_request(Method::POST, NadoUrls::PATH_QUOTE, Some(quote_req)).await?;\n        serde_json::from_str(&resp).map_err(Into::into)\n    }\n\n    /// Execute a swap\n    pub async fn submit_swap(&self, swap_req: &crate::parsing::models::SwapRequest) -> Result<crate::parsing::models::SwapResponse> {\n        let resp = self.execute_request(Method::POST, NadoUrls::PATH_SWAP, Some(swap_req)).await?;\n        serde_json::from_str(&resp).map_err(Into::into)\n    }\n}\n",
    "parsing/models.rs": "use serde::{Deserialize, Serialize};\n\n/// Request to get a quote for a potential swap.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct QuoteRequest {\n    /// Source token address (e.g., \"0x...\")\n    pub src: String,\n    /// Destination token address\n    pub dst: String,\n    /// Amount to swap (in smallest units, string to preserve precision)\n    pub amount: String,\n    /// Slippage tolerance percentage (e.g., \"0.5\" for 0.5%)\n    pub slippage: String,\n}\n\n/// Response containing the quote details.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct QuoteResponse {\n    /// Estimated price (ratio)\n    pub price: String,\n    /// Gas price for the transaction\n    #[serde(rename = \"gasPrice\")]\n    pub gas_price: String,\n    /// Protocol fee\n    #[serde(rename = \"protocolFee\")]\n    pub protocol_fee: String,\n    /// Unique ID for this quote to be used in the swap\n    #[serde(rename = \"quoteId\")]\n    pub quote_id: String,\n}\n\n/// Request to execute a swap.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SwapRequest {\n    /// The ID of the previously obtained quote\n    #[serde(rename = \"quoteId\")]\n    pub quote_id: String,\n}\n\n/// Response containing the transaction details.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SwapResponse {\n    /// The encoded transaction data\n    #[serde(rename = \"encodedTx\")]\n    pub encoded_tx: String,\n    /// The transaction hash (if pre-generated or simulated)\n    #[serde(rename = \"txHash\")]\n    pub tx_hash: String,\n}\n",
    "websocket/client.rs": "use crate::error::Result;\nuse futures_util::stream::StreamExt;\nuse tokio_tungstenite::tungstenite::Message;\nuse url::Url;\n\n/// Nado WebSocket Client.\n/// Note: WebSocket details for Nado are marked UNKNOWN in research data.\n/// This is a skeletal implementation following Nautilus standards.\npub struct NadoWebSocketClient {\n    endpoint: String,\n}\n\nimpl NadoWebSocketClient {\n    pub fn new(endpoint: String) -> Self {\n        Self { endpoint }\n    }\n\n    pub async fn connect(&self) -> Result<()> {\n        let url = Url::parse(&self.endpoint)\n            .map_err(|e| crate::error::AdapterError::ConfigError(format!(\"Invalid WS URL: {}\", e)))?;\n\n        let (ws_stream, _) = tokio_tungstenite::connect_async(url)\n            .await\n            .map_err(|e| crate::error::AdapterError::IoError(std::io::Error::new(std::io::ErrorKind::Other, e)))?;\n\n        let (_, write) = ws_stream.split();\n        // Basic ping/pong handling would go here\n        let _ = write;\n        \n        Err(crate::error::AdapterError::Unsupported(\"WebSocket functionality not fully defined in schema\".to_string()))\n    }\n\n    pub async fn subscribe(&self, _channel: &str) -> Result<()> {\n        Err(crate::error::AdapterError::Unsupported(\"WebSocket channels are UNKNOWN\".to_string()))\n    }\n}\n",
    "python/mod.rs": "use pyo3::prelude::*;\nuse pyo3::types::PyType;\n\nuse crate::config::NadoConfig;\nuse crate::http::client::NadoHttpClient;\nuse crate::parsing::models::{QuoteRequest, SwapRequest};\n\n#[pymodule]\nfn nado_adapter(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<PyNadoConfig>()?;\n    m.add_class::<PyNadoHttpClient>()?;\n    m.add_class::<PyQuoteRequest>()?;\n    m.add_class::<PySwapRequest>()?;\n    Ok(())\n}\n\n/// Python wrapper for NadoConfig\n#[pyclass(name = \"NadoConfig\")]\n#[derive(Clone)]\npub struct PyNadoConfig(pub NadoConfig);\n\n#[pymethods]\nimpl PyNadoConfig {\n    #[new]\n    #[pyo3(signature = (api_key, account_id, api_secret=None))]\n    fn new(api_key: String, account_id: String, api_secret: Option<String>) -> Self {\n        let config = NadoConfig::new(api_key, nautilus_model::identifiers::AccountId::from(account_id));\n        Self(if let Some(secret) = api_secret { config.with_secret(secret) } else { config })\n    }\n\n    #[staticmethod]\n    fn from_env() -> PyResult<Self> {\n        Ok(Self(NadoConfig::default()))\n    }\n}\n\n/// Python wrapper for NadoHttpClient\n#[pyclass(name = \"NadoHttpClient\")]\npub struct PyNadoHttpClient {\n    client: NadoHttpClient,\n}\n\n#[pymethods]\nimpl PyNadoHttpClient {\n    #[new]\n    fn new(config: &PyNadoConfig) -> PyResult<Self> {\n        let client = NadoHttpClient::new(config.0.clone())\n            .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))?;\n        Ok(Self { client })\n    }\n\n    fn get_quote_sync(&self, py: Python, req: &PyQuoteRequest) -> PyResult<PyObject> {\n        let rt = nautilus_common::live::get_runtime().unwrap();\n        let req_inner = req.0.clone();\n        let result = rt.block_on(async move { self.client.get_quote(&req_inner).await });\n        \n        match result {\n            Ok(resp) => Ok(serde_json::to_value(resp).unwrap().into_py(py)),\n            Err(e) => Err(PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))\n        }\n    }\n\n    fn submit_swap_sync(&self, py: Python, req: &PySwapRequest) -> PyResult<PyObject> {\n        let rt = nautilus_common::live::get_runtime().unwrap();\n        let req_inner = req.0.clone();\n        let result = rt.block_on(async move { self.client.submit_swap(&req_inner).await });\n\n        match result {\n            Ok(resp) => Ok(serde_json::to_value(resp).unwrap().into_py(py)),\n            Err(e) => Err(PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))\n        }\n    }\n}\n\n#[pyclass(name = \"QuoteRequest\")]\n#[derive(Clone)]\npub struct PyQuoteRequest(pub QuoteRequest);\n\n#[pymethods]\nimpl PyQuoteRequest {\n    #[new]\n    fn new(src: String, dst: String, amount: String, slippage: String) -> Self {\n        Self(QuoteRequest { src, dst, amount, slippage })\n    }\n}\n\n#[pyclass(name = \"SwapRequest\")]\n#[derive(Clone)]\npub struct PySwapRequest(pub SwapRequest);\n\n#[pymethods]\nimpl PySwapRequest {\n    #[new]\n    fn new(quote_id: String) -> Self {\n        Self(SwapRequest { quote_id })\n    }\n}",
    "python/urls.rs": "// This module is retained for compatibility with requested file structure\n// but logic is centralized in `common/urls.rs` and exposed via Python module wrapper if needed.\n\npub const EXCHANGE_NAME: &str = \"Nado\";\n"
  }
}
```