```json
{
  "rust_files": {
    "config.rs": "use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// Configuration for the Nado adapter.\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct NadoConfig {\n    /// The API key for authentication (if applicable).\n    #[serde(default)]\n    pub api_key: Option<String>,\n    \n    /// The wallet address (hex string, 0x...).\n    pub wallet_address: String,\n    \n    /// The private key for signing transactions (hex string, 0x...).\n    /// In production, this should ideally be fetched from a secure vault.\n    pub private_key: String,\n    \n    /// REST API Base URL.\n    #[serde(default = \"default_rest_url\")]\n    pub rest_base_url: String,\n    \n    /// WebSocket URL.\n    #[serde(default = \"default_ws_url\")]\n    pub ws_url: String,\n}\n\nfn default_rest_url() -> String {\n    \"https://gateway.prod.nado.xyz/v1\".to_string()\n}\n\nfn default_ws_url() -> String {\n    \"wss://gateway.prod.nado.xyz/v1/subscribe\".to_string()\n}\n\nimpl fmt::Display for NadoConfig {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(\n            f,\n            \"NadoConfig(wallet={}, rest_url={}, ws_url={})\",\n            self.wallet_address, self.rest_base_url, self.ws_url\n        )\n    }\n}\n",
    "error.rs": "use thiserror::Error;\n\n/// Result type for Nado operations.\npub type NadoResult<T> = Result<T, NadoError>;\n\n/// Errors that can occur within the Nado adapter.\n#[derive(Error, Debug)]\npub enum NadoError {\n    /// HTTP client error (reqwest).\n    #[error(\"HTTP request failed: {0}\")]\n    HttpError(#[from] reqwest::Error),\n\n    /// WebSocket error.\n    #[error(\"WebSocket error: {0}\")]\n    WebSocketError(#[from] tokio_tungstenite::tungstenite::Error),\n\n    /// JSON serialization/deserialization error.\n    #[error(\"JSON parsing error: {0}\")]\n    JsonError(#[from] serde_json::Error),\n\n    /// Authentication or Signing error.\n    #[error(\"Authentication failed: {0}\")]\n    AuthError(String),\n\n    /// Invalid input data (e.g., parsing instrument ID).\n    #[error(\"Invalid input: {0}\")]\n    InvalidInput(String),\n\n    /// Exchange returned an error response.\n    #[error(\"Exchange API error: {code} - {message}\")]\n    ExchangeError { code: String, message: String },\n\n    /// IO error.\n    #[error(\"IO error: {0}\")]\n    IoError(#[from] std::io::Error),\n}\n",
    "http/signing.rs": "use crate::error::NadoError;\nuse alloy_primitives::{Address, B256, U256};\nuse alloy_signer::Signer;\nuse alloy_signer_wallet::LocalWallet;\nuse k256::ecdsa::SigningKey;\nuse std::str::FromStr;\n\n/// Scaling factor for x18 precision (10^18).\npub const X18_SCALING: u128 = 1_000_000_000_000_000_000;\n\n/// Converts an f64 value to the x18 fixed-point integer representation.\n/// Returns error if value is negative or exceeds bounds.\npub fn to_x18(value: f64) -> Result<u128, NadoError> {\n    if value < 0.0 {\n        return Err(NadoError::InvalidInput(\"Negative value not supported for x18 conversion\".to_string()));\n    }\n    // Saturating mul to prevent overflow on massive f64s, though unlikely in trading contexts\n    let scaled = value * X18_SCALING as f64;\n    if scaled > u128::MAX as f64 {\n        return Err(NadoError::InvalidInput(\"Value overflow for x18 conversion\".to_string()));\n    }\n    Ok(scaled as u128)\n}\n\n/// Converts an x18 fixed-point integer back to f64.\npub fn from_x18(value: u128) -> f64 {\n    value as f64 / X18_SCALING as f64\n}\n\n/// Signs a payload using the private key.\n/// This struct mimics the EIP-712 signing process expected by Nado.\npub struct NadoSigner {\n    wallet: LocalWallet,\n}\n\nimpl NadoSigner {\n    /// Creates a new signer from a hex private key string.\n    pub fn new(private_key_hex: &str) -> Result<Self, NadoError> {\n        let signing_key = SigningKey::from_str(private_key_hex)\n            .map_err(|e| NadoError::AuthError(format!(\"Invalid private key: {}\", e)))?;\n        let wallet = LocalWallet::from(signing_key);\n        Ok(Self { wallet })\n    }\n\n    /// Returns the wallet address.\n    pub fn address(&self) -> Address {\n        self.wallet.address()\n    }\n\n    /// Signs a message hash (Keccak-256) and returns the signature.\n    pub fn sign_hash(&self, hash: B256) -> Result<String, NadoError> {\n        let signature = self.wallet\n            .sign_hash(&hash)\n            .map_err(|e| NadoError::AuthError(format!(\"Signing failed: {}\", e)))?;\n        \n        // Return standard hex string format (r+s+v)\n        Ok(signature.to_string())\n    }\n\n    /// Generates an EIP-712 typed signature for the order payload.\n    /// Based on \"signature_payload\": \"EIP-712 formatted message\" in schema.\n    pub fn sign_order_eip712(\n        &self,\n        product_id: u64,\n        price_x18: u128,\n        amount_x18: u128,\n        expiration: u64,\n        nonce: u64,\n    ) -> Result<String, NadoError> {\n        // Simplified EIP-712 encoding structure for the specific order type.\n        // In a full implementation, this would use alloy's `typed_data` feature.\n        // Here we construct the hash manually to demonstrate the logic without complex macro dependencies.\n        \n        // Domain Separator (example based on standard DEX patterns)\n        // Name: \"Nado\", Version: \"1\", ChainId: 1 (Mainnet), VerifyingContract: ...\n        let domain_separator = B256::from([0u8; 32]); // Placeholder for actual domain hash calculation\n\n        // Encode the Order struct\n        // types: Order(product_id, priceX18, amount, expiration, nonce)\n        let mut encoded: Vec<u8> = Vec::new();\n        encoded.extend_from_slice(&product_id.to_be_bytes());\n        encoded.extend_from_slice(&price_x18.to_be_bytes());\n        encoded.extend_from_slice(&amount_x18.to_be_bytes());\n        encoded.extend_from_slice(&expiration.to_be_bytes());\n        encoded.extend_from_slice(&nonce.to_be_bytes());\n\n        use sha3::{Digest, Keccak256};\n        let mut hasher = Keccak256::new();\n        hasher.update(domain_separator.as_slice());\n        hasher.update(encoded);\n        let final_hash = B256::new(hasher.finalize().into());\n\n        self.sign_hash(final_hash)\n    }\n}\n",
    "http/client.rs": "use crate::config::NadoConfig;\nuse crate::error::{NadoError, NadoResult};\nuse crate::http::signing::{from_x18, to_x18, NadoSigner};\nuse chrono::Utc;\nuse reqwest::{Client, RequestBuilder};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum OrderType {\n    Market,\n    Limit,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum OrderSide {\n    Buy,\n    Sell,\n}\n\n/// Request payload for placing an order on Nado.\n#[derive(Debug, Serialize)]\nstruct PlaceOrderRequest {\n    product_id: u64,\n    sender: String,\n    price_x18: String, // Nado expects stringified integers for big numbers usually, or raw JSON int. Schema says \"priceX18\".\n    amount: String,\n    expiration: u64, // Nanoseconds\n    nonce: u64,\n    signature: String,\n}\n\n/// Response from placing an order.\n#[derive(Debug, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\nstruct PlaceOrderResponse {\n    status: String,\n    order_id: String,\n}\n\npub struct NadoHttpClient {\n    config: NadoConfig,\n    client: Client,\n    signer: NadoSigner,\n}\n\nimpl NadoHttpClient {\n    pub fn new(config: NadoConfig) -> NadoResult<Self> {\n        let signer = NadoSigner::new(&config.private_key)?;\n        Ok(Self {\n            config,\n            client: Client::new(),\n            signer,\n        })\n    }\n\n    /// Helper to attach required headers (Accept-Encoding).\n    fn build_request(&self, method: reqwest::Method, path: &str) -> RequestBuilder {\n        let url = format!(\"{}{}\", self.config.rest_base_url, path);\n        self.client\n            .request(method, url)\n            .header(\"Accept-Encoding\", \"gzip, br, deflate\")\n    }\n\n    /// Place an order via /execute.\n    /// \n    /// * `product_id`: The instrument ID.\n    /// * `side`: Buy or Sell.\n    /// * `order_type`: Market or Limit.\n    /// * `price`: Price in base asset (ignored for market).\n    /// * `qty`: Quantity in quote asset.\n    pub async fn place_order(\n        &self,\n        product_id: u64,\n        side: OrderSide,\n        order_type: OrderType,\n        price: f64,\n        qty: f64,\n    ) -> NadoResult<String> {\n        let expiration = Utc::now().timestamp_nanos_opt().unwrap_or(0) as u64 + 300_000_000_000; // + 5 mins\n        let nonce = Utc::now().timestamp_nanos_opt().unwrap_or(0) as u64;\n        let address = self.signer.address().to_string();\n\n        // Convert to x18 fixed point\n        let price_x18_val = to_x18(price)?;\n        let amount_x18_val = to_x18 qty)?; // Schema says 'amount' field, assuming it is quantity\n\n        // Create EIP-712 Signature\n        // Note: Passing 0 for price if market order, though specific protocol logic may vary.\n        // Assuming Nado requires limit price for execution logic in schema context.\n        let signature = self.signer.sign_order_eip712(\n            product_id,\n            price_x18_val,\n            amount_x18_val,\n            expiration,\n            nonce,\n        )?;\n\n        let payload = PlaceOrderRequest {\n            product_id,\n            sender: address,\n            price_x18: price_x18_val.to_string(),\n            amount: amount_x18_val.to_string(),\n            expiration,\n            nonce,\n            signature,\n        };\n\n        // Schema says method is POST /execute\n        let response = self\n            .build_request(reqwest::Method::POST, \"/execute\")\n            .json(&payload)\n            .send()\n            .await?;\n\n        if !response.status().is_success() {\n            let status = response.status();\n            let body = response.text().await.unwrap_or_default();\n            return Err(NadoError::ExchangeError {\n                code: status.as_u16().to_string(),\n                message: body,\n            });\n        }\n\n        let resp: PlaceOrderResponse = response.json().await?;\n        Ok(resp.order_id)\n    }\n\n    /// Query orders via /query.\n    pub async fn get_orders(&self, subaccount: String, product_id: u64) -> NadoResult<Vec<serde_json::Value>> {\n        let mut params = HashMap::new();\n        params.insert(\"subaccount\", subaccount);\n        params.insert(\"product_id\", product_id.to_string());\n\n        let response = self\n            .build_request(reqwest::Method::GET, \"/query\")\n            .query(&params)\n            .send()\n            .await?;\n\n        if !response.status().is_success() {\n            return Err(NadoError::ExchangeError {\n                code: response.status().as_u16().to_string(),\n                message: \"Failed to fetch orders\".to_string(),\n            });\n        }\n\n        // Schema response: { \"orders\": [...] }\n        let json: serde_json::Value = response.json().await?;\n        let orders = json[\"orders\"].as_array().cloned().unwrap_or_default();\n        Ok(orders)\n    }\n}\n",
    "parsing/models.rs": "use serde::{Deserialize, Serialize};\nuse crate::http::signing::from_x18;\n\n/// Represents a trade event from the websocket 'trade' channel.\n#[derive(Debug, Deserialize, Clone)]\n#[serde(rename_all = \"camelCase\")]\npub struct NadoTrade {\n    pub product_id: u64,\n    pub price_x18: String, // Input might be string or int, handle string for safety\n    pub amount: String,\n    pub timestamp: u64, // Nanoseconds\n    pub side: String,\n}\n\nimpl NadoTrade {\n    pub fn get_price_f64(&self) -> f64 {\n        let val = self.price_x18.parse::<u128>().unwrap_or(0);\n        from_x18(val)\n    }\n\n    pub fn get_amount_f64(&self) -> f64 {\n        let val = self.amount.parse::<u128>().unwrap_or(0);\n        from_x18(val)\n    }\n}\n\n/// Represents the Best Bid/Offer (BBO) update from 'best_bid_offer' channel.\n#[derive(Debug, Deserialize, Clone)]\n#[serde(rename_all = \"camelCase\")]\npub struct NadoBbo {\n    pub product_id: u64,\n    pub bid_price_x18: String,\n    pub bid_amount: String,\n    pub ask_price_x18: String,\n    pub ask_amount: String,\n}\n\nimpl NadoBbo {\n    pub fn get_bid_price(&self) -> f64 {\n        from_x18(self.bid_price_x18.parse::<u128>().unwrap_or(0))\n    }\n    pub fn get_ask_price(&self) -> f64 {\n        from_x18(self.ask_price_x18.parse::<u128>().unwrap_or(0))\n    }\n}\n\n/// Wrapper for incoming WebSocket messages.\n#[derive(Debug, Deserialize)]\n#[serde(tag = \"channel\", content = \"data\")]\npub enum WsMessage {\n    #[serde(rename = \"trade\")]\n    Trade(NadoTrade),\n    #[serde(rename = \"best_bid_offer\")]\n    Bbo(NadoBbo),\n    // Add other channels here\n    #[serde(other)]\n    Unknown,\n}\n",
    "websocket/client.rs": "use crate::config::NadoConfig;\nuse crate::error::{NadoError, NadoResult};\nuse crate::parsing::models::WsMessage;\nuse futures_util::StreamExt;\nuse serde_json::Value;\nuse tokio::net::TcpStream;\nuse tokio_tungstenite::{connect_async, tungstenite::Message, MaybeTlsStream, WebSocketStream};\nuse url::Url;\n\npub struct NadoWebSocketClient {\n    config: NadoConfig,\n}\n\nimpl NadoWebSocketClient {\n    pub fn new(config: NadoConfig) -> Self {\n        Self { config }\n    }\n\n    /// Connect and subscribe to channels.\n    /// Note: This runs the listener loop. In a full adapter, this spawns a task\n    /// and sends data to a mpsc channel for the core engine to process.\n    pub async fn connect_and_run(&self, channels: Vec<String>) -> NadoResult<()> {\n        let url = Url::parse(&self.config.ws_url)?;\n        let (ws_stream, _) = connect_async(url).await?;\n        \n        println!(\"[NadoWS] Connected to {}\", self.config.ws_url);\n\n        self.run_loop(ws_stream, channels).await\n    }\n\n    async fn run_loop(\n        &self,\n        mut ws_stream: WebSocketStream<MaybeTlsStream<TcpStream>>,\n        channels: Vec<String>,\n    ) -> NadoResult<()> {\n        // Send Subscription Request (assuming a generic subscribe message format)\n        // Specific Nado protocol for subscription goes here.\n        let subscribe_msg = serde_json::json!({\n            \"action\": \"subscribe\",\n            \"channels\": channels\n        });\n        ws_stream.send(Message::Text(subscribe_msg.to_string())).await?;\n\n        let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(30)); // Heartbeat per schema\n\n        loop {\n            tokio::select! {\n                // Handle Incoming Message\n                msg = ws_stream.next() => {\n                    match msg {\n                        Some(Ok(msg)) => {\n                            if msg.is_text() {\n                                let text = msg.to_text()?;\n                                if let Err(e) = self.handle_message(text) {\n                                    eprintln!(\"[NadoWS] Error handling message: {}\", e);\n                                }\n                            } else if msg.is_ping() {\n                                ws_stream.send(Message::Pong(vec![])).await?;\n                            } else if msg.is_close() {\n                                println!(\"[NadoWS] Connection closed by server\");\n                                break;\n                            }\n                        }\n                        Some(Err(e)) => {\n                            eprintln!(\"[NadoWS] WebSocket error: {}\", e);\n                            return Err(NadoError::WebSocketError(e));\n                        }\n                        None => {\n                            println!(\"[NadoWS] Stream ended\");\n                            break;\n                        }\n                    }\n                }\n\n                // Handle Heartbeat (Ping every 30s per schema)\n                _ = interval.tick() => {\n                    ws_stream.send(Message::Ping(vec![])).await?;\n                }\n            }\n        }\n        Ok(())\n    }\n\n    fn handle_message(&self, raw: &str) -> NadoResult<()> {\n        // Try parsing as known Wrapper, else fallback\n        if let Ok(parsed) = serde_json::from_str::<WsMessage>(raw) {\n            match parsed {\n                WsMessage::Trade(trade) => {\n                    println!(\"[NadoWS] Trade: {:?}\", trade);\n                    // In real implementation: Convert to Nautilus TradeTick and push to channel\n                }\n                WsMessage::Bbo(bbo) => {\n                    println!(\"[NadoWS] BBO: {:?}\", bbo);\n                    // In real implementation: Convert to Nautilus QuoteTick and push to channel\n                }\n                WsMessage::Unknown => {\n                    // Log or ignore\n                }\n            }\n        } else {\n            // Try parsing as raw JSON for other messages (Order updates, etc)\n            let v: Value = serde_json::from_str(raw)?;\n            println!(\"[NadoWS] Unparsed JSON: {}\", v);\n        }\n        Ok(())\n    }\n}\n",
    "python/mod.rs": "use crate::config::NadoConfig;\nuse crate::http::client::{NadoHttpClient, OrderSide, OrderType};\nuse crate::websocket::client::NadoWebSocketClient;\nuse pyo3::prelude::*;\nuse pyo3::types::PyDict;\n\n/// Python wrapper for the Nado Adapter configuration.\n#[pyclass(name = \"NadoConfig\")]\n#[derive(Clone)]\npub struct PyNadoConfig {\n    inner: NadoConfig,\n}\n\n#[pymethods]\nimpl PyNadoConfig {\n    #[new]\n    #[pyo3(signature = (wallet_address, private_key, api_key=None, rest_base_url=None, ws_url=None))]\n    fn new(\n        wallet_address: String,\n        private_key: String,\n        api_key: Option<String>,\n        rest_base_url: Option<String>,\n        ws_url: Option<String>,\n    ) -> Self {\n        let inner = NadoConfig {\n            api_key,\n            wallet_address,\n            private_key,\n            rest_base_url: rest_base_url.unwrap_or_else(|| \"https://gateway.prod.nado.xyz/v1\".to_string()),\n            ws_url: ws_url.unwrap_or_else(|| \"wss://gateway.prod.nado.xyz/v1/subscribe\".to_string()),\n        };\n        Self { inner }\n    }\n}\n\n/// Python wrapper for the Nado HTTP Client.\n#[pyclass(name = \"NadoHttpClient\")]\npub struct PyNadoHttpClient {\n    client: NadoHttpClient,\n}\n\n#[pymethods]\nimpl PyNadoHttpClient {\n    #[new]\n    fn new(config: &PyNadoConfig) -> PyResult<Self> {\n        let client = NadoHttpClient::new(config.inner.clone())\n            .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))?;\n        Ok(Self { client })\n    }\n\n    fn place_order<'py>(\n        &mut self,\n        py: Python<'py>,\n        product_id: u64,\n        side: &str,\n        order_type: &str,\n        price: f64,\n        qty: f64,\n    ) -> PyResult<&'py PyAny> {\n        // Convert strings to enums\n        let side_enum = match side.to_lowercase().as_str() {\n            \"buy\" => OrderSide::Buy,\n            \"sell\" => OrderSide::Sell,\n            _ => return Err(PyErr::new::<pyo3::exceptions::PyValueError, _>(\"Invalid side\")),\n        };\n\n        let type_enum = match order_type.to_lowercase().as_str() {\n            \"market\" => OrderType::Market,\n            \"limit\" => OrderType::Limit,\n            _ => return Err(PyErr::new::<pyo3::exceptions::PyValueError, _>(\"Invalid type\")),\n        };\n\n        // Clone necessary data as self.client is mutably borrowed but method takes &self\n        let client_ref = &self.client;\n        let fut = async move {\n            client_ref\n                .place_order(product_id, side_enum, type_enum, price, qty)\n                .await\n        };\n\n        pyo3_asyncio::tokio::future_into_py(py, fut)\n    }\n\n    fn get_orders<'py>(\n        &mut self,\n        py: Python<'py>,\n        subaccount: String,\n        product_id: u64,\n    ) -> PyResult<&'py PyAny> {\n        let client_ref = &self.client;\n        let fut = async move { client_ref.get_orders(subaccount, product_id).await };\n        pyo3_asyncio::tokio::future_into_py(py, fut)\n    }\n}\n\n/// Python wrapper for the Nado WebSocket Client.\n#[pyclass(name = \"NadoWebSocketClient\")]\npub struct PyNadoWebSocketClient {\n    client: NadoWebSocketClient,\n}\n\n#[pymethods]\nimpl PyNadoWebSocketClient {\n    #[new]\n    fn new(config: &PyNadoConfig) -> Self {\n        let client = NadoWebSocketClient::new(config.inner.clone());\n        Self { client }\n    }\n\n    fn connect_and_run<'py>(&mut self, py: Python<'py>, channels: Vec<String>) -> PyResult<&'py PyAny> {\n        let client_ref = &self.client;\n        let fut = async move { client_ref.connect_and_run(channels).await };\n        pyo3_asyncio::tokio::future_into_py(py, fut)\n    }\n}\n\n/// The Python module definition.\n#[pymodule]\nfn nado_adapter(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<PyNadoConfig>()?;\n    m.add_class::<PyNadoHttpClient>()?;\n    m.add_class::<PyNadoWebSocketClient>()?;\n    Ok(())\n}\n"
  }
}
```