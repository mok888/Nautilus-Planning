```json
{
  "rust_files": {
    "src/config.rs": "use serde::{Deserialize, Serialize};\n\n/// Configuration for the Nado DEX adapter.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct NadoConfig {\n    /// The base URL for the REST API (default: https://gateway.prod.nado.xyz/v1)\n    #[serde(default = \"default_rest_url\")]\n    pub rest_base_url: String,\n\n    /// The URL for the WebSocket API\n    #[serde(default = \"default_ws_url\")]\n    pub ws_base_url: String,\n\n    /// The wallet private key (hex string) for signing EIP-712 payloads.\n    /// Must correspond to the `sender` address.\n    pub private_key: String,\n\n    /// The sender address (hex string) derived from the private key.\n    pub sender_address: String,\n\n    /// Optional subaccount identifier for queries.\n    #[serde(default)]\n    pub subaccount: Option<String>,\n\n    /// Timeout in seconds for HTTP requests.\n    #[serde(default = \"default_timeout\")]\n    pub timeout_sec: u64,\n}\n\nfn default_rest_url() -> String {\n    \"https://gateway.prod.nado.xyz/v1\".to_string()\n}\n\nfn default_ws_url() -> String {\n    \"wss://gateway.prod.nado.xyz/v1/subscribe\".to_string()\n}\n\nfn default_timeout() -> u64 {\n    10\n}\n\nimpl Default for NadoConfig {\n    fn default() -> Self {\n        Self {\n            rest_base_url: default_rest_url(),\n            ws_base_url: default_ws_url(),\n            private_key: String::new(),\n            sender_address: String::new(),\n            subaccount: None,\n            timeout_sec: default_timeout(),\n        }\n    }\n}",
    "src/error.rs": "use thiserror::Error;\n\n/// Error types for the Nado adapter.\n#[derive(Error, Debug)]\npub enum NadoError {\n    #[error(\"HTTP request failed: {0}\")]\n    HttpError(#[from] reqwest::Error),\n\n    #[error(\"WebSocket error: {0}\")]\n    WsError(#[from] tokio_tungstenite::tungstenite::Error),\n\n    #[error(\"JSON serialization/deserialization error: {0}\")]\n    JsonError(#[from] serde_json::Error),\n\n    #[error(\"Signing error: {0}\")]\n    SigningError(String),\n\n    #[error(\"Authentication failed: {0}\")]\n    AuthenticationError(String),\n\n    #[error(\"Invalid response from exchange: {0}\")]\n    InvalidResponse(String),\n\n    #[error(\"Unsupported operation: {0}\")]\n    UnsupportedOperation(String),\n\n    #[error(\"Conversion error: {0}\")]\n    ConversionError(String),\n}",
    "src/http/signing.rs": "use crate::error::NadoError;\nuse k256::ecdsa::{SigningKey, Signature, signature::Signer};\nuse k256::sha3::{Keccak256, Digest};\nuse serde::Serialize;\nuse hex;\n\n/// Payload required to sign an order on Nado.\n#[derive(Debug, Serialize, Clone)]\npub struct OrderPayload {\n    pub product_id: u64,\n    pub sender: String,\n    pub price_x18: String, // Scaled by 10^18\n    pub amount: String,    // Scaled by 10^18\n    pub expiration: u64,  // Nanoseconds\n    pub nonce: u64,\n}\n\n/// Signs an EIP-712 formatted payload using the private key.\npub fn sign_eip712_order(private_key_hex: &str, payload: &OrderPayload) -> Result<String, NadoError> {\n    // 1. Decode private key\n    let private_key_bytes = hex::decode(private_key_hex.trim_start_matches(\"0x\"))\n        .map_err(|e| NadoError::SigningError(format!(\"Invalid private key hex: {}\", e)))?;\n    \n    let signing_key = SigningKey::from_bytes(&private_key_bytes.into())\n        .map_err(|e| NadoError::SigningError(format!(\"Invalid signing key: {}\", e)))?;\n\n    // 2. Construct the EIP-712 message hash (Simplified for Nado schema)\n    // Note: Real EIP-712 includes domain separator and type hashes.\n    // Based on research data: \"EIP-712 formatted message\".\n    // We implement a deterministic hash of the payload fields as per specific DEX implementation patterns.\n    \n    // Concatenate raw bytes for hashing (standard pattern for simple EIP-712 structs without full struct hashing implementation in this stub)\n    // In a full implementation, we would encode types: `keccak256(AbiEncode(payload))`\n    \n    let mut hasher = Keccak256::new();\n    // Hash fields individually to avoid collisions\n    hasher.update(payload.product_id.to_be_bytes());\n    hasher.update(payload.sender.as_bytes());\n    hasher.update(payload.price_x18.as_bytes());\n    hasher.update(payload.amount.as_bytes());\n    hasher.update(payload.expiration.to_be_bytes());\n    hasher.update(payload.nonce.to_be_bytes());\n    \n    let hash = hasher.finalize();\n\n    // 3. Sign the hash\n    let signature: Signature = signing_key.sign(&hash);\n    \n    // 4. Encode to hex (DER or Compact RSV). Nado likely expects standard hex signature.\n    // We output the compact byte representation of the signature.\n    Ok(format!(\"0x{}\", hex::encode(signature.to_bytes())))\n}\n\n/// Helper to scale float values to x18 fixed point strings.\npub fn to_x18_string(value: f64) -> Result<String, NadoError> {\n    let scaled = (value * 1e18) as u128;\n    Ok(scaled.to_string())\n}",
    "src/http/client.rs": "use crate::config::NadoConfig;\nuse crate::error::NadoError;\nuse crate::http::signing::{sign_eip712_order, to_x18_string, OrderPayload};\nuse reqwest::{Client, header::{HeaderMap, HeaderValue, ACCEPT_ENCODING}};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n#[derive(Debug, Serialize)]\nstruct PlaceOrderRequest {\n    product_id: u64,\n    sender: String,\n    priceX18: String,\n    amount: String,\n    expiration: u64,\n    nonce: u64,\n    signature: String,\n}\n\n#[derive(Debug, Deserialize)]\nstruct PlaceOrderResponse {\n    pub status: String,\n    pub order_id: Option<String>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct QueryOrdersResponse {\n    pub orders: Vec<serde_json::Value>,\n}\n\n/// HTTP Client for Nado REST API.\npub struct NadoHttpClient {\n    client: Client,\n    config: NadoConfig,\n}\n\nimpl NadoHttpClient {\n    pub fn new(config: NadoConfig) -> Self {\n        let mut headers = HeaderMap::new();\n        headers.insert(\n            ACCEPT_ENCODING,\n            HeaderValue::from_static(\"gzip, br, deflate\"),\n        );\n\n        let client = Client::builder()\n            .default_headers(headers)\n            .timeout(std::time::Duration::from_secs(config.timeout_sec))\n            .build()\n            .expect(\"Failed to create HTTP client\");\n\n        Self { client, config }\n    }\n\n    /// Place an order via the /execute endpoint.\n    pub async fn place_order(\n        &self,\n        product_id: u64,\n        price: f64,\n        quantity: f64,\n        expiration: u64, // nanoseconds\n        nonce: u64,\n    ) -> Result<String, NadoError> {\n        let price_x18 = to_x18_string(price)?;\n        let amount_x18 = to_x18_string(quantity)?;\n\n        let payload = OrderPayload {\n            product_id,\n            sender: self.config.sender_address.clone(),\n            price_x18,\n            amount: amount_x18,\n            expiration,\n            nonce,\n        };\n\n        let signature = sign_eip712_order(&self.config.private_key, &payload)?;\n\n        let req_body = PlaceOrderRequest {\n            product_id,\n            sender: self.config.sender_address.clone(),\n            priceX18: payload.price_x18,\n            amount: payload.amount,\n            expiration,\n            nonce,\n            signature,\n        };\n\n        let url = format!(\"{}/execute\", self.config.rest_base_url);\n        let resp = self\n            .client\n            .post(&url)\n            .json(&req_body)\n            .send()\n            .await?;\n\n        let status = resp.status();\n        let body_text = resp.text().await?;\n\n        if !status.is_success() {\n            return Err(NadoError::InvalidResponse(format!(\n                \"Place order failed: {} - {}\",\n                status, body_text\n            )));\n        }\n\n        let result: PlaceOrderResponse = serde_json::from_str(&body_text)\n            .map_err(|e| NadoError::InvalidResponse(format!(\"JSON parse error: {}\", e)))?;\n\n        result\n            .order_id\n            .ok_or_else(|| NadoError::InvalidResponse(\"Missing order_id in response\".into()))\n    }\n\n    /// Query orders via the /query endpoint.\n    pub async fn get_orders(\n        &self,\n        product_id: u64,\n    ) -> Result<Vec<serde_json::Value>, NadoError> {\n        let subaccount = self\n            .config\n            .subaccount\n            .as_ref()\n            .ok_or_else(|| NadoError::AuthenticationError(\"Subaccount required for query\".into()))?;\n\n        let url = format!(\n            \"{}/query?subaccount={}&product_id={}\",\n            self.config.rest_base_url, subaccount, product_id\n        );\n\n        let resp = self.client.get(&url).send().await?;\n        let body_text = resp.text().await?;\n\n        if !resp.status().is_success() {\n            return Err(NadoError::InvalidResponse(format!(\n                \"Get orders failed: {} - {}\",\n                resp.status(),\n                body_text\n            )));\n        }\n\n        let result: QueryOrdersResponse = serde_json::from_str(&body_text)?;\n        Ok(result.orders)\n    }\n}",
    "src/parsing/models.rs": "use crate::error::NadoError;\nuse serde::{Deserialize, Serialize};\nuse chrono::{DateTime, Utc};\n\n// --- Raw WebSocket Messages ---\n\n#[derive(Debug, Deserialize, Clone)]\npub struct WsMessage<T> {\n    #[serde(rename = \"channel\")]\n    pub channel: String,\n    pub data: T,\n}\n\n/// Trade event from the 'trade' channel.\n#[derive(Debug, Deserialize, Clone)]\npub struct RawTrade {\n    pub product_id: u64,\n    pub price_x18: String,\n    pub amount_x18: String,\n    pub timestamp: u64, // nanoseconds\n    pub side: String,   // \"buy\" or \"sell\"\n}\n\n/// Best Bid/Offer update from the 'best_bid_offer' channel.\n#[derive(Debug, Deserialize, Clone)]\npub struct RawBbo {\n    pub product_id: u64,\n    pub bid_price_x18: String,\n    pub bid_amount_x18: String,\n    pub ask_price_x18: String,\n    pub ask_amount_x18: String,\n    pub timestamp: u64,\n}\n\n// --- Parsed Domain Models (Nautilus Compatible) ---\n\n#[derive(Debug, Clone, Serialize)]\npub struct Trade {\n    pub product_id: u64,\n    pub price: f64,\n    pub quantity: f64,\n    pub ts: DateTime<Utc>,\n    pub side: String,\n}\n\n#[derive(Debug, Clone, Serialize)]\npub struct QuoteTick {\n    pub product_id: u64,\n    pub bid_price: f64,\n    pub bid_qty: f64,\n    pub ask_price: f64,\n    pub ask_qty: f64,\n    pub ts: DateTime<Utc>,\n}\n\n/// Helper to convert x18 string to f64.\nfn parse_x18(val: &str) -> Result<f64, NadoError> {\n    let val_u128: u128 = val.parse().map_err(|_| {\n        NadoError::ConversionError(format!(\"Failed to parse x18 string: {}\", val))\n    })?;\n    Ok(val_u128 as f64 / 1e18)\n}\n\nimpl TryFrom<RawTrade> for Trade {\n    type Error = NadoError;\n\n    fn try_from(raw: RawTrade) -> Result<Self, Self::Error> {\n        let price = parse_x18(&raw.price_x18)?;\n        let qty = parse_x18(&raw.amount_x18)?;\n        \n        // Convert nanoseconds to DateTime\n        let secs = (raw.timestamp / 1_000_000_000) as i64;\n        let nsecs = (raw.timestamp % 1_000_000_000) as u32;\n        let ts = DateTime::<Utc>::from_timestamp(secs, nsecs)\n            .ok_or_else(|| NadoError::ConversionError(\"Invalid timestamp\".into()))?;\n\n        Ok(Self {\n            product_id: raw.product_id,\n            price,\n            quantity: qty,\n            ts,\n            side: raw.side,\n        })\n    }\n}\n\nimpl TryFrom<RawBbo> for QuoteTick {\n    type Error = NadoError;\n\n    fn try_from(raw: RawBbo) -> Result<Self, Self::Error> {\n        let bid_price = parse_x18(&raw.bid_price_x18)?;\n        let bid_qty = parse_x18(&raw.bid_amount_x18)?;\n        let ask_price = parse_x18(&raw.ask_price_x18)?;\n        let ask_qty = parse_x18(&raw.ask_amount_x18)?;\n\n        let secs = (raw.timestamp / 1_000_000_000) as i64;\n        let nsecs = (raw.timestamp % 1_000_000_000) as u32;\n        let ts = DateTime::<Utc>::from_timestamp(secs, nsecs)\n            .ok_or_else(|| NadoError::ConversionError(\"Invalid timestamp\".into()))?;\n\n        Ok(Self {\n            product_id: raw.product_id,\n            bid_price,\n            bid_qty,\n            ask_price,\n            ask_qty,\n            ts,\n        })\n    }\n}",
    "src/websocket/client.rs": "use crate::config::NadoConfig;\nuse crate::error::NadoError;\nuse crate::parsing::models::{RawTrade, RawBbo, WsMessage};\nuse futures_util::{SinkExt, StreamExt};\nuse serde_json::json;\nuse tokio_tungstenite::{connect_async, tungstenite::Message};\nuse tokio::time::{interval, Duration};\n\npub struct NadoWebSocketClient {\n    config: NadoConfig,\n}\n\nimpl NadoWebSocketClient {\n    pub fn new(config: NadoConfig) -> Self {\n        Self { config }\n    }\n\n    /// Connects and subscribes to public channels.\n    pub async fn connect_and_subscribe(&self, channels: Vec<String>) -> Result<(), NadoError> {\n        let url = &self.config.ws_base_url;\n        let (ws_stream, _) = connect_async(url).await?;\n        let (mut write, mut read) = ws_stream.split();\n\n        // Subscribe payload format\n        let payload = json!({\n            \"channels\": channels,\n            \"auth\": null // Public channels don't need auth in the connect msg, per schema private auth is separate/similar\n        });\n\n        write\n            .send(Message::Text(payload.to_string()))\n            .await\n            .map_err(|e| NadoError::WsError(e))?;\n\n        // Heartbeat loop (Ping every 30s as per schema)\n        let mut ping_interval = interval(Duration::from_secs(30));\n\n        loop {\n            tokio::select! {\n                _ = ping_interval.tick() => {\n                    write.send(Message::Ping(vec![])).await?;\n                }\n                Some(msg_result) = read.next() => {\n                    match msg_result {\n                        Ok(msg) => {\n                            if msg.is_text() {\n                                let text = msg.to_text()?;\n                                self.handle_message(text);\n                            } else if msg.is_close() {\n                                println!(\"WebSocket close received\");\n                                break;\n                            }\n                        }\n                        Err(e) => return Err(NadoError::WsError(e)),\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    fn handle_message(&self, raw: &str) {\n        // Try to parse as generic wrapper first\n        if let Ok(msg) = serde_json::from_str::<WsMessage<serde_json::Value>>(raw) {\n            match msg.channel.as_str() {\n                \"trade\" => {\n                    if let Ok(data) = serde_json::from_value::<RawTrade>(msg.data) {\n                        println!(\"Received Trade: {:?}\", data);\n                        // In a full adapter, we would convert this and send it to an internal mpsc channel\n                    }\n                }\n                \"best_bid_offer\" => {\n                    if let Ok(data) = serde_json::from_value::<RawBbo>(msg.data) {\n                        println!(\"Received BBO: {:?}\", data);\n                    }\n                }\n                _ => {\n                    println!(\"Received unknown channel: {}\", msg.channel);\n                }\n            }\n        } else {\n            println!(\"Unparseable message: {}\", raw);\n        }\n    }\n}",
    "src/python/mod.rs": "use crate::config::NadoConfig;\nuse crate::http::client::NadoHttpClient;\nuse crate::error::NadoError;\nuse pyo3::prelude::*;\nuse pyo3::types::PyDict;\nuse std::collections::HashMap;\n\n/// Python wrapper for the Nado HTTP Client.\n#[pyclass(name = \"NadoHttpClient\")]\npub struct PyNadoHttpClient {\n    client: NadoHttpClient,\n}\n\n#[pymethods]\nimpl PyNadoHttpClient {\n    #[new]\n    fn new(config_dict: &PyDict) -> PyResult<Self> {\n        // Extract config from Python dict\n        let rest_base_url = config_dict\n            .get_item(\"rest_base_url\")?\n            .unwrap_or(\"https://gateway.prod.nado.xyz/v1\")\n            .extract()?;\n        let private_key = config_dict.get_item(\"private_key\")?.unwrap().extract()?;\n        let sender_address = config_dict.get_item(\"sender_address\")?.unwrap().extract()?;\n        let subaccount = config_dict.get_item(\"subaccount\")?.unwrap().extract()?;\n        let timeout_sec: u64 = config_dict\n            .get_item(\"timeout_sec\")?\n            .unwrap_or(10)\n            .extract()?;\n\n        let config = NadoConfig {\n            rest_base_url,\n            ws_base_url: \"wss://gateway.prod.nado.xyz/v1/subscribe\".to_string(),\n            private_key,\n            sender_address,\n            subaccount,\n            timeout_sec,\n        };\n\n        Ok(Self {\n            client: NadoHttpClient::new(config),\n        })\n    }\n\n    /// Place an order.\n    fn place_order(\n        &self,\n        product_id: u64,\n        price: f64,\n        quantity: f64,\n        expiration: u64,\n        nonce: u64,\n        py: Python,\n    ) -> PyResult<String> {\n        py.allow_threads(|| {\n            let rt = tokio::runtime::Runtime::new()\n                .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))?;\n            rt.block_on(self.client.place_order(product_id, price, quantity, expiration, nonce))\n                .map_err(|e| PyErr::new::<pyo3::exceptions::PyValueError, _>(e.to_string()))\n        })\n    }\n\n    /// Get orders for a product.\n    fn get_orders(&self, product_id: u64, py: Python) -> PyResult<Vec<HashMap<String, serde_json::Value>>> {\n        py.allow_threads(|| {\n            let rt = tokio::runtime::Runtime::new()\n                .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))?;\n            let orders = rt.block_on(self.client.get_orders(product_id))\n                .map_err(|e| PyErr::new::<pyo3::exceptions::PyValueError, _>(e.to_string()))?;\n            \n            // Convert serde_json::Value to Python-friendly HashMap\n            let result: Vec<HashMap<String, serde_json::Value>> = orders\n                .into_iter()\n                .map(|v| serde_json::from_value(v).unwrap_or_default())\n                .collect();\n            \n            Ok(result)\n        })\n    }\n}\n\n/// The Python module definition.\n#[pymodule]\nfn nado_adapter(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<PyNadoHttpClient>()?;\n    Ok(())\n}"
  }
}
```