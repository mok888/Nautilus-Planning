```json
{
  "python_files": {
    "config.py": "\"\"\"\nConfiguration for Lighter adapters.\n\"\"\"\nfrom nautilus_trader.config import WebSocketClientConfig\nfrom nautilus_trader.core.correctness import PyCondition\n\n\nclass LighterConfig(WebSocketClientConfig, frozen=True):\n    \"\"\"\n    Configuration for the Lighter DEX adapter.\n    \"\"\"\n\n    api_key: str\n    api_secret: str\n    chain_id: int = 137  # Default to Polygon Mainnet\n\n    def __post_init__(self) -> None:\n        PyCondition.not_empty(self.api_key, \"api_key\")\n        PyCondition.not_empty(self.api_secret, \"api_secret\")\n        PyCondition.positive(self.chain_id, \"chain_id\")\n",
    "constants.py": "\"\"\"\nConstants for Lighter adapters.\n\"\"\"\nfrom nautilus_trader.model.identifiers import Venue\n\n\n# Venue identifiers\nVENUE = Venue(\"LIGHTER\")\n\n# API Constants\nREST_BASE_URL = \"https://api.lighter.xyz\"\nWS_PUBLIC_URL = \"wss://api.lighter.xyz/ws\"\nWS_PRIVATE_URL = \"wss://api.lighter.xyz/ws\"\n\n# Authentication Headers\nHEADER_CHAIN_ID = \"x-lighter-chain-id\"\nHEADER_API_KEY = \"x-api-key\"\nHEADER_TIMESTAMP = \"x-timestamp\"\nHEADER_SIGNATURE = \"x-signature\"\n\n# Environment Variables\nENV_API_KEY = \"LIGHTER_API_KEY\"\nENV_API_SECRET = \"LIGHTER_API_SECRET\"\n\n# API Version\nAPI_VERSION = \"v1\"\n\n# Channels\nCHANNEL_ORDERBOOK = \"orderbook\"\nCHANNEL_TRADES = \"trades\"\n\n# Order Types\nORDER_TYPE_LIMIT = \"LIMIT\"\nORDER_TYPE_MARKET = \"MARKET\"\n\n# Order Sides\nSIDE_BUY = \"BUY\"\nSIDE_SELL = \"SELL\"\n\n# Time in Force\nTIF_GTC = \"GTC\"\nTIF_IOC = \"IOC\"  # Assuming support for Fill or Kill/IOC based on standard DEX behavior, though schema implies GTC primarily.\n\n# Precision\nPRICE_PRECISION = 8\nQUANTITY_PRECISION = 8\n",
    "data.py": "\"\"\"\nData client for Lighter.\n\"\"\"\nimport asyncio\nfrom typing import Any, Optional\n\nimport msgspec\n\nfrom nautilus_trader.adapters.websocket.client import WebSocketClient\nfrom nautilus_trader.common.clock import LiveClock\nfrom nautilus_trader.common.enums import LogColor\nfrom nautilus_trader.core.correctness import PyCondition\nfrom nautilus_trader.core.message import Event\nfrom nautilus_trader.core.uuid import UUID4\nfrom nautilus_trader.data.messages import RequestBars, RequestInstrument, RequestTick\nfrom nautilus_trader.data.client import DataClient\nfrom nautilus_trader.live.data_engine import DataEngine\nfrom nautilus_trader.model.data import OrderBookDeltas, QuoteTick, TradeTick\nfrom nautilus_trader.model.identifiers import InstrumentId\nfrom nautilus_trader.model.objects import Price, Quantity\n\nfrom nautilus_trader.adapters.lighter.constants import CHANNEL_ORDERBOOK, CHANNEL_TRADES, VENUE, WS_PUBLIC_URL\nfrom nautilus_trader.adapters.lighter.providers import LighterInstrumentProvider\n\n\nclass LighterDataClient(DataClient):\n    \"\"\"\n    Provides a data client for the Lighter DEX.\n    \"\"\"\n\n    def __init__(\n        self,\n        loop: asyncio.AbstractEventLoop,\n        engine: DataEngine,\n        clock: LiveClock,\n        instrument_provider: LighterInstrumentProvider,\n        config: dict[str, Any],\n    ) -> None:\n        super().__init__(loop, engine, clock, config.get(\"name\", \"Lighter\"))\n        self._instrument_provider = instrument_provider\n        self._ws_client: Optional[WebSocketClient] = None\n        self._base_url = config.get(\"ws_public_url\", WS_PUBLIC_URL)\n        self._is_connected = False\n\n    async def _connect(self) -> None:\n        self._log.info(f\"Connecting LighterDataClient to {self._base_url}...\")\n        # In a full implementation, WebSocketClient would be initialized and connected here.\n        # For this schema-driven output, we assume the connection logic follows Nautilus standards.\n        self._is_connected = True\n        self._log.info(\"LighterDataClient connected.\")\n\n    async def _disconnect(self) -> None:\n        self._log.info(\"Disconnecting LighterDataClient...\")\n        self._is_connected = False\n        self._log.info(\"LighterDataClient disconnected.\")\n\n    def _is_reliable(self) -> bool:\n        return True\n\n    # --- Subscription handling ---\n\n    async def _subscribe_instruments(self) -> None:\n        self._log.info(\"Requesting instrument snapshot...\")\n        await self._instrument_provider.load_all_async()\n        for instrument in self._instrument_provider.get_all():\n            self._handle_data(instrument)\n\n    async def _subscribe_order_book_snapshots(\n        self,\n        instrument_id: InstrumentId,\n        limit: int | None = None,\n    ) -> None:\n        PyCondition.true(self._is_connected, \"Not connected\")\n        self._log.info(f\"Subscribing to OrderBook snapshots for {instrument_id}\")\n        # Implementation would send a subscription message over WebSocket\n\n    async def _subscribe_order_book_deltas(\n        self,\n        instrument_id: InstrumentId,\n    ) -> None:\n        PyCondition.true(self._is_connected, \"Not connected\")\n        self._log.info(f\"Subscribing to OrderBook deltas for {instrument_id}\")\n        # Implementation would send subscription message for 'orderbook' channel\n\n    async def _subscribe_quote_ticks(\n        self,\n        instrument_id: InstrumentId,\n    ) -> None:\n        await self._subscribe_order_book_deltas(instrument_id)\n\n    async def _subscribe_trade_ticks(\n        self,\n        instrument_id: InstrumentId,\n    ) -> None:\n        PyCondition.true(self._is_connected, \"Not connected\")\n        self._log.info(f\"Subscribing to Trade ticks for {instrument_id}\")\n        # Implementation would send subscription message for 'trades' channel\n\n    # --- Message handlers ---\n\n    def _handle_data(self, data: Any) -> None:\n        self._engine.process(data)\n",
    "execution.py": "\"\"\"\nExecution client for Lighter.\n\"\"\"\nimport asyncio\nimport hmac\nimport hashlib\nimport time\nfrom typing import Any, Optional\n\nimport msgspec\n\nfrom nautilus_trader.adapters.http.client import HttpClient\nfrom nautilus_trader.common.clock import LiveClock\nfrom nautilus_trader.common.enums import LogColor\nfrom nautilus_trader.config import HttpClientConfig, WebSocketClientConfig\nfrom nautilus_trader.core.correctness import PyCondition\nfrom nautilus_trader.core.message import Event\nfrom nautilus_trader.core.uuid import UUID4\nfrom nautilus_trader.execution.client import ExecutionClient\nfrom nautilus_trader.execution.messages import CancelOrder, SubmitOrder\nfrom nautilus_trader.live.execution_engine import ExecutionEngine\nfrom nautilus_trader.model.data import OrderBookDeltas\nfrom nautilus_trader.model.enums import OrderSide, OrderStatus, OrderType, TimeInForce\nfrom nautilus_trader.model.events import OrderAccepted, OrderFilled, OrderRejected, OrderUpdated\nfrom nautilus_trader.model.identifiers import AccountId, ClientOrderId, InstrumentId, OrderListId, VenueOrderId\nfrom nautilus_trader.model.objects import Price, Quantity\n\nfrom nautilus_trader.adapters.lighter.config import LighterConfig\nfrom nautilus_trader.adapters.lighter.constants import (\n    API_VERSION,\n    HEADER_API_KEY,\n    HEADER_CHAIN_ID,\n    HEADER_SIGNATURE,\n    HEADER_TIMESTAMP,\n    ORDER_TYPE_LIMIT,\n    ORDER_TYPE_MARKET,\n    REST_BASE_URL,\n    SIDE_BUY,\n    SIDE_SELL,\n    TIF_GTC,\n    VENUE,\n)\nfrom nautilus_trader.adapters.lighter.providers import LighterInstrumentProvider\n\n\n# Response Decoders\nclass LighterOrderResponse(msgspec.Struct):\n    orderId: str\n    status: str\n    symbol: str\n\n\nclass LighterExecutionClient(ExecutionClient):\n    \"\"\"\n    Provides an execution client for the Lighter DEX.\n    \"\"\"\n\n    def __init__(\n        self,\n        loop: asyncio.AbstractEventLoop,\n        engine: ExecutionEngine,\n        clock: LiveClock,\n        instrument_provider: LighterInstrumentProvider,\n        config: LighterConfig,\n    ) -> None:\n        super().__init__(loop=loop, engine=engine, clock=clock, config=config)\n        self._instrument_provider = instrument_provider\n        self._config = config\n        self._http_client: Optional[HttpClient] = None\n        self._account_id = AccountId(config.api_key) # Using API Key as account identifier\n        self._is_connected = False\n\n    async def _connect(self) -> None:\n        if self._is_connected:\n            self._log.warning(\"Already connected.\")\n            return\n\n        self._log.info(f\"Connecting to Lighter Execution (REST)...\")\n        http_config = HttpClientConfig(\n            base_url=REST_BASE_URL,\n            timeout_ms=5000,\n        )\n        self._http_client = HttpClient(\n            loop=self._loop,\n            clock=self._clock,\n            config=http_config,\n            logger=self._log.get_logger(),\n        )\n        await self._http_client.connect()\n        \n        # TODO: Connect to private WebSocket for updates if needed, schema supports it.\n        \n        self._is_connected = True\n        self._log.info(\"Connected to Lighter Execution.\")\n\n    async def _disconnect(self) -> None:\n        if self._http_client:\n            await self._http_client.disconnect()\n        self._is_connected = False\n        self._log.info(\"Disconnected from Lighter Execution.\")\n\n    def _generate_signature(self, timestamp: str, method: str, path: str, body: str = \"\") -> str:\n        \"\"\"Generate the X-Signature header value.\"\"\"\n        message = f\"{timestamp}{method}{path}{body}\"\n        mac = hmac.new(\n            self._config.api_secret.encode(\"utf-8\"),\n            message.encode(\"utf-8\"),\n            hashlib.sha256,\n        )\n        return mac.hexdigest()\n\n    def _get_auth_headers(self, method: str, path: str, body: str = \"\") -> dict[str, str]:\n        timestamp = str(int(time.time() * 1000))\n        signature = self._generate_signature(timestamp, method, path, body)\n        return {\n            HEADER_CHAIN_ID: str(self._config.chain_id),\n            HEADER_API_KEY: self._config.api_key,\n            HEADER_TIMESTAMP: timestamp,\n            HEADER_SIGNATURE: signature,\n            \"Content-Type\": \"application/json\",\n        }\n\n    async def submit_order(self, command: SubmitOrder) -> None:\n        \"\"\"Submit an order to the exchange.\"\"\"\n        PyCondition.true(self._is_connected, \"Not connected\")\n        \n        instrument = self._instrument_provider.find(command.instrument_id)\n        PyCondition.not_none(instrument, \"Instrument not found\")\n\n        # Map Nautilus Order to Lighter Request\n        side = SIDE_BUY if command.side == OrderSide.BUY else SIDE_SELL\n        \n        order_type_str: str\n        if command.order_type == OrderType.LIMIT:\n            order_type_str = ORDER_TYPE_LIMIT\n        elif command.order_type == OrderType.MARKET:\n            order_type_str = ORDER_TYPE_MARKET\n        else:\n            self._log.error(f\"Unsupported order type: {command.order_type}\")\n            self._generate_order_rejected(\n                command.strategy_id,\n                command.instrument_id,\n                command.client_order_id,\n                f\"Unsupported order type: {command.order_type}\",\n                self._clock.timestamp_ns(),\n            )\n            return\n\n        tif = command.time_in_force if command.time_in_force else TimeInForce.GTC\n        tif_str = TIF_GTC # Lighter primarily handles GTC based on schema notes\n\n        payload = {\n            \"chainId\": self._config.chain_id,\n            \"symbol\": command.instrument_id.symbol.value, # Assumes BASE-QUOTE format matches\n            \"side\": side,\n            \"type\": order_type_str,\n            \"quantity\": str(command.quantity),\n            \"clientOrderId\": command.client_order_id.value,\n            \"tif\": tif_str,\n        }\n\n        if command.order_type == OrderType.LIMIT:\n            payload[\"price\"] = str(command.price)\n        elif command.order_type == OrderType.MARKET:\n            # Market orders might not need price, or 0. Lighter schema doesn't specify, but standard is no price.\n            pass \n\n        path = f\"/{API_VERSION}/order\"\n        body = msgspec.json.encode(payload).decode(\"utf-8\")\n        headers = self._get_auth_headers(\"POST\", path, body)\n\n        try:\n            self._log.info(f\"Submitting order: {command.client_order_id.value}\")\n            response = await self._http_client.post(path, headers=headers, body=body)\n            result = msgspec.json.decode(response, type=LighterOrderResponse)\n            \n            # Process result\n            self._log.info(f\"Order submitted. Exchange ID: {result.orderId}\")\n            self._generate_order_accepted(\n                client_order_id=command.client_order_id,\n                venue_order_id=VenueOrderId(result.orderId),\n                ts_event=self._clock.timestamp_ns(),\n            )\n            # Further updates would come from WS or polling\n        except Exception as e:\n            self._log.error(f\"Failed to submit order: {e}\")\n            self._generate_order_rejected(\n                command.strategy_id,\n                command.instrument_id,\n                command.client_order_id,\n                str(e),\n                self._clock.timestamp_ns(),\n            )\n\n    async def cancel_order(self, command: CancelOrder) -> None:\n        \"\"\"Cancel an order on the exchange.\"\"\"\n        PyCondition.true(self._is_connected, \"Not connected\")\n        \n        # Schema only provided Create Order endpoint. \n        # Assuming standard RESTful DELETE /v1/order based on 'cancel_behavior': 'GTC' existing.\n        # Note: Real implementation requires the exact endpoint from documentation.\n        \n        path = f\"/{API_VERSION}/order\" # Placeholder for actual delete path if different\n        \n        # Lighter cancellation payload structure is inferred (often orderId or clientOrderId)\n        payload = {\n            \"orderId\": command.venue_order_id.value if command.venue_order_id else None,\n            \"clientOrderId\": command.client_order_id.value,\n        }\n        \n        body = msgspec.json.encode(payload).decode(\"utf-8\")\n        headers = self._get_auth_headers(\"DELETE\", path, body)\n\n        try:\n            # self._http_client.delete(...) is assumed to exist or use .post with override\n            # HttpClient usually has delete method\n            # await self._http_client.delete(path, headers=headers, body=body)\n            self._log.warning(\"Cancel order implementation requires specific endpoint confirmation from Lighter docs.\")\n        except Exception as e:\n            self._log.error(f\"Failed to cancel order: {e}\")\n\n    async def modify_order(self, command) -> None:\n        \"\"\"Modify an order (not supported by Lighter usually).\"\"\"\n        self._log.error(\"Order modification not supported by Lighter DEX.\")\n\n    async def _update_account_state(self) -> None:\n        \"\"\"Update account state.\"\"\"\n        # Fetch balances from /v1/account or similar (schema didn't list it, but private WS mentions balance_updates)\n        pass\n",
    "factories.py": "\"\"\"\nFactory for Lighter adapters.\n\"\"\"\nimport asyncio\nfrom typing import Optional\n\nfrom nautilus_trader.adapters.betfair.providers import BetfairInstrumentProvider\nfrom nautilus_trader.config import WebSocketClientConfig\nfrom nautilus_trader.core.correctness import PyCondition\nfrom nautilus_trader.core.uuid import UUID4\nfrom nautilus_trader.live.data_engine import DataEngine\nfrom nautilus_trader.live.execution_engine import ExecutionEngine\nfrom nautilus_trader.model.identifiers import Venue\n\nfrom nautilus_trader.adapters.lighter.config import LighterConfig\nfrom nautilus_trader.adapters.lighter.constants import VENUE\nfrom nautilus_trader.adapters.lighter.data import LighterDataClient\nfrom nautilus_trader.adapters.lighter.execution import LighterExecutionClient\nfrom nautilus_trader.adapters.lighter.providers import LighterInstrumentProvider\nfrom nautilus_trader.live.factories import LiveDataClientFactory, LiveExecClientFactory\n\n\nclass LighterClientFactory:\n    \"\"\"\n    A factory for creating Lighter clients.\n    \"\"\"\n\n    @staticmethod\n    def create(\n        loop: asyncio.AbstractEventLoop,\n        name: str,\n        config: LighterConfig,\n        data_engine: Optional[DataEngine] = None,\n        exec_engine: Optional[ExecutionEngine] = None,\n    ) -> tuple[Optional[LighterDataClient], Optional[LighterExecutionClient]]:\n        \"\"\"\n        Create Lighter Data and Execution clients.\n        \"\"\"\n        PyCondition.type(config, LighterConfig, \"config\")\n\n        # Create shared instrument provider\n        instrument_provider = LighterInstrumentProvider(\n            loop=loop,\n            config=config,\n        )\n        \n        data_client: Optional[LighterDataClient] = None\n        execution_client: Optional[LighterExecutionClient] = None\n\n        if data_engine:\n            data_client = LighterDataClient(\n                loop=loop,\n                engine=data_engine,\n                clock=data_engine.clock,\n                instrument_provider=instrument_provider,\n                config=config.to_dict(),\n            )\n\n        if exec_engine:\n            execution_client = LighterExecutionClient(\n                loop=loop,\n                engine=exec_engine,\n                clock=exec_engine.clock,\n                instrument_provider=instrument_provider,\n                config=config,\n            )\n\n        return data_client, execution_client\n\n\nclass LighterDataClientFactory(LiveDataClientFactory):\n    \"\"\"\n    A factory for creating Lighter DataClient instances.\n    \"\"\"\n\n    def create(self, loop: asyncio.AbstractEventLoop, name: str, config: WebSocketClientConfig) -> LighterDataClient:\n        \"\"\"\n        Create a new LighterDataClient.\n        \"\"\"\n        PyCondition.type(config, LighterConfig, \"config\")\n        return LighterClientFactory.create(\n            loop=loop,\n            name=name,\n            config=config,\n            data_engine=self._engine,\n        )[0]\n\n\nclass LighterExecutionClientFactory(LiveExecClientFactory):\n    \"\"\"\n    A factory for creating Lighter ExecutionClient instances.\n    \"\"\"\n\n    def create_single(self, loop: asyncio.AbstractEventLoop, name: str, config: WebSocketClientConfig) -> LighterExecutionClient:\n        \"\"\"\n        Create a new LighterExecutionClient.\n        \"\"\"\n        PyCondition.type(config, LighterConfig, \"config\")\n        return LighterClientFactory.create(\n            loop=loop,\n            name=name,\n            config=config,\n            exec_engine=self._engine,\n        )[1]\n",
    "providers.py": "\"\"\"\nInstrument provider for Lighter.\n\"\"\"\nimport asyncio\nfrom typing import Optional\n\nimport msgspec\n\nfrom nautilus_trader.adapters.http.client import HttpClient\nfrom nautilus_trader.common.clock import LiveClock\nfrom nautilus_trader.config import HttpClientConfig\nfrom nautilus_trader.core.correctness import PyCondition\nfrom nautilus_trader.model.currency import Currency\nfrom nautilus_trader.model.enums import AssetClass, PriceType\nfrom nautilus_trader.model.identifiers import InstrumentId, Symbol, Venue\nfrom nautilus_trader.model.instruments import CryptoInstrument\nfrom nautilus_trader.model.objects import Money, Price, Quantity\n\nfrom nautilus_trader.adapters.lighter.config import LighterConfig\nfrom nautilus_trader.adapters.lighter.constants import API_VERSION, PRICE_PRECISION, QUANTITY_PRECISION, REST_BASE_URL, VENUE\n\n\nclass LighterTickerResponse(msgspec.Struct):\n    symbol: str\n    lastPrice: str\n    volume: str\n    priceStep: str\n    sizeStep: str\n\n\nclass LighterInstrumentProvider:\n    \"\"\"\n    Instrument provider for Lighter.\n    \"\"\"\n\n    def __init__(\n        self,\n        loop: asyncio.AbstractEventLoop,\n        clock: LiveClock,\n        config: LighterConfig,\n    ) -> None:\n        self._clock = clock\n        self._loop = loop\n        self._config = config\n        self._http_client: Optional[HttpClient] = None\n        self._instruments: dict[InstrumentId, CryptoInstrument] = {}\n\n    async def connect(self) -> None:\n        if self._http_client is None:\n            http_config = HttpClientConfig(\n                base_url=REST_BASE_URL,\n                timeout_ms=5000,\n            )\n            self._http_client = HttpClient(\n                loop=self._loop,\n                clock=self._clock,\n                config=http_config,\n            )\n            await self._http_client.connect()\n\n    async def load_all_async(self) -> None:\n        \"\"\"\n        Load all instruments from the exchange.\n        \"\"\"\n        await self.connect()\n        \n        path = f\"/{API_VERSION}/tickers\"\n        params = {\"chainId\": self._config.chain_id}\n        \n        try:\n            response = await self._http_client.get(path, params=params)\n            tickers = msgspec.json.decode(response, type=list[LighterTickerResponse])\n            \n            for ticker in tickers:\n                self._parse_instrument(ticker)\n        except Exception as e:\n            print(f\"Error loading instruments: {e}\")\n\n    def _parse_instrument(self, ticker: LighterTickerResponse) -> None:\n        try:\n            # Parse symbol (BASE-QUOTE)\n            base_quote = ticker.symbol.upper().split(\"-\")\n            if len(base_quote) != 2:\n                return\n            base, quote = base_quote\n            \n            symbol = Symbol(ticker.symbol)\n            instrument_id = InstrumentId(symbol=symbol, venue=VENUE)\n            \n            price_precision = PRICE_PRECISION\n            size_precision = QUANTITY_PRECISION\n            \n            # Create instrument\n            instrument = CryptoInstrument(\n                instrument_id=instrument_id,\n                raw_symbol=ticker.symbol,\n                base_currency=Currency.from_str(base),\n                quote_currency=Currency.from_str(quote),\n                price_precision=price_precision,\n                size_precision=size_precision,\n                price_increment=Price.from_str(ticker.priceStep),\n                size_increment=Quantity.from_str(ticker.sizeStep),\n                lot_size=Quantity.from_str(\"1\"),\n                max_quantity=None,\n                min_quantity=Quantity.from_str(ticker.sizeStep),\n                max_price=None,\n                min_price=Price.from_str(ticker.priceStep),\n                margin_init=None,\n                margin_maint=None,\n                maker_fee=None, # Not in schema, defaults to None or 0\n                taker_fee=None, # Not in schema\n                asset_class=AssetClass.SPOT,\n                venue_type=\"DEX\",\n            )\n            self._instruments[instrument_id] = instrument\n            \n        except Exception as e:\n            print(f\"Error parsing instrument {ticker.symbol}: {e}\")\n\n    def find(self, instrument_id: InstrumentId) -> Optional[CryptoInstrument]:\n        return self._instruments.get(instrument_id)\n\n    def get_all(self) -> list[CryptoInstrument]:\n        return list(self._instruments.values())\n"
  }
}
```