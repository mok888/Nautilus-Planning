```json
{
  "rust_files": {
    "config.rs": "use serde::{Deserialize, Serialize};\nuse std::fmt;\n\n/// Configuration for the Nado (NADO) DEX adapter.\n#[derive(Clone, Serialize, Deserialize, Debug)]\n#[serde(crate = \"serde\")]\npub struct NadoConfig {\n    /// The base URL for the REST API.\n    #[serde(default = \"default_rest_url\")]\n    pub rest_base_url: String,\n\n    /// The base URL for the WebSocket API.\n    #[serde(default = \"default_ws_url\")]\n    pub ws_base_url: String,\n\n    /// The wallet address (sender) used for authentication.\n    pub api_key: String,\n\n    /// The private key (hex string) for signing EIP-712 messages.\n    pub secret_key: String,\n\n    /// Optional: Chain ID for EIP-712 domain (defaults to 1 if not set).\n    #[serde(default)]\n    pub chain_id: u64,\n\n    /// Optional: Contract address for verifying signatures (verifyingContract).\n    #[serde(default)]\n    pub verifying_contract: String,\n}\n\nimpl Default for NadoConfig {\n    fn default() -> Self {\n        Self {\n            rest_base_url: default_rest_url(),\n            ws_base_url: default_ws_url(),\n            api_key: String::new(),\n            secret_key: String::new(),\n            chain_id: 1,\n            verifying_contract: String::new(),\n        }\n    }\n}\n\nimpl fmt::Display for NadoConfig {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(\n            f,\n            \"NadoConfig(rest_base_url={}, ws_base_url={}, api_key=...)\",\n            self.rest_base_url, self.ws_base_url\n        )\n    }\n}\n\nfn default_rest_url() -> String {\n    \"https://gateway.prod.nado.xyz/v1\".to_string()\n}\n\nfn default_ws_url() -> String {\n    \"wss://gateway.prod.nado.xyz/v1/subscribe\".to_string()\n}\n",
    "error.rs": "use thiserror::Error;\n\n/// Core error type for the Nado adapter.\n#[derive(Error, Debug)]\npub enum NadoAdapterError {\n    #[error(\"Network error: {0}\")]\n    Network(#[from] reqwest::Error),\n\n    #[error(\"JSON serialization/deserialization error: {0}\")]\n    Json(#[from] serde_json::Error),\n\n    #[error(\"WebSocket error: {0}\")]\n    WebSocket(String),\n\n    #[error(\"Authentication error: {0}\")]\n    Authentication(String),\n\n    #[error(\"Exchange returned error: {code} - {message}\")]\n    ExchangeError { code: String, message: String },\n\n    #[error(\"Signing error: {0}\")]\n    Signing(String),\n\n    #[error(\"Invalid configuration: {0}\")]\n    Config(String),\n\n    #[error(\"Parsing error: {0}\")]\n    Parsing(String),\n}\n\npub type Result<T> = std::result::Result<T, NadoAdapterError>;\n",
    "http/signing.rs": "use crate::error::Result;\nuse alloy::primitives::{\n    address, Address, B256, FixedBytes, I256, PrimitiveSignature, U256,\n};\nuse alloy::signers::{local::LocalSigner, Signer};\nuse alloy::sol_types::{SolStruct, eip712_domain};\nuse k256::SecretKey;\nuse std::str::FromStr;\n\n// Represents the EIP-712 structure required by Nado for placing orders.\n// Based on schema fields: product_id, sender, priceX18, amount, expiration, nonce\n#[derive(Debug, Clone, SolStruct)]\n#[sol(all_derives)]\npub struct NadoOrder {\n    #[sol(name = \"product_id\")]\n    pub product_id: U256,\n    pub sender: Address,\n    #[sol(name = \"priceX18\")]\n    pub price_x18: U256,\n    pub amount: U256,\n    pub expiration: U256, // Timestamp in nanoseconds\n    pub nonce: U256,\n}\n\npub struct Signer {\n    inner: LocalSigner<SecretKey>,\n    verifying_contract: Address,\n    chain_id: u64,\n}\n\nimpl Signer {\n    pub fn new(secret_key_hex: &str, verifying_contract: &str, chain_id: u64) -> Result<Self> {\n        // Clean hex string\n        let cleaned = secret_key_hex.strip_prefix(\"0x\").unwrap_or(secret_key_hex);\n        let secret_key = SecretKey::from_str(cleaned)\n            .map_err(|e| crate::error::NadoAdapterError::Signing(format!(\"Invalid private key: {}\", e)))?;\n        \n        let signer = LocalSigner::from_secret_key(secret_key);\n        \n        let contract_addr = Address::from_str(verifying_contract)\n            .unwrap_or_else(|_| Address::ZERO);\n\n        Ok(Self {\n            inner: signer,\n            verifying_contract: contract_addr,\n            chain_id,\n        })\n    }\n\n    pub fn address(&self) -> Address {\n        self.inner.address()\n    }\n\n    /// Signs an order payload according to Nado's EIP-712 specifications.\n    pub fn sign_order(&self, order: NadoOrder) -> Result<String> {\n        let domain = eip712_domain! {\n            name: \"Nado\",\n            version: \"1\",\n            chain_id: self.chain_id,\n            verifying_contract: self.verifying_contract,\n        };\n\n        // Encode the typed data\n        let signable_hash = order.eip712_signing_hash(&domain);\n\n        // Sign\n        let sig: PrimitiveSignature = self.inner\n            .sign_hash(signable_hash)\n            .map_err(|e| crate::error::NadoAdapterError::Signing(e.to_string()))?;\n\n        // Convert to hex string (usually r + s + v)\n Ok(format!(\"0x{}\", sig.as_tuple()))\n    }\n}\n\n/// Helper to convert f64 price/amount to x18 fixed point (U256)\npub fn to_x18(value: f64) -> U256 {\n    let scaled = value * 1e18;\n    U256::from(scaled as u128) // Simple conversion, robust for supported ranges\n}\n\n/// Helper to convert U256 x18 fixed point to f64\npub fn from_x18(value: U256) -> f64 {\n    let val = value.to::<u128>();\n    val as f64 / 1e18\n}\n",
    "http/client.rs": "use crate::config::NadoConfig;\nuse crate::error::{NadoAdapterError, Result};\nuse crate::http::signing::{Signer, to_x18, NadoOrder};\nuse crate::parsing::models::{PlaceOrderResponse, QueryOrdersResponse};\nuse alloy::primitives::{Address, U256};\nuse reqwest::header::{HeaderMap, CONTENT_TYPE, ACCEPT_ENCODING};\nuse serde_json::json;\nuse std::time::{SystemTime, UNIX_EPOCH};\n\npub struct NadoHttpClient {\n    client: reqwest::Client,\n    config: NadoConfig,\n    signer: Signer,\n}\n\nimpl NadoHttpClient {\n    pub fn new(config: NadoConfig) -> Result<Self> {\n        let mut headers = HeaderMap::new();\n        headers.insert(ACCEPT_ENCODING, \"gzip, br, deflate\".parse().unwrap());\n        headers.insert(CONTENT_TYPE, \"application/json\".parse().unwrap());\n\n        let client = reqwest::Client::builder()\n            .default_headers(headers)\n            .build()?;\n\n        let signer = Signer::new(\n            &config.secret_key, \n            &config.verifying_contract, \n            config.chain_id\n        )?;\n\n        Ok(Self { client, config, signer })\n    }\n\n    /// Helper to get current nanosecond timestamp\n    fn now_nanos() -> u64 {\n        SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .unwrap()\n            .as_nanos() as u64\n    }\n\n    /// POST /execute - Place Order\n    /// Request fields: product_id, sender, priceX18, amount, expiration, nonce, signature\n    pub async fn place_order(\n        &self,\n        product_id: u64,\n        side: &str, // \"BUY\" or \"SELL\"\n        price: f64,\n        amount: f64,\n    ) -> Result<PlaceOrderResponse> {\n        let sender = self.signer.address();\n        let price_x18 = to_x18(price);\n        let amount_x18 = to_x18(amount);\n        let nonce = U256::from(rand::random::<u64>()); // In production, manage nonces locally\n        let expiration = U256::from(Self::now_nanos() + 300_000_000_000u64); // 5 min from now\n\n        let order_struct = NadoOrder {\n            product_id: U256::from(product_id),\n            sender,\n            price_x18,\n            amount: amount_x18,\n            expiration,\n            nonce,\n        };\n\n        let signature = self.signer.sign_order(order_struct.clone())?;\n\n        let payload = json!({\n            \"product_id\": product_id,\n            \"sender\": format!(\"{sender:?}\"),\n            \"priceX18\": format!(\"{price_x18}\"),\n            \"amount\": format!(\"{amount_x18}\"),\n            \"expiration\": format!(\"{expiration}\"),\n            \"nonce\": format!(\"{nonce}\"),\n            \"signature\": signature,\n            // Adding side/inferred type if necessary, though schema lists specific fields above.\n            // Assuming Side is handled by amount direction or specific logic not fully detailed in schema request_fields.\n            // For DEXes usually amount is negative for sell. We will treat amount as raw magnitude here.\n            \"side\": side // Adding to ensure completeness as \"No inferred behavior\"\n        });\n\n        let url = format!(\"{}/execute\", self.config.rest_base_url);\n        \n        let resp = self\n            .client\n            .post(&url)\n            .json(&payload)\n            .send()\n            .await?;\n\n        let status = resp.status();\n        let body = resp.text().await?;\n\n        if !status.is_success() {\n            return Err(NadoAdapterError::ExchangeError {\n                code: status.as_u16().to_string(),\n                message: body,\n            });\n        }\n\n        let result: PlaceOrderResponse = serde_json::from_str(&body)\n            .map_err(|e| NadoAdapterError::Parsing(format!(\"{}: {}\", e, body)))?;\n\n        Ok(result)\n    }\n\n    /// GET /query - Get Orders\n    /// Request fields: subaccount, product_id\n    pub async fn get_orders(&self, subaccount: &str, product_id: u64) -> Result<QueryOrdersResponse> {\n        let url = format!(\n            \"{}/query?subaccount={}&product_id={}\",\n            self.config.rest_base_url, subaccount, product_id\n        );\n\n        let resp = self.client.get(&url).send().await?;\n        let body = resp.text().await?;\n\n        if !resp.status().is_success() {\n            return Err(NadoAdapterError::ExchangeError {\n                code: resp.status().as_u16().to_string(),\n                message: body,\n            });\n        }\n\n        let result: QueryOrdersResponse = serde_json::from_str(&body)\n            .map_err(|e| NadoAdapterError::Parsing(format!(\"{}: {}\", e, body)))?;\n\n        Ok(result)\n    }\n}\n",
    "parsing/models.rs": "use serde::{Deserialize, Serialize};\n\n/// Response for POST /execute\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PlaceOrderResponse {\n    pub status: String,\n    pub order_id: String,\n}\n\n/// Response for GET /query\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct QueryOrdersResponse {\n    pub orders: Vec<OrderEntry>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OrderEntry {\n    pub order_id: String,\n    pub product_id: u64,\n    pub price_x18: String,\n    pub amount: String,\n    pub state: String,\n    // Additional fields can be added here based on live data\n}\n\n/// WebSocket Public Trade\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct WsTrade {\n    pub channel: String,\n    pub data: TradeData,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TradeData {\n    pub product_id: u64,\n    pub price_x18: String,\n    pub amount: String,\n    pub timestamp: u64,\n}\n\n/// WebSocket Best Bid/Offer\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct WsBBO {\n    pub channel: String,\n    pub data: BBOData,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BBOData {\n    pub product_id: u64,\n    pub best_bid_x18: String,\n    pub best_ask_x18: String,\n}\n\n/// WebSocket Subscription Message (Outgoing)\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct WsSubscribe {\n    #[serde(rename = \"op\")]\n    pub operation: String, // \"subscribe\"\n    pub channel: String,\n}\n\nimpl WsSubscribe {\n    pub fn new(channel: &str) -> Self {\n        Self {\n            operation: \"subscribe\".to_string(),\n            channel: channel.to_string(),\n        }\n    }\n}\n\n/// WebSocket Auth Message (Outgoing)\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct WsAuth {\n    #[serde(rename = \"op\")]\n    pub operation: String, // \"auth\"\n    pub api_key: String,\n    pub signature: String,\n    pub timestamp: u64,\n}\n",
    "websocket/client.rs": "use crate::config::NadoConfig;\nuse crate::error::{NadoAdapterError, Result};\nuse crate::parsing::models::{WsSubscribe, WsTrade, WsBBO};\nuse futures_util::{SinkExt, StreamExt};\nuse serde_json::Value;\nuse tokio_tungstenite::{connect_async, tungstenite::Message};\nuse tokio::time::{interval, Duration};\n\npub struct NadoWebSocketClient {\n    config: NadoConfig,\n}\n\nimpl NadoWebSocketClient {\n    pub fn new(config: NadoConfig) -> Self {\n        Self { config }\n    }\n\n    pub async fn connect_and_run<F>(&self, mut callback: F) -> Result<()>\n    where\n        F: FnMut(Value) + Send + 'static,\n    {\n        let url = &self.config.ws_base_url;\n        let (ws_stream, _) = connect_async(url).await.map_err(|e| {\n            NadoAdapterError::WebSocket(format!(\"Connection failed: {}\", e))\n        })?;\n\n        let (mut write, mut read) = ws_stream.split();\n\n        // Handle Heartbeat (Ping every 30s)\n        let mut ping_interval = interval(Duration::from_secs(30));\n\n        // Subscribe to channels\n        let channels = vec![\"trade\", \"best_bid_offer\"];\n        for chan in channels {\n            let sub_msg = WsSubscribe::new(chan);\n            let payload = serde_json::to_string(&sub_msg).map_err(|e| {\n                NadoAdapterError::Parsing(format!(\"Subscription serialization failed: {}\", e))\n            })?;\n            write.send(Message::Text(payload)).await.map_err(|e| {\n                NadoAdapterError::WebSocket(format!(\"Send subscription failed: {}\", e))\n            })?;\n        }\n\n        loop {\n            tokio::select! {\n                // Incoming messages\n                msg = read.next() => {\n                    match msg {\n                        Some(Ok(msg)) => {\n                            if msg.is_text() {\n                                let text = msg.to_text().map_err(|e| NadoAdapterError::WebSocket(format!(\"Text conversion error: {}\", e)))?;\n                                if let Ok(json) = serde_json::from_str::<Value>(&text) {\n                                    callback(json);\n                                }\n                            } else if msg.is_close() {\n                                break;\n                            }\n                        },\n                        Some(Err(e)) => {\n                            return Err(NadoAdapterError::WebSocket(format!(\"Stream error: {}\", e)));\n                        },\n                        None => {\n                            break;\n                        }\n                    }\n                },\n                // Heartbeat\n                _ = ping_interval.tick() => {\n                    if let Err(e) = write.send(Message::Ping(vec![])).await {\n                        return Err(NadoAdapterError::WebSocket(format!(\"Ping failed: {}\", e)));\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n}\n",
    "python/mod.rs": "use crate::config::NadoConfig;\nuse crate::error::NadoAdapterError;\nuse crate::http::client::NadoHttpClient;\nuse pyo3::prelude::*;\nuse pyo3::types::PyDict;\nuse std::collections::HashMap;\n\n/// Python wrapper for the Nado Adapter\n#[pymodule]\nfn nado_adapter(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<PyNadoClient>()?;\n    m.add_class::<PyNadoConfig>()?;\n    Ok(())\n}\n\n/// PyO3 Wrapper for Configuration\n#[pyclass(name = \"NadoConfig\")]\n#[derive(Clone)]\npub struct PyNadoConfig {\n    config: NadoConfig,\n}\n\n#[pymethods]\nimpl PyNadoConfig {\n    #[new]\n    #[pyo3(signature = (api_key, secret_key, rest_base_url=\"https://gateway.prod.nado.xyz/v1\".to_string(), ws_base_url=\"wss://gateway.prod.nado.xyz/v1/subscribe\".to_string(), chain_id=1, verifying_contract=\"\".to_string()))]\n    fn new(\n        api_key: String,\n        secret_key: String,\n        rest_base_url: String,\n        ws_base_url: String,\n        chain_id: u64,\n        verifying_contract: String,\n    ) -> Self {\n        Self {\n            config: NadoConfig {\n                api_key,\n                secret_key,\n                rest_base_url,\n                ws_base_url,\n                chain_id,\n                verifying_contract,\n            },\n        }\n    }\n}\n\n/// PyO3 Wrapper for the HTTP Client\n#[pyclass(name = \"NadoClient\")]\npub struct PyNadoClient {\n    client: NadoHttpClient,\n}\n\n#[pymethods]\nimpl PyNadoClient {\n    #[new]\n    fn new(py_config: PyNadoConfig) -> PyResult<Self> {\n        let client = NadoHttpClient::new(py_config.config)\n            .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))?;\n        Ok(Self { client })\n    }\n\n    /// Place an order\n    #[pyo3(signature = (product_id, side, price, amount))]\n    fn place_order(\n        &self,\n        py: Python,\n        product_id: u64,\n        side: String,\n        price: f64,\n        amount: f64,\n    ) -> PyResult<PyObject> {\n        py.allow_threads(|| {\n            tokio::runtime::Runtime::new()\n                .unwrap()\n                .block_on(self.client.place_order(product_id, &side, price, amount))\n        })\n        .map(|res| {\n            let dict = PyDict::new(py);\n            dict.set_item(\"status\", res.status).unwrap();\n            dict.set_item(\"order_id\", res.order_id).unwrap();\n            dict.into()\n        })\n        .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))\n    }\n\n    /// Get orders\n    #[pyo3(signature = (subaccount, product_id))]\n    fn get_orders(\n        &self,\n        py: Python,\n        subaccount: String,\n        product_id: u64,\n    ) -> PyResult<PyObject> {\n        py.allow_threads(|| {\n            tokio::runtime::Runtime::new()\n                .unwrap()\n                .block_on(self.client.get_orders(&subaccount, product_id))\n        })\n        .map(|res| {\n            // Convert Rust struct to Python dict for simplicity\n            let dict = PyDict::new(py);\n            let orders_list: Vec<PyObject> = res\n                .orders\n                .into_iter()\n                .map(|o| {\n                    let d = PyDict::new(py);\n                    d.set_item(\"order_id\", o.order_id).unwrap();\n                    d.set_item(\"product_id\", o.product_id).unwrap();\n                    d.set_item(\"state\", o.state).unwrap();\n                    d.into()\n                })\n                .collect();\n            dict.set_item(\"orders\", orders_list).unwrap();\n            dict.into()\n        })\n        .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))\n    }\n}\n"
  }
}
```