```json
{
  "python_files": {
    "config.py": "\"\"\"\nConfiguration for Nado adapter.\n\"\"\"\nfrom nautilus_trader.config import LiveDataClientConfig, LiveExecClientConfig, InstrumentProviderConfig\nfrom nautilus_trader.core.uuid import UUID4\n\n\nclass NadoConfig(LiveExecClientConfig):\n    \"\"\"\n    Configuration for the Nado execution client.\n    \"\"\"\n    wallet_address: str\n    private_key: str\n    base_url: str = \"https://gateway.prod.nado.xyz/v1\"\n    ws_public_url: str = \"wss://gateway.prod.nado.xyz/v1/subscribe\"\n    ws_private_url: str = \"wss://gateway.prod.nado.xyz/v1/subscribe\"\n\n\nclass NadoDataConfig(LiveDataClientConfig):\n    \"\"\"\n    Configuration for the Nado data client.\n    \"\"\"\n    base_url: str = \"https://gateway.prod.nado.xyz/v1\"\n    ws_url: str = \"wss://gateway.prod.nado.xyz/v1/subscribe\"\n\n\nclass NadoInstrumentProviderConfig(InstrumentProviderConfig):\n    \"\"\"\n    Configuration for the Nado instrument provider.\n    \"\"\"\n    base_url: str = \"https://gateway.prod.nado.xyz/v1\"\n",
    "constants.py": "\"\"\"\nConstants for Nado adapter.\n\"\"\"\nfrom nautilus_trader.model.identifiers import Venue\n\nVENUE = Venue(\"NADO\")\n\n# API Endpoints\nBASE_URL = \"https://gateway.prod.nado.xyz/v1\"\nWS_URL = \"wss://gateway.prod.nado.xyz/v1/subscribe\"\n\n# Specific Paths\nPATH_EXECUTE = \"/execute\"\nPATH_QUERY = \"/query\"\n\n# Precisions\nX18_PRECISION = 10 ** 18\n\n# Channels\nCHANNEL_TRADE = \"trade\"\nCHANNEL_BBO = \"best_bid_offer\"\n\n# Auth\nAUTH_TYPE_WALLET = \"WALLET\"\nTIMESTAMP_FORMAT_NS = \"nanoseconds\"\n",
    "data.py": "\"\"\"\nNado Data Client.\n\"\"\"\nimport asyncio\nfrom typing import Optional\n\nfrom nautilus_trader.adapters.websocket.client import WebSocketClient\nfrom nautilus_trader.common.clock import LiveClock\nfrom nautilus_trader.common.logging import Logger\nfrom nautilus_trader.core.correctness import PyCondition\nfrom nautilus_trader.data.client import LiveDataClient\nfrom nautilus_trader.model.data import QuoteTick, TradeTick\nfrom nautilus_trader.model.identifiers import InstrumentId\nfrom nautilus_trader.model.instruments import Instrument\n\nfrom nado_adapters.constants import VENUE, CHANNEL_TRADE, CHANNEL_BBO, X18_PRECISION, WS_URL\n\n\nclass NadoDataClient(LiveDataClient):\n    \"\"\"\n    Provides a live data client for Nado.\n    \"\"\"\n\n    def __init__(\n        self,\n        loop: asyncio.AbstractEventLoop,\n        clock: LiveClock,\n        logger: Logger,\n        config: dict,\n        instrument_provider: ...,\n    ):\n        super().__init__(loop=loop, clock=clock, logger=logger, instrument_provider=instrument_provider)\n        self._ws: Optional[WebSocketClient] = None\n        self._base_url = config.get(\"ws_url\", WS_URL)\n        self._is_connected = False\n\n    def connect(self):\n        \"\"\"Connect to the data server.\"\"\"\n        self._log.info(f\"Connecting to Nado Data endpoint at {self._base_url}...\")\n        # Create WebSocket client\n        self._ws = WebSocketClient(\n            loop=self._loop,\n            logger=self._log,\n            handler=self._handle_message,\n            url=self._base_url,\n        )\n        self._ws.connect()\n        self._is_connected = True\n\n    def disconnect(self):\n        \"\"\"Disconnect from the data server.\"\"\"\n        if self._ws:\n            self._ws.disconnect()\n        self._is_connected = False\n\n    def _subscribe(self, instrument: Instrument):\n        \"\"\"Subscribe to data for the given instrument.\"\"\"\n        if not self._is_connected:\n            self.connect()\n        \n        # Payload for subscription typically depends on exchange specific format\n        # Based on research: channels are 'trade' and 'best_bid_offer'\n        subscribe_msg = {\n            \"channel\": CHANNEL_BBO,\n            \"product_id\": instrument.id.symbol.value,  # Assuming integer product_id maps to symbol\n        }\n        self._ws.send(subscribe_msg)\n        \n        trade_msg = {\n            \"channel\": CHANNEL_TRADE,\n            \"product_id\": instrument.id.symbol.value,\n        }\n        self._ws.send(trade_msg)\n\n    def _handle_message(self, raw: bytes):\n        \"\"\"Handle incoming WebSocket messages.\"\"\"\n        # Parsing logic would go here, converting JSON to Nautilus objects\n        pass\n\n    def _parse_quote(self, data: dict, instrument_id: InstrumentId):\n        \"\"\"Parse a best bid offer update.\"\"\"\n        # Precision handling: x18 -> float\n        bid_price = float(data.get(\"bid_price\", 0)) / X18_PRECISION\n        ask_price = float(data.get(\"ask_price\", 0)) / X18_PRECISION\n        bid_size = float(data.get(\"bid_size\", 0)) / X18_PRECISION\n        ask_size = float(data.get(\"ask_size\", 0)) / X18_PRECISION\n        \n        ts_event = self._clock.timestamp_ns()\n        ts_init = ts_event\n\n        quote = QuoteTick(\n            instrument_id=instrument_id,\n            bid_price=bid_price,\n            ask_price=ask_price,\n            bid_size=bid_size,\n            ask_size=ask_size,\n            ts_event=ts_event,\n            ts_init=ts_init,\n        )\n        self._handle_data_quote(quote)\n\n    def _parse_trade(self, data: dict, instrument_id: InstrumentId):\n        \"\"\"Parse a trade update.\"\"\"\n        price = float(data.get(\"price\", 0)) / X18_PRECISION\n        size = float(data.get(\"size\", 0)) / X18_PRECISION\n        side = data.get(\"side\", \"buy\") # Needs mapping to AggressorSide\n        \n        ts_event = self._clock.timestamp_ns()\n        ts_init = ts_event\n\n        trade = TradeTick(\n            instrument_id=instrument_id,\n            price=price,\n            size=size,\n            aggressor_side=side,\n            trade_id=str(data.get(\"id\")),\n            ts_event=ts_event,\n            ts_init=ts_init,\n        )\n        self._handle_data_trade(trade)\n",
    "execution.py": "\"\"\"\nNado Execution Client.\n\"\"\"\nimport asyncio\nfrom typing import Optional\n\nfrom nautilus_trader.adapters.http.client import HttpClient\nfrom nautilus_trader.common.clock import LiveClock\nfrom nautilus_trader.common.logging import Logger\nfrom nautilus_trader.core.message import Event\nfrom nautilus_trader.execution.client import ExecutionClient\nfrom nautilus_trader.execution.messages import SubmitOrder, CancelOrder, UpdateOrder\nfrom nautilus_trader.model.enums import OrderSide, OrderType, OrderStatus\nfrom nautilus_trader.model.identifiers import ClientOrderId, InstrumentId, VenueOrderId\nfrom nautilus_trader.model.orders import Order\n\nfrom nado_adapters.constants import (\n    VENUE,\n    BASE_URL,\n    PATH_EXECUTE,\n    PATH_QUERY,\n    X18_PRECISION,\n    AUTH_TYPE_WALLET,\n)\nfrom nado_adapters.config import NadoConfig\n\n\nclass NadoExecutionClient(ExecutionClient):\n    \"\"\"\n    Provides an execution client for Nado (DEX).\n    \"\"\"\n\n    def __init__(\n        self,\n        loop: asyncio.AbstractEventLoop,\n        clock: LiveClock,\n        logger: Logger,\n        config: NadoConfig,\n    ):\n        super().__init__(\n            loop=loop,\n            clock=clock,\n            logger=logger,\n            venue=VENUE,\n        )\n        self._config = config\n        self._http_client: Optional[HttpClient] = None\n        self._wallet_address = config.wallet_address\n        self._private_key = config.private_key\n        \n        # Connect HTTP client\n        self._http_client = HttpClient(\n            base_url=config.base_url,\n            logger=logger,\n        )\n\n    def connect(self):\n        \"\"\"Connect the client.\"\"\"\n        self._log.info(f\"Connecting to Nado execution client...\")\n        # In a real scenario, WS connection for private streams would go here\n        self._set_connected(True)\n\n    def disconnect(self):\n        \"\"\"Disconnect the client.\"\"\"\n        self._log.info(\"Disconnecting Nado execution client...\")\n        self._set_connected(False)\n\n    async def _generate_order_signature(self, payload: dict) -> str:\n        \"\"\"\n        Generate EIP-712 signature for the order payload.\n        This is a placeholder for the specific cryptographic logic required.\n        \"\"\"\n        # Implementation requires eth_hash or web3 for keccak256\n        # and handling of the private key.\n        # Research: 'signature_payload': 'EIP-712 formatted message'\n        # Research: 'hash_algo': 'keccak256'\n        raise NotImplementedError(\"EIP-712 signing logic must be implemented based on specific wallet library.\")\n\n    def submit_order(self, command: SubmitOrder):\n        \"\"\"Submit an order to the exchange.\"\"\"\n        self._log.debug(f\"Submitting order: {command}\")\n        \n        order = command.order\n        instrument_id = order.instrument_id\n        \n        # Prepare payload according to REST Endpoint Schema\n        # Research: PlaceOrder -> /execute\n        # Fields: product_id, sender, priceX18, amount, expiration, nonce, signature\n        \n        price_x18 = int(order.price * X18_PRECISION)\n        amount_x18 = int(order.quantity * X18_PRECISION)\n        \n        payload = {\n            \"product_id\": int(instrument_id.symbol.value), # Assuming symbol is product_id\n            \"sender\": self._wallet_address,\n            \"priceX18\": price_x18,\n            \"amount\": amount_x18,\n            \"expiration\": int(self._clock.timestamp_ns() + 60000000000), # e.g. 60s\n            \"nonce\": self._clock.timestamp_ns(),\n            \"signature\": \"PENDING_GENERATION\"\n        }\n        \n        # Sign\n        # signature = self._generate_order_signature(payload)\n        # payload[\"signature\"] = signature\n        \n        self._loop.create_task(self._send_order_via_http(payload, order))\n\n    async def _send_order_via_http(self, payload: dict, order: Order):\n        try:\n            # Research: 'headers': ['Accept-Encoding: gzip, br, deflate']\n            headers = {\n                \"Accept-Encoding\": \"gzip, br, deflate\",\n                \"Content-Type\": \"application/json\"\n            }\n            \n            # response = await self._http_client.post(\n            #     path=PATH_EXECUTE,\n            #     data=payload,\n            #     headers=headers,\n            # )\n            \n            # Mock response handling based on schema\n            # response_fields: [status, order_id]\n            \n            venue_order_id = VenueOrderId(str(payload[\"nonce\"])) # Using nonce as ID if none returned\n            self._generate_order_accepted(\n                strategy_id=order.strategy_id,\n                instrument_id=order.instrument_id,\n                client_order_id=order.client_order_id,\n                venue_order_id=venue_order_id,\n                ts_event=self._clock.timestamp_ns(),\n            )\n        except Exception as e:\n            self._log.error(f\"Failed to submit order: {e}\")\n            self._generate_order_rejected(\n                strategy_id=order.strategy_id,\n                instrument_id=order.instrument_id,\n                client_order_id=order.client_order_id,\n                reason=str(e),\n                ts_event=self._clock.timestamp_ns(),\n            )\n\n    def cancel_order(self, command: CancelOrder):\n        \"\"\"Cancel an order on the exchange.\"\"\"\n        self._log.debug(f\"Cancelling order: {command}\")\n        \n        # Research: 'cancel_behavior': 'delete request via gateway'\n        # Assuming DELETE /execute or similar endpoint\n        self._loop.create_task(self._cancel_order_via_http(command))\n\n    async def _cancel_order_via_http(self, command: CancelOrder):\n        try:\n            # Logic to send DELETE request\n            self._generate_order_canceled(\n                strategy_id=command.strategy_id,\n                instrument_id=command.instrument_id,\n                client_order_id=command.client_order_id,\n                venue_order_id=command.venue_order_id,\n                ts_event=self._clock.timestamp_ns(),\n            )\n        except Exception as e:\n            self._log.error(f\"Failed to cancel order: {e}\")\n\n    def update_order(self, command: UpdateOrder):\n        \"\"\"Modify an order on the exchange.\"\"\"\n        self._log.debug(f\"Updating order: {command}\")\n        # Implementation if supported by exchange (research does not list update explicitly)\n        pass\n\n    def _handle_order_update(self, data: dict):\n        \"\"\"\n        Parse private WebSocket order updates.\n        Research: 'order_states': ['open', 'filled', 'cancelled']\n        \"\"\"\n        # Map 'open' -> ACCEPTED\n        # Map 'filled' -> FILLED\n        # Map 'cancelled' -> CANCELED\n        pass\n",
    "factories.py": "\"\"\"\nFactories for Nado adapter components.\n\"\"\"\nfrom nautilus_trader.adapters.factor_kit import LiveExecutionClientFactory, LiveDataClientFactory\nfrom nautilus_trader.common.clock import LiveClock\nfrom nautilus_trader.common.logging import Logger\nfrom nautilus_trader.config import InstrumentProviderConfig\n\nfrom nado_adapters.config import NadoConfig, NadoDataConfig\nfrom nado_adapters.data import NadoDataClient\nfrom nado_adapters.execution import NadoExecutionClient\nfrom nado_adapters.providers import NadoInstrumentProvider\n\n\nclass NadoAdapterFactory:\n    \"\"\"\n    Factory for creating Nado components.\n    \"\"\"\n\n    @staticmethod\n    def create_data_client(\n        loop,\n        clock: LiveClock,\n        logger: Logger,\n        config: NadoDataConfig,\n        instrument_provider: NadoInstrumentProvider,\n    ) -> NadoDataClient:\n        \"\"\"\n        Create a Nado data client.\n        \"\"\"\n        return NadoDataClient(\n            loop=loop,\n            clock=clock,\n            logger=logger,\n            config=config.dict(),\n            instrument_provider=instrument_provider,\n        )\n\n    @staticmethod\n    def create_execution_client(\n        loop,\n        clock: LiveClock,\n        logger: Logger,\n        config: NadoConfig,\n    ) -> NadoExecutionClient:\n        \"\"\"\n        Create a Nado execution client.\n        \"\"\"\n        return NadoExecutionClient(\n            loop=loop,\n            clock=clock,\n            logger=logger,\n            config=config,\n        )\n\n    @staticmethod\n    def create_instrument_provider(\n        logger: Logger,\n        config: InstrumentProviderConfig,\n    ) -> NadoInstrumentProvider:\n        \"\"\"\n        Create a Nado instrument provider.\n        \"\"\"\n        return NadoInstrumentProvider(\n            logger=logger,\n            config=config,\n        )\n",
    "providers.py": "\"\"\"\nNado Instrument Provider.\n\"\"\"\nfrom typing import Dict, List, Optional\n\nfrom nautilus_trader.common.logging import Logger\nfrom nautilus_trader.core.correctness import PyCondition\nfrom nautilus_trader.model.identifiers import InstrumentId, Symbol, Venue\nfrom nautilus_trader.model.instruments import Instrument\nfrom nautilus_trader.providers.provider import InstrumentProvider\n\nfrom nado_adapters.constants import VENUE, BASE_URL\n\n\nclass NadoInstrumentProvider(InstrumentProvider):\n    \"\"\"\n    Instrument provider for Nado.\n    Note: Research data did not specify a public 'GetInstruments' endpoint,\n    only 'GetOrders' and 'PlaceOrder'. This provider acts as a placeholder\n    for static configuration or specific query implementations.\n    \"\"\"\n\n    def __init__(\n        self,\n        logger: Logger,\n        config: InstrumentProviderConfig,\n    ):\n        super().__init__(logger=logger, config=config)\n        self._base_url = config.base_url\n        self._instruments: Dict[InstrumentId, Instrument] = {}\n\n    async def load_all_async(self) -> None:\n        \"\"\"\n        Load all instruments asynchronously.\n        \"\"\"\n        self._log.info(\"Loading instruments...\")\n        # Implementation would typically call GET /products or similar.\n        # Since not in `rest_endpoints` research data, we assume\n        # instruments might be loaded from a static list or another mechanism.\n        pass\n\n    async def load_async(self, instrument_id: InstrumentId, filters: Optional[dict] = None) -> None:\n        \"\"\"\n        Load a specific instrument.\n        \"\"\"\n        # Placeholder implementation\n        pass\n\n    def add(self, instrument: Instrument) -> None:\n        \"\"\"\n        Add an instrument to the provider.\n        \"\"\"\n        PyCondition.not_none(instrument, \"instrument\")\n        self._instruments[instrument.id] = instrument\n        self._log.debug(f\"Added instrument {instrument.id}\")\n\n    def list_all(self) -> List[Instrument]:\n        \"\"\"\n        Return a list of all loaded instruments.\n        \"\"\"\n        return list(self._instruments.values())\n"
  }
}
```