```json
{
  "rust_files": {
    "common/consts.rs": "use nautilus_core::time::UnixTimestamp;\n\n/// The exchange identifier for Lighter.\npub const EXCHANGE_ID: &str = \"LIGHTER\";\n\n/// The exchange display name.\npub const EXCHANGE_NAME: &str = \"Lighter\";\n\n/// Default chain ID for Lighter (Polygon).\npub const DEFAULT_CHAIN_ID: &str = \"137\";\n\n/// Content type header value.\npub const CONTENT_TYPE_JSON: &str = \"application/json\";\n\n/// Header key for Chain ID.\npub const HEADER_CHAIN_ID: &str = \"x-lighter-chain-id\";\n\n/// Header key for API Key.\npub const HEADER_API_KEY: &str = \"x-api-key\";\n\n/// Header key for Timestamp.\npub const HEADER_TIMESTAMP: &str = \"x-timestamp\";\n\n/// Header key for Signature.\npub const HEADER_SIGNATURE: &str = \"x-signature\";\n",
    "common/urls.rs": "/// Base URL for Lighter REST API (Mainnet).\npub const HTTP_BASE_URL: &str = \"https://api.lighter.xyz\";\n\n/// Base URL for Lighter REST API (Testnet).\npub const HTTP_BASE_URL_TESTNET: &str = \"https://api.testnet.lighter.xyz\";\n\n/// WebSocket URL for Lighter Public feeds.\npub const WS_PUBLIC_URL: &str = \"wss://api.lighter.xyz/ws\";\n\n/// WebSocket URL for Lighter Private feeds.\npub const WS_PRIVATE_URL: &str = \"wss://api.lighter.xyz/ws\";\n",
    "config.rs": "use nautilus_core::python::to_pyresult;\nuse nautilus_model::identifiers::AccountId;\nuse pyo3::prelude::*;\nuse serde::{Deserialize, Serialize};\n\nuse crate::common::consts::DEFAULT_CHAIN_ID;\n\n/// Configuration for the Lighter adapter.\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct LighterConfig {\n    /// The API key for authentication.\n    pub api_key: Option<String>,\n\n    /// The API secret for authentication.\n    pub api_secret: Option<String>,\n\n    /// The Chain ID (e.g., 137 for Polygon).\n    #[serde(default = \"default_chain_id\")]\n    pub chain_id: String,\n\n    /// Whether to use testnet.\n    #[serde(default)]\n    pub testnet: bool,\n}\n\nfn default_chain_id() -> String {\n    DEFAULT_CHAIN_ID.to_string()\n}\n\nimpl Default for LighterConfig {\n    fn default() -> Self {\n        Self {\n            api_key: None,\n            api_secret: None,\n            chain_id: default_chain_id(),\n            testnet: false,\n        }\n    }\n}\n\n#[pymethods]\nimpl LighterConfig {\n    #[new]\n    #[pyo3(signature = (api_key=None, api_secret=None, chain_id=None, testnet=false))]\n    fn new(\n        api_key: Option<String>,\n        api_secret: Option<String>,\n        chain_id: Option<String>,\n        testnet: bool,\n    ) -> Self {\n        Self {\n            api_key,\n            api_secret,\n            chain_id: chain_id.unwrap_or_else(|| DEFAULT_CHAIN_ID.to_string()),\n            testnet,\n        }\n    }\n}\n",
    "error.rs": "use thiserror::Error;\n\n/// Errors that can occur during Lighter adapter operation.\n#[derive(Debug, Error)]\npub enum LighterError {\n    #[error(\"HTTP client error: {0}\")]\n    HttpClientError(#[from] hyper::Error),\n\n    #[error(\"HTTP error: {status} - {message}\")]\n    HttpError { status: u16, message: String },\n\n    #[error(\"Serialization error: {0}\")]\n    SerializationError(#[from] serde_json::Error),\n\n    #[error(\"Signing error: {0}\")]\n    SigningError(String),\n\n    #[error(\"WebSocket error: {0}\")]\n    WebSocketError(String),\n\n    #[error(\"Invalid configuration: {0}\")]\n    ConfigError(String),\n\n    #[error(\"Unsupported operation: {0}\")]\n    UnsupportedOperation(String),\n}\n\npub type Result<T> = std::result::Result<T, LighterError>;\n",
    "http/client.rs": "use std::future::Future;\nuse std::pin::Pin;\nuse std::sync::Arc;\nuse std::task::{Context, Poll};\nuse std::time::Duration;\n\nuse hyper::body::{Body, Frame, Incoming};\nuse hyper::client::conn::http1::{SendRequest, Builder as ConnBuilder};\nuse hyper::rt::Executor;\nuse hyper::Request;\nuse hyper_util::client::legacy::connect::HttpConnector;\nuse hyper_util::rt::TokioExecutor;\nuse hyper_rustls::HttpsConnector;\nuse tower::{Service, ServiceBuilder};\nuse governor::{Quota, RateLimiter, Jitter, clock::DefaultClock, state::{InMemoryState, NotKeyed}};\nuse nonzero_ext::nonzero;\nuse http_body_util::{Full, BodyExt};\nuse bytes::Bytes;\n\nuse crate::common::urls::{HTTP_BASE_URL, HTTP_BASE_URL_TESTNET};\nuse crate::common::consts::{CONTENT_TYPE_JSON, HEADER_CHAIN_ID};\nuse crate::config::LighterConfig;\nuse crate::error::{LighterError, Result};\nuse crate::http::signing::sign_request;\n\n/// Type alias for the body used in requests.\npub type ReqBody = Full<Bytes>;\n\n/// HTTP client for Lighter API.\npub struct LighterHttpClient {\n    config: LighterConfig,\n    base_url: String,\n    rate_limiter: Arc<RateLimiter<NotKeyed, InMemoryState, DefaultClock, NoOpMiddleware>>,\n    connector: HttpsConnector<HttpConnector>,\n    executor: TokioExecutor,\n}\n\n// Custom middleware for governor to satisfy trait bounds in older versions if needed, \n// though typically NoOpMiddleware or default is used.\nstruct NoOpMiddleware;\n\nimpl governor::middleware::RateLimitingMiddleware<NotKeyed> for NoOpMiddleware {\n    type RequestBody = ();\n    fn on_rate_limited(&self, _: &mut NotKeyed, _: &NoOpMiddleware::RequestBody) {} \n}\n\nimpl LighterHttpClient {\n    pub fn new(config: LighterConfig) -> Self {\n        let base_url = if config.testnet {\n            HTTP_BASE_URL_TESTNET.to_string()\n        } else {\n            HTTP_BASE_URL.to_string()\n        };\n\n        // Rate limit: 120 requests per minute (1m window) from schema\n        let quota = Quota::per_minute(nonzero!(120u32));\n        let rate_limiter = RateLimiter::direct(quota);\n\n        // Setup HTTPS connector\n        let connector = HttpsConnector::with_default_roots().unwrap();\n\n        Self {\n            config,\n            base_url,\n            rate_limiter: Arc::new(rate_limiter),\n            connector,\n            executor: TokioExecutor::new(),\n        }\n    }\n\n    async fn send_request_inner(&self, req: Request<ReqBody>) -> Result<hyper::Response<Incoming>> {\n        // Enforce rate limit\n        self.rate_limiter.until_ready().await;\n\n        let host = self.base_url\n            .strip_prefix(\"https://\")\n            .expect(\"Invalid base URL format\")\n            .to_string();\n            \n        let stream = self.connector\n            .call(host)\n            .await\n            .map_err(|e| LighterError::HttpClientError(hyper::Error::new(e)))?;\n\n        let (mut sender, conn) = SendRequest::new(Builder::new().executor(self.executor.clone()), stream)\n            .await\n            .map_err(|e| LighterError::HttpClientError(e))?;\n\n        // Spawn the connection task to drive the state\n        tokio::spawn(conn);\n\n        sender\n            .send_request(req)\n            .await\n            .map_err(LighterError::HttpClientError)\n    }\n\n    pub async fn request_signed(\n        &self,\n        method: hyper::Method,\n        path: &str,\n        body: Option<String>,\n    ) -> Result<String> {\n        let full_path = if path.starts_with('/') {\n            path.to_string()\n        } else {\n            format!(\"/{}\", path)\n        };\n\n        let body_str = body.unwrap_or_default();\n        let byte_body = Bytes::from(body_str.clone());\n        \n        let mut req_builder = Request::builder()\n            .method(method.clone())\n            .uri(format!(\"{}{}\", self.base_url, full_path));\n\n        // Sign the request\n        req_builder = sign_request(&self.config, method.as_str(), &full_path, &body_str, req_builder)?;\n\n        // Inject standard headers (redundant if sign_request does it, but safe to ensure)\n        req_builder = req_builder.header(\"Content-Type\", CONTENT_TYPE_JSON);\n        req_builder = req_builder.header(HEADER_CHAIN_ID, &self.config.chain_id);\n\n        let req = req_builder\n            .body(ReqBody::from(byte_body))\n            .map_err(|e| LighterError::ConfigError(e.to_string()))?;\n\n        let resp = self.send_request_inner(req).await?;\n        \n        let status = resp.status();\n        let body_bytes = resp\n            .collect()\n            .await\n            .map_err(|e| LighterError::HttpClientError(e))?\n            .to_bytes();\n            \n        let response_str = String::from_utf8(body_bytes.to_vec())\n            .map_err(|e| LighterError::SerializationError(e.into()))?;\n\n        if !status.is_success() {\n            return Err(LighterError::HttpError {\n                status: status.as_u16(),\n                message: response_str,\n            });\n        }\n\n        Ok(response_str)\n    }\n\n    pub async fn request_public(\n        &self,\n        method: hyper::Method,\n        path: &str,\n        body: Option<String>,\n    ) -> Result<String> {\n        let full_path = if path.starts_with('/') {\n            path.to_string()\n        } else {\n            format!(\"/{}\", path)\n        };\n\n        let byte_body = body.map(|b| Bytes::from(b)).unwrap_or_default();\n        \n        let req_builder = Request::builder()\n            .method(method.clone())\n            .uri(format!(\"{}{}\", self.base_url, full_path))\n            .header(\"Content-Type\", CONTENT_TYPE_JSON)\n            .header(HEADER_CHAIN_ID, &self.config.chain_id);\n\n        let req = req_builder\n            .body(ReqBody::from(byte_body))\n            .map_err(|e| LighterError::ConfigError(e.to_string()))?;\n\n        let resp = self.send_request_inner(req).await?;\n        \n        let status = resp.status();\n        let body_bytes = resp\n            .collect()\n            .await\n            .map_err(|e| LighterError::HttpClientError(e))?\n            .to_bytes();\n\n        let response_str = String::from_utf8(body_bytes.to_vec())\n            .map_err(|e| LighterError::SerializationError(e.into()))?;\n\n        if !status.is_success() {\n            return Err(LighterError::HttpError {\n                status: status.as_u16(),\n                message: response_str,\n            });\n        }\n\n        Ok(response_str)\n    }\n}\n",
    "http/signing.rs": "use crate::common::consts::{HEADER_API_KEY, HEADER_SIGNATURE, HEADER_TIMESTAMP};\nuse crate::config::LighterConfig;\nuse crate::error::{LighterError, Result};\nuse hex;\nuse hmac::{Hmac, Mac};\nuse http::request::Builder;\nuse sha2::Sha256;\n\ntype HmacSha256 = Hmac<Sha256>;\n\n/// Generates the signature and headers required for authenticated Lighter requests.\npub fn sign_request(\n    config: &LighterConfig,\n    method: &str,\n    path: &str,\n    body: &str,\n    request_builder: Builder,\n) -> Result<Builder> {\n    let api_key = config.api_key.as_ref().ok_or_else(|| {\n        LighterError::ConfigError(\"API Key is missing for signed request\".into())\n    })?;\n    let api_secret = config.api_secret.as_ref().ok_or_else(|| {\n        LighterError::ConfigError(\"API Secret is missing for signed request\".into())\n    })?;\n\n    // Current timestamp in milliseconds\n    let timestamp = chrono::Utc::now().timestamp_millis().to_string();\n\n    // Payload: timestamp + method + requestPath + body\n    // Schema: \"timestamp + method + requestPath + body\"\n    let payload = format!(\"{}{}{}{}\", timestamp, method, path, body);\n\n    // Decode secret from hex (assuming secret is stored as hex string or raw)\n    // Usually API secrets are base64 or hex. Assuming hex based on \"encoding: hex\" in schema context usually referring to output or input format.\n    // If the secret itself is raw bytes, we skip decode. Assuming standard hex input for secret storage.\n    let key_bytes = hex::decode(api_secret).map_err(|e| LighterError::SigningError(e.to_string()))?;\n\n    let mut mac = HmacSha256::new_from_slice(&key_bytes)\n        .map_err(|e| LighterError::SigningError(e.to_string()))?;\n    mac.update(payload.as_bytes());\n    let signature = hex::encode(mac.finalize().into_bytes());\n\n    let request_builder = request_builder\n        .header(HEADER_API_KEY, api_key)\n        .header(HEADER_TIMESTAMP, timestamp)\n        .header(HEADER_SIGNATURE, signature);\n\n    Ok(request_builder)\n}\n",
    "websocket/client.rs": "use std::sync::Arc;\nuse std::time::Duration;\n\nuse futures_util::{SinkExt, StreamExt};\nuse tokio_tungstenite::tungstenite::protocol::Message;\nuse url::Url;\n\nuse crate::common::urls::{WS_PUBLIC_URL, WS_PRIVATE_URL};\nuse crate::config::LighterConfig;\nuse crate::error::{LighterError, Result};\n\n/// WebSocket client for Lighter.\npub struct LighterWebSocketClient {\n    endpoint: String,\n    config: LighterConfig,\n}\n\nimpl LighterWebSocketClient {\n    pub fn new(endpoint: String, config: LighterConfig) -> Self {\n        Self { endpoint, config }\n    }\n\n    pub async fn connect_public(&self) -> Result<()> {\n        let url = Url::parse(&self.endpoint)\n            .map_err(|e| LighterError::ConfigError(format!(\"Invalid WS URL: {}\", e)))?;\n\n        let (ws_stream, _response) = tokio_tungstenite::connect_async(url)\n            .await\n            .map_err(|e| LighterError::WebSocketError(e.to_string()))?;\n\n        let (mut write, mut read) = ws_stream.split();\n\n        // Heartbeat logic could be triggered here based on 30s interval\n        // For now, we just handle the connection structure.\n\n        // Example subscribe payload\n        // Note: Schema doesn't define exact JSON format, assuming standard JSON-RPC or simple subscription object\n        let subscribe_msg = r#\"{\"method\":\"subscribe\",\"params\":[\"orderbook:BTC-USDT\"]}\"#;\n        write\n            .send(Message::Text(subscribe_msg.to_string()))\n            .await\n            .map_err(|e| LighterError::WebSocketError(e.to_string()))?;\n\n        // Spawn a task for the heartbeat\n        let mut write_clone = write.reunite(read).unwrap().0; // Reunite for the task, simplified here for snippet validity\n        // In a real adapter, we would keep the split handles alive.\n\n        // Listener loop\n        // Note: reunite above was to show ownership logic. In reality, we hold both in the loop.\n        // Let's fix the logic for the snippet to be a valid loop.\n        \n        let (mut write, mut read) = ws_stream.split();\n        tokio::spawn(async move {\n            loop {\n                tokio::time::sleep(Duration::from_secs(30)).await;\n                if write.send(Message::Ping(Vec::new())).await.is_err() {\n                    break;\n                }\n            }\n        });\n\n        while let Some(message) = read.next().await {\n            match message {\n                Ok(msg) => {\n                    if msg.is_text() {\n                        let data = msg.to_text().unwrap(); // Safe to unwrap for text\n                        // Handle data parsing\n                        // TODO: Dispatch to parser\n                        println!(\"Received: {}\", data);\n                    } else if msg.is_ping() {\n                        // tungstenite handles ping/pong automatically usually\n                    } else if msg.is_close() {\n                        break;\n                    }\n                }\n                Err(e) => {\n                    return Err(LighterError::WebSocketError(e.to_string()));\n                }\n            }\n        }\n\n        Ok(())\n    }\n}\n",
    "parsing/models.rs": "use serde::{Deserialize, Serialize};\nuse nautilus_model::identifiers::{symbol::Symbol, trade_id::TradeId};\nuse nautilus_model::enums::{Side, OrderSide};\nuse nautilus_model::data::{QuoteTick, TradeTick};\nuse nautilus_model::types::{price::Price, quantity::Quantity};\nuse chrono::{DateTime, Utc};\n\n/// Response from `/v1/tickers`\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LighterTicker {\n    #[serde(rename = \"symbol\")]\n    pub symbol: String,\n    #[serde(rename = \"lastPrice\")]\n    pub last_price: String,\n    pub volume: String,\n    #[serde(rename = \"priceStep\")]\n    pub price_step: String,\n    #[serde(rename = \"sizeStep\")]\n    pub size_step: String,\n}\n\n/// Response from `/v1/orderbook`\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LighterOrderBook {\n    pub bids: Vec<[String; 2]>, // [price, size]\n    pub asks: Vec<[String; 2]>,\n    pub timestamp: i64,\n}\n\n/// Represents an order update from WebSocket or REST\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LighterOrder {\n    #[serde(rename = \"orderId\")]\n    pub order_id: String,\n    pub symbol: String,\n    pub status: String,\n    pub side: String,\n    #[serde(rename = \"type\")]\n    pub order_type: String,\n    pub price: String,\n    pub quantity: String,\n}\n\n/// Represents a trade fill\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LighterTrade {\n    pub id: String,\n    pub symbol: String,\n    pub side: String,\n    pub price: String,\n    pub quantity: String,\n    pub timestamp: i64,\n}\n\n/// Helper to map Lighter side to Nautilus Side\npub fn parse_lighter_side(side: &str) -> Result<OrderSide, String> {\n    match side.to_uppercase().as_str() {\n        \"BUY\" => Ok(OrderSide::Buy),\n        \"SELL\" => Ok(OrderSide::Sell),\n        _ => Err(format!(\"Unknown side: {}\", side)),\n    }\n}\n\n/// Helper to parse timestamp\npub fn parse_timestamp(ms: i64) -> DateTime<Utc> {\n    DateTime::<Utc>::from_timestamp_millis(ms).unwrap_or_else(Utc::now)\n}\n",
    "python/mod.rs": "use pyo3::prelude::*;\nuse pyo3::types::PyDict;\n\nuse crate::config::LighterConfig;\n\n#[pymodule]\nfn lighter_adapter(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<LighterConfig>()?;\n    // Add other classes like LighterHttpClient, LighterWebSocketClient here if exposed to Python\n    Ok(())\n}\n",
    "python/urls.rs": "use pyo3::prelude::*;\n\n/// Python module for URL constants.\n#[pymodule]\npub fn urls(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add(\"HTTP_BASE_URL\", crate::common::urls::HTTP_BASE_URL)?;\n    m.add(\"HTTP_BASE_URL_TESTNET\", crate::common::urls::HTTP_BASE_URL_TESTNET)?;\n    m.add(\"WS_PUBLIC_URL\", crate::common::urls::WS_PUBLIC_URL)?;\n    m.add(\"WS_PRIVATE_URL\", crate::common::urls::WS_PRIVATE_URL)?;\n    Ok(())\n}\n"
  }
}
```