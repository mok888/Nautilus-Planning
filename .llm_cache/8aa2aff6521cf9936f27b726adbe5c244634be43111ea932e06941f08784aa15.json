```json
{
  "rust_files": {
    "config.rs": "use serde::{Deserialize, Serialize};\n\n/// Configuration for the Lighter DEX adapter.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LighterConfig {\n    /// The API Key for authentication.\n    pub api_key: String,\n    /// The Secret Key for signing requests.\n    pub api_secret: String,\n    /// The Chain ID (e.g., 137 for Polygon Mainnet).\n    pub chain_id: u64,\n    /// Base URL for the REST API.\n    #[serde(default = \"default_rest_url\")]\n    pub rest_base_url: String,\n    /// URL for the WebSocket connection.\n    #[serde(default = \"default_ws_url\")]\n    pub ws_base_url: String,\n}\n\nfn default_rest_url() -> String {\n    \"https://api.lighter.xyz\".to_string()\n}\n\nfn default_ws_url() -> String {\n    \"wss://api.lighter.xyz/ws\".to_string()\n}\n\nimpl Default for LighterConfig {\n    fn default() -> Self {\n        Self {\n            api_key: String::new(),\n            api_secret: String::new(),\n            chain_id: 1,\n            rest_base_url: default_rest_url(),\n            ws_base_url: default_ws_url(),\n        }\n    }\n}",
    "error.rs": "use thiserror::Error;\n\n/// Lighter adapter specific errors.\n#[derive(Debug, Error)]\npub enum LighterAdapterError {\n    #[error(\"HTTP request failed: {0}\")]\n    RequestError(#[from] reqwest::Error),\n\n    #[error(\"JSON parsing failed: {0}\")]\n    JsonError(#[from] serde_json::Error),\n\n    #[error(\"Invalid configuration: {0}\")]\n    ConfigError(String),\n\n    #[error(\"Authentication failed: {0}\")]\n    AuthenticationError(String),\n\n    #[error(\"Parsing error: {0}\")]\n    ParsingError(String),\n\n    #[error(\"Websocket error: {0}\")]\n    WebsocketError(String),\n}",
    "http/client.rs": "use crate::config::LighterConfig;\nuse crate::error::LighterAdapterError;\nuse crate::http::signing::generate_signature;\nuse chrono::Utc;\nuse reqwest::{header::HeaderMap, Client, Method};\nuse serde::de::DeserializeOwned;\nuse serde_json::json;\nuse std::collections::HashMap;\nuse tracing::{debug, error, info};\n\npub struct HttpClient {\n    client: Client,\n    config: LighterConfig,\n}\n\nimpl HttpClient {\n    pub fn new(config: LighterConfig) -> Self {\n        Self {\n            client: Client::new(),\n            config,\n        }\n    }\n\n    fn prepare_headers(&self, method: &Method, path: &str, body: &str) -> HeaderMap {\n        let mut headers = HeaderMap::new();\n        let timestamp = Utc::now().timestamp_millis().to_string();\n        \n        // Construct signature payload: timestamp + method + requestPath + body\n        let payload = format!(\"{}{}{}{}\", timestamp, method, path, body);\n        let signature = generate_signature(&self.config.api_secret, &payload);\n\n        headers.insert(\"x-lighter-chain-id\", self.config.chain_id.to_string().parse().unwrap());\n        headers.insert(\"x-api-key\", self.config.api_key.parse().unwrap());\n        headers.insert(\"x-timestamp\", timestamp.parse().unwrap());\n        headers.insert(\"x-signature\", signature.parse().unwrap());\n        headers.insert(\"Content-Type\", \"application/json\".parse().unwrap());\n\n        headers\n    }\n\n    async fn send_signed<R: DeserializeOwned>(\n        &self,\n        method: Method,\n        path: &str,\n        body: Option<&serde_json::Value>,\n    ) -> Result<R, LighterAdapterError> {\n        let body_str = body.map_or(String::new(), |b| b.to_string());\n        let url = format!(\"{}{}\", self.config.rest_base_url, path);\n        \n        info!(\"Sending signed {} request to {}\", method, url);\n\n        let mut request = self.client.request(method.clone(), &url);\n        request = request.headers(self.prepare_headers(&method, path, &body_str));\n\n        if let Some(b) = body {\n            request = request.json(b);\n        }\n\n        let response = request.send().await?;\n        let status = response.status();\n        let text = response.text().await?;\n\n        if status.is_success() {\n            serde_json::from_str(&text).map_err(Into::into)\n        } else {\n            error!(\"Error response: {}\", text);\n            Err(LighterAdapterError::RequestError(\n                reqwest::Error::new(reqwest::StatusCode::from_u16(status.as_u16()).unwrap(), text)\n            ))\n        }\n    }\n\n    async fn send_public<R: DeserializeOwned>(\n        &self,\n        method: Method,\n        path: &str,\n        query: Option<&HashMap<String, String>>,\n    ) -> Result<R, LighterAdapterError> {\n        let url = format!(\"{}{}\", self.config.rest_base_url, path);\n        info!(\"Sending public {} request to {}\", method, url);\n\n        let mut request = self.client.request(method, &url);\n        if let Some(q) = query {\n            request = request.query(q);\n        }\n\n        let response = request.send().await?;\n        let status = response.status();\n        let text = response.text().await?;\n\n        if status.is_success() {\n            serde_json::from_str(&text).map_err(Into::into)\n        } else {\n            Err(LighterAdapterError::RequestError(\n                reqwest::Error::new(reqwest::StatusCode::from_u16(status.as_u16()).unwrap(), text)\n            ))\n        }\n    }\n\n    // --- Endpoint Implementations ---\n\n    pub async fn get_tickers(&self) -> Result<Vec<Ticker>, LighterAdapterError> {\n        let mut query = HashMap::new();\n        query.insert(\"chainId\".to_string(), self.config.chain_id.to_string());\n        self.send_public(Method::GET, \"/v1/tickers\", Some(&query)).await\n    }\n\n    pub async fn get_orderbook(&self, symbol: &str) -> Result<OrderBookResponse, LighterAdapterError> {\n        let mut query = HashMap::new();\n        query.insert(\"chainId\".to_string(), self.config.chain_id.to_string());\n        query.insert(\"symbol\".to_string(), symbol.to_string());\n        self.send_public(Method::GET, \"/v1/orderbook\", Some(&query)).await\n    }\n\n    pub async fn create_order(&self, order_req: &CreateOrderRequest) -> Result<OrderResponse, LighterAdapterError> {\n        let body = json!(order_req);\n        self.send_signed(Method::POST, \"/v1/order\", Some(&body)).await\n    }\n}\n\n// --- DTOs ---\n\n#[derive(Debug, Deserialize)]\npub struct Ticker {\n    pub symbol: String,\n    #[serde(rename = \"lastPrice\")]\n    pub last_price: String,\n    pub volume: String,\n    #[serde(rename = \"priceStep\")]\n    pub price_step: String,\n    #[serde(rename = \"sizeStep\")]\n    pub size_step: String,\n}\n\n#[derive(Debug, Deserialize)]\npub struct OrderBookResponse {\n    pub bids: Vec<[String; 2]>,\n    pub asks: Vec<[String; 2]>,\n    pub timestamp: i64,\n}\n\n#[derive(Debug, Serialize)]\npub struct CreateOrderRequest {\n    #[serde(rename = \"chainId\")]\n    pub chain_id: u64,\n    pub symbol: String,\n    pub side: String, // \"BUY\" or \"SELL\"\n    #[serde(rename = \"type\")]\n    pub order_type: String, // \"LIMIT\", \"MARKET\"\n    pub price: String,\n    pub quantity: String,\n    #[serde(rename = \"clientOrderId\")]\n    pub client_order_id: String,\n    pub tif: String, // Time in Force, e.g., \"GTC\"\n}\n\n#[derive(Debug, Deserialize)]\npub struct OrderResponse {\n    #[serde(rename = \"orderId\")]\n    pub order_id: String,\n    pub status: String,\n    pub symbol: String,\n}",
    "http/signing.rs": "use crate::error::LighterAdapterError;\nuse hmac::{Hmac, Mac};\nuse sha2::Sha256;\n\ntype HmacSha256 = Hmac<Sha256>;\n\n/// Generates a SHA256 HMAC signature.\npub fn generate_signature(secret: &str, payload: &str) -> String {\n    let mut mac = HmacSha256::new_from_slice(secret.as_bytes()).expect(\"HMAC can take key of any size\");\n    mac.update(payload.as_bytes());\n    let result = mac.finalize();\n    let code_bytes = result.into_bytes();\n    hex::encode(code_bytes)\n}",
    "websocket/client.rs": "use crate::config::LighterConfig;\nuse crate::error::LighterAdapterError;\nuse crate::http::signing::generate_signature;\nuse chrono::Utc;\nuse futures_util::{SinkExt, StreamExt};\nuse serde_json::json;\nuse tokio::net::TcpStream;\nuse tokio_tungstenite::{connect_async, tungstenite::Message, MaybeTlsStream, WebSocketStream};\nuse tracing::{debug, error, info};\n\npub struct WsClient {\n    config: LighterConfig,\n    ws_stream: Option<WebSocketStream<MaybeTlsStream<TcpStream>>>,\n}\n\nimpl WsClient {\n    pub fn new(config: LighterConfig) -> Self {\n        Self {\n            config,\n            ws_stream: None,\n        }\n    }\n\n    pub async fn connect(&mut self) -> Result<(), LighterAdapterError> {\n        let url = format!(\"{}\", self.config.ws_base_url);\n        info!(\"Connecting to WebSocket: {}\", url);\n        \n        let (ws_stream, _) = connect_async(&url).await\n            .map_err(|e| LighterAdapterError::WebsocketError(e.to_string()))?;\n        \n        self.ws_stream = Some(ws_stream);\n        Ok(())\n    }\n\n    pub async fn authenticate(&mut self) -> Result<(), LighterAdapterError> {\n        if let Some(ref mut stream) = self.ws_stream {\n            let timestamp = Utc::now().timestamp_millis().to_string();\n            let payload = format!(\"{}{}\", timestamp, \"auth\");\n            let signature = generate_signature(&self.config.api_secret, &payload);\n\n            let auth_msg = json!({\n                \"method\": \"LOGIN\",\n                \"apiKey\": self.config.api_key,\n                \"timestamp\": timestamp,\n                \"signature\": signature,\n                \"chainId\": self.config.chain_id\n            });\n\n            stream.send(Message::Text(auth_msg.to_string())).await\n                .map_err(|e| LighterAdapterError::WebsocketError(e.to_string()))?;\n\n            debug!(\"Sent authentication message\");\n        }\n        Ok(())\n    }\n\n    pub async fn subscribe(&mut self, channel: &str, symbol: &str) -> Result<(), LighterAdapterError> {\n        if let Some(ref mut stream) = self.ws_stream {\n            let sub_msg = json!({\n                \"method\": \"SUBSCRIBE\",\n                \"params\": [format!(\"{}@{}\", symbol, channel)]\n            });\n\n            stream.send(Message::Text(sub_msg.to_string())).await\n                .map_err(|e| LighterAdapterError::WebsocketError(e.to_string()))?;\n            \n            info!(\"Subscribed to channel: {} for symbol: {}\", channel, symbol);\n        }\n        Ok(())\n    }\n\n    pub async fn next_message(&mut self) -> Result<String, LighterAdapterError> {\n        if let Some(ref mut stream) = self.ws_stream {\n            match stream.next().await {\n                Some(Ok(Message::Text(text))) => Ok(text),\n                Some(Ok(Message::Ping(data))) => {\n                    let _ = stream.send(Message::Pong(data)).await;\n                    Err(LighterAdapterError::WebsocketError(\"Received Ping\".to_string()))\n                },\n                Some(Ok(Message::Close(_))) => {\n                    Err(LighterAdapterError::WebsocketError(\"Connection closed\".to_string()))\n                }\n                Some(Err(e)) => Err(LighterAdapterError::WebsocketError(e.to_string())),\n                None => Err(LighterAdapterError::WebsocketError(\"Stream ended\".to_string())),\n                _ => Err(LighterAdapterError::WebsocketError(\"Unexpected message type\".to_string())),\n            }\n        } else {\n            Err(LighterAdapterError::WebsocketError(\"Not connected\".to_string()))\n        }\n    }\n}",
    "parsing/models.rs": "use nautilus_core::time::Timestamp;\nuse nautilus_model::data::{order::BookOrder, quote::QuoteTick, trade::TradeTick};\nuse nautilus_model::identifiers::{InstrumentId, TradeId};\nuse rust_decimal::Decimal;\n\n/// Represents a raw message from the WebSocket.\n#[derive(Debug, Clone, serde::Deserialize)]\npub struct WsMessage {\n    pub channel: Option<String>,\n    #[serde(rename = \"type\")]\n    pub msg_type: Option<String>,\n    pub data: Option<serde_json::Value>,\n}\n\nimpl WsMessage {\n    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {\n        serde_json::from_str(json)\n    }\n}\n\n/// Parses a ticker update.\npub fn parse_ticker(\n    instrument_id: &InstrumentId,\n    data: &serde_json::Value,\n    ts_event: Timestamp,\n) -> Result<QuoteTick, String> {\n    let bid_price = data[\"lastPrice\"].as_str().and_then(|s| s.parse::<Decimal>().ok())\n        .ok_or(\"Invalid lastPrice\")?;\n    let ask_price = bid_price;\n    let bid_size = data[\"volume\"].as_str().and_then(|s| s.parse::<Decimal>().ok())\n        .ok_or(\"Invalid volume\")?;\n    let ask_size = bid_size;\n\n    Ok(QuoteTick::new(\n        instrument_id.clone(),\n        bid_price,\n        ask_price,\n        bid_size,\n        ask_size,\n        ts_event,\n        ts_event,\n    ))\n}\n\n/// Parses orderbook snapshot updates.\npub fn parse_orderbook(\n    instrument_id: &InstrumentId,\n    data: &serde_json::Value,\n    ts_event: Timestamp,\n) -> Result<(Vec<BookOrder>, Vec<BookOrder>), String> {\n    let bids_data = data[\"bids\"].as_array().ok_or(\"Missing bids\")?;\n    let asks_data = data[\"asks\"].as_array().ok_or(\"Missing asks\")?;\n\n    let mut bids = Vec::new();\n    for level in bids_data {\n        if let Some(arr) = level.as_array() {\n            if arr.len() >= 2 {\n                let price = arr[0].as_str().and_then(|s| s.parse::<Decimal>().ok()).ok_or(\"Invalid bid price\")?;\n                let size = arr[1].as_str().and_then(|s| s.parse::<Decimal>().ok()).ok_or(\"Invalid bid size\")?;\n                bids.push(BookOrder::new(0, price, size, 0));\n            }\n        }\n    }\n\n    let mut asks = Vec::new();\n    for level in asks_data {\n        if let Some(arr) = level.as_array() {\n            if arr.len() >= 2 {\n                let price = arr[0].as_str().and_then(|s| s.parse::<Decimal>().ok()).ok_or(\"Invalid ask price\")?;\n                let size = arr[1].as_str().and_then(|s| s.parse::<Decimal>().ok()).ok_or(\"Invalid ask size\")?;\n                asks.push(BookOrder::new(1, price, size, 0));\n            }\n        }\n    }\n\n    Ok((bids, asks))\n}\n\n/// Parses a trade update.\npub fn parse_trade(\n    instrument_id: &InstrumentId,\n    data: &serde_json::Value,\n    ts_event: Timestamp,\n) -> Result<TradeTick, String> {\n    let price = data[\"price\"].as_str().and_then(|s| s.parse::<Decimal>().ok())\n        .ok_or(\"Invalid trade price\")?;\n    let size = data[\"quantity\"].as_str().and_then(|s| s.parse::<Decimal>().ok())\n        .ok_or(\"Invalid trade quantity\")?;\n    let agg_side = data[\"side\"].as_str().ok_or(\"Invalid trade side\")?;\n    let trade_id = data[\"id\"].as_str().unwrap_or(\"unknown\");\n\n    Ok(TradeTick::new(\n        instrument_id.clone(),\n        price,\n        size,\n        agg_side.to_uppercase(),\n        TradeId::new(trade_id),\n        ts_event,\n        ts_event,\n    ))\n}",
    "python/mod.rs": "use crate::config::LighterConfig;\nuse pyo3::prelude::*;\n\n/// Python wrapper for LighterConfig.\n#[pyclass(name = \"LighterConfig\")]\npub struct PyLighterConfig {\n    pub config: LighterConfig,\n}\n\n#[pymethods]\nimpl PyLighterConfig {\n    #[new]\n    #[pyo3(signature = (api_key, api_secret, chain_id, rest_base_url=\"https://api.lighter.xyz\".to_string(), ws_base_url=\"wss://api.lighter.xyz/ws\".to_string()))]\n    fn new(\n        api_key: String,\n        api_secret: String,\n        chain_id: u64,\n        rest_base_url: String,\n        ws_base_url: String,\n    ) -> Self {\n        Self {\n            config: LighterConfig {\n                api_key,\n                api_secret,\n                chain_id,\n                rest_base_url,\n                ws_base_url,\n            },\n        }\n    }\n\n    #[getter]\n    fn api_key(&self) -> String {\n        self.config.api_key.clone()\n    }\n\n    #[getter]\n    fn chain_id(&self) -> u64 {\n        self.config.chain_id\n    }\n}\n\n/// Exposes the adapter core logic to Python via PyO3.\n#[pymodule]\nfn lighter_adapter_core(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<PyLighterConfig>()?;\n    Ok(())\n}"
  }
}
```