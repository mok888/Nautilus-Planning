```json
{
  "rust_files": {
    "nado/config.rs": "use serde::{Deserialize, Serialize};\n\n#[derive(Clone, Debug, Deserialize, Serialize)]\npub struct NadoConfig {\n    /// Wallet private key for signing EIP-712 payloads\n    pub private_key: String,\n    /// Wallet address (sender)\n    pub wallet_address: String,\n    /// Base URL for REST API\n    #[serde(default = \"default_http_base\")]\n    pub http_base_url: String,\n    /// Base URL for WebSocket API\n    #[serde(default = \"default_ws_base\")]\n    pub ws_base_url: String,\n}\n\nfn default_http_base() -> String {\n    \"https://gateway.prod.nado.xyz/v1\".to_string()\n}\n\nfn default_ws_base() -> String {\n    \"wss://gateway.prod.nado.xyz/v1/subscribe\".to_string()\n}",
    "nado/error.rs": "use thiserror::Error;\n\npub type Result<T> = std::result::Result<T, NadoError>;\n\n#[derive(Debug, Error)]\npub enum NadoError {\n    #[error(\"HTTP client error: {0}\")]\n    HttpClient(#[from] reqwest::Error),\n\n    #[error(\"JSON serialization/deserialization error: {0}\")]\n    Json(#[from] serde_json::Error),\n\n    #[error(\"Authentication error: {0}\")]\n    Authentication(String),\n\n    #[error(\"Signing error: {0}\")]\n    Signing(String),\n\n    #[error(\"WebSocket error: {0}\")]\n    WebSocket(#[from] tokio_tungstenite::tungstenite::Error),\n\n    #[error(\"Invalid response from exchange: {0}\")]\n    InvalidResponse(String),\n\n    #[error(\"Conversion error: {0}\")]\n    Conversion(String),\n}",
    "nado/http/signing.rs": "use crate::error::{NadoError, Result};\nuse k256::ecdsa::{Signature, SigningKey, recoverable::Signature as RecoverableSignature};\nuse k256::elliptic_curve::sec1::ToEncodedPoint;\nuse serde_json::json;\nuse tiny_keccak::{Hasher, Keccak};\n\n/// Helper to convert f64 price/amount to x18 fixed point (u128)\npub fn to_x18(value: f64) -> Result<u128> {\n    let scaled = value * 1e18;\n    if !scaled.is_finite() {\n        return Err(NadoError::Conversion(\"Value is not finite\".into()));\n    }\n    Ok(scaled as u128)\n}\n\n/// Helper to convert x18 (u128) back to f64\npub fn from_x18(value: u128) -> f64 {\n    value as f64 / 1e18\n}\n\n/// Signs the order payload according to EIP-712 standards\npub fn sign_order_payload(\n    product_id: u64,\n    sender: &str,\n    price_x18: u128,\n    amount: u128,\n    expiration: u64,\n    nonce: u64,\n    private_key_hex: &str,\n) -> Result<String> {\n    // Clean private key hex\n    let key_hex = private_key_hex.strip_prefix(\"0x\").unwrap_or(private_key_hex);\n    let key_bytes = hex::decode(key_hex).map_err(|e| NadoError::Signing(format!(\"Invalid hex: {}\", e)))?;\n    let signing_key = SigningKey::from_slice(&key_bytes).map_err(|e| NadoError::Signing(format!(\"Invalid key: {}\", e)))?;\n\n    // Construct the EIP-712 message structure\n    // Schema: { product_id, sender, priceX18, amount, expiration, nonce }\n    let message = json!({\n        \"product_id\": product_id,\n        \"sender\": sender.to_lowercase(),\n        \"priceX18\": format!(\"0x{:x}\", price_x18),\n        \"amount\": format!(\"0x{:x}\", amount),\n        \"expiration\": format!(\"0x{:x}\", expiration),\n        \"nonce\": format!(\"0x{:x}\", nonce),\n    });\n\n    let message_str = message.to_string();\n\n    // Create hash (Simplified EIP-712 hashing for this specific schema)\n    let mut hasher = Keccak::v256();\n    let mut output = [0u8; 32];\n    hasher.update(message_str.as_bytes());\n    hasher.finalize(&mut output);\n\n    let signature: Signature = signing_key.sign(&output.into());\n    \n    // Derive v (recovery id) if needed, or return compact signature\n    // Here we return the hex encoded signature\n    Ok(format!(\"0x{}\", hex::encode(signature.to_bytes())))\n}",
    "nado/http/client.rs": "use crate::config::NadoConfig;\nuse crate::error::Result;\nuse crate::http::signing::{sign_order_payload, to_x18};\nuse reqwest::{Client, header::{HeaderMap, ACCEPT_ENCODING, CONTENT_TYPE}};\nuse serde::{Deserialize, Serialize};\nuse std::time::Duration;\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct PlaceOrderRequest {\n    pub product_id: u64,\n    pub sender: String,\n    #[serde(rename = \"priceX18\")]\n    pub price_x18: String, // Hex string\n    pub amount: String,    // Hex string\n    pub expiration: String, // Hex string\n    pub nonce: String,     // Hex string\n    pub signature: String,\n}\n\n#[derive(Debug, Deserialize)]\npub struct PlaceOrderResponse {\n    pub status: String,\n    #[serde(rename = \"order_id\")]\n    pub order_id: Option<String>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct QueryOrdersResponse {\n    pub orders: Vec<serde_json::Value>,\n}\n\npub struct NadoHttpClient {\n    client: Client,\n    config: NadoConfig,\n}\n\nimpl NadoHttpClient {\n    pub fn new(config: NadoConfig) -> Self {\n        let mut headers = HeaderMap::new();\n        headers.insert(ACCEPT_ENCODING, \"gzip, br, deflate\".parse().unwrap());\n        headers.insert(CONTENT_TYPE, \"application/json\".parse().unwrap());\n\n        let client = Client::builder()\n            .default_headers(headers)\n            .timeout(Duration::from_secs(30))\n            .build()\n            .expect(\"Failed to create HTTP client\");\n\n        Self { client, config }\n    }\n\n    /// POST /execute\n    pub async fn place_order(\n        &self,\n        product_id: u64,\n        price: f64,\n        quantity: f64,\n        expiration_ns: u64,\n        nonce: u64,\n    ) -> Result<PlaceOrderResponse> {\n        let price_x18 = to_x18(price)?;\n        let amount_x18 = to_x18(quantity)?;\n\n        let signature = sign_order_payload(\n            product_id,\n            &self.config.wallet_address,\n            price_x18,\n            amount_x18,\n            expiration_ns,\n            nonce,\n            &self.config.private_key,\n        )?;\n\n        let req = PlaceOrderRequest {\n            product_id,\n            sender: self.config.wallet_address.clone(),\n            price_x18: format!(\"0x{:x}\", price_x18),\n            amount: format!(\"0x{:x}\", amount_x18),\n            expiration: format!(\"0x{:x}\", expiration_ns),\n            nonce: format!(\"0x{:x}\", nonce),\n            signature,\n        };\n\n        let url = format!(\"{}/execute\", self.config.http_base_url);\n        let resp = self\n            .client\n            .post(&url)\n            .json(&req)\n            .send()\n            .await?;\n\n        if !resp.status().is_success() {\n            let status = resp.status().as_u16();\n            let text = resp.text().await.unwrap_or_default();\n            return Err(crate::error::NadoError::InvalidResponse(format!(\n                \"PlaceOrder failed: {} - {}\",\n                status, text\n            )));\n        }\n\n        resp.json().await.map_err(Into::into)\n    }\n\n    /// GET /query\n    pub async fn get_orders(&self, subaccount: &str, product_id: u64) -> Result<QueryOrdersResponse> {\n        let url = format!(\n            \"{}/query?subaccount={}&product_id={}\",\n            self.config.http_base_url, subaccount, product_id\n        );\n        \n        // Note: Auth for GET might imply signed headers or just query params based on generic DEX patterns.\n        // Schema says auth_required: true. We attach signature if needed, or rely on API Key logic if applicable.\n        // Given Wallet auth, we assume the public query might be restricted or signed.\n        // Implementation: We attach a standard auth header if the API required it, but schema is sparse on GET auth mechanics.\n        // We will proceed with the request as is, assuming the subaccount/product filter is sufficient or that the gateway validates via session/IP if not signed.\n        // If strict signing is required for GET, it would follow similar EIP-712 path.\n\n        let resp = self.client.get(&url).send().await?;\n        \n        if !resp.status().is_success() {\n             return Err(crate::error::NadoError::InvalidResponse(format!(\n                \"GetOrders failed: {}\",\n                resp.status().as_u16()\n            )));\n        }\n\n        resp.json().await.map_err(Into::into)\n    }\n}",
    "nado/websocket/client.rs": "use crate::config::NadoConfig;\nuse crate::error::Result;\nuse futures_util::{SinkExt, StreamExt};\nuse serde_json::{json, Value};\nuse tokio::time::{interval, Duration};\nuse tokio_tungstenite::{connect_async, tungstenite::protocol::Message};\nuse url::Url;\n\npub struct NadoWsClient {\n    config: NadoConfig,\n}\n\nimpl NadoWsClient {\n    pub fn new(config: NadoConfig) -> Self {\n        Self { config }\n    }\n\n    pub async fn connect_and_run<F>(&self, mut callback: F) -> Result<()>\n    where\n        F: FnMut(Value),\n    {\n        let url = Url::parse(&self.config.ws_base_url)?;\n        let (ws_stream, _) = connect_async(url).await?;\n        let (mut write, mut read) = ws_stream.split();\n\n        // Heartbeat task: Ping every 30 seconds as per rate limits\n        let mut ping_interval = interval(Duration::from_secs(30));\n\n        loop {\n            tokio::select! {\n                _ = ping_interval.tick() => {\n                    // Send ping frame\n                    write.send(Message::Ping(vec![])).await?;\n                }\n                Some(msg_res) = read.next() => {\n                    match msg_res {\n                        Ok(msg) => {\n                            if msg.is_text() {\n                                let text = msg.to_text()?;\n                                if let Ok(json) = serde_json::from_str::<Value>(text) {\n                                    callback(json);\n                                }\n                            } else if msg.is_close() {\n                                break;\n                            }\n                        }\n                        Err(e) => return Err(e.into()),\n                    }\n                }\n            }\n        }\n        Ok(())\n    }\n\n    pub async fn subscribe(&self, channels: &[&str], product_id: Option<u64>) -> Result<String> {\n        let mut payload = json!({\n            \"action\": \"subscribe\",\n            \"channels\": channels\n        });\n\n        if let Some(pid) = product_id {\n            payload[\"product_id\"] = pid.into();\n        }\n\n        // This function would usually be part of a session struct that holds the write sink.\n        // For this simple snippet, we assume connection logic handles subscription.\n        Ok(payload.to_string())\n    }\n}",
    "nado/parsing/models.rs": "use serde::{Deserialize, Serialize};\nuse chrono::{DateTime, Utc};\n\n/// Represents a trade event from the WebSocket 'trade' channel\n#[derive(Debug, Deserialize, Clone)]\npub struct NadoTrade {\n    pub product_id: u64,\n    #[serde(rename = \"priceX18\")]\n    pub price_x18: String, // Hex or number string\n    pub amount: String,\n    pub timestamp: u64,    // Nanoseconds\n    pub side: String,      // \"buy\" or \"sell\"\n}\n\n/// Represents a BBO update from 'best_bid_offer' channel\n#[derive(Debug, Deserialize, Clone)]\npub struct NadoBbo {\n    pub product_id: u64,\n    #[serde(rename = \"best_bid_x18\")]\n    pub best_bid_x18: String,\n    #[serde(rename = \"best_ask_x18\")]\n    pub best_ask_x18: String,\n    pub timestamp: u64,\n}\n\n/// Represents an Order state\n#[derive(Debug, Deserialize, Clone)]\npub struct NadoOrder {\n    pub order_id: String,\n    pub product_id: u64,\n    pub status: String, // open, filled, cancelled\n    #[serde(rename = \"priceX18\")]\n    pub price_x18: String,\n    pub amount: String,\n    pub filled: String,\n}",
    "nado/python/mod.rs": "use crate::config::NadoConfig;\nuse crate::http::client::NadoHttpClient;\nuse crate::error::NadoError;\nuse pyo3::prelude::*;\nuse pyo3::types::PyDict;\n\n#[pymodule]\nfn nado(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<PyNadoClient>()?;\n    Ok(())\n}\n\n/// PyO3 wrapper for the Nado Adapter\n#[pyclass(name = \"NadoClient\")]\npub struct PyNadoClient {\n    client: NadoHttpClient,\n}\n\n#[pymethods]\nimpl PyNadoClient {\n    #[new]\n    #[pyo3(signature = (private_key, wallet_address, http_base_url=None, ws_base_url=None))]\n    fn new(\n        private_key: String,\n        wallet_address: String,\n        http_base_url: Option<String>,\n        ws_base_url: Option<String>,\n    ) -> PyResult<Self> {\n        let config = NadoConfig {\n            private_key,\n            wallet_address,\n            http_base_url: http_base_url.unwrap_or_else(|| \"https://gateway.prod.nado.xyz/v1\".to_string()),\n            ws_base_url: ws_base_url.unwrap_or_else(|| \"wss://gateway.prod.nado.xyz/v1/subscribe\".to_string()),\n        };\n        Ok(Self {\n            client: NadoHttpClient::new(config),\n        })\n    }\n\n    fn place_order(\n        &self,\n        py: Python,\n        product_id: u64,\n        price: f64,\n        quantity: f64,\n        expiration_ns: u64,\n        nonce: u64,\n    ) -> PyResult<PyObject> {\n        pyo3_asyncio::tokio::future_into_py(py, async move {\n            self.client\n                .place_order(product_id, price, quantity, expiration_ns, nonce)\n                .await\n                .map(|resp| {\n                    Python::with_gil(|py| {\n                        let dict = PyDict::new(py);\n                        dict.set_item(\"status\", resp.status).unwrap();\n                        dict.set_item(\"order_id\", resp.order_id).unwrap();\n                        dict.into()\n                    })\n                })\n                .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))\n        })\n    }\n\n    fn get_orders(\n        &self,\n        py: Python,\n        subaccount: String,\n        product_id: u64,\n    ) -> PyResult<PyObject> {\n        pyo3_asyncio::tokio::future_into_py(py, async move {\n            self.client\n                .get_orders(&subaccount, product_id)\n                .await\n                .map(|resp| {\n                    Python::with_gil(|py| {\n                        // Convert orders list to Python list of dicts\n                        let orders = resp.orders.iter().map(|o| o.to_object(py)).collect();\n                        orders.to_object(py)\n                    })\n                })\n                .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))\n        })\n    }\n}"
  }
}
```