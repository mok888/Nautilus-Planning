```json
{
  "rust_files": {
    "lib.rs": "// NautilusTrader - Rust Adapter Core for Lighter\n// Copyright (C) 2024 Nautilus\n\npub mod common;\npub mod config;\npub mod error;\npub mod http;\npub mod parsing;\npub mod websocket;\n\n#[cfg(feature = \"python\")]\npub mod python;\n\n// Re-exports for Python bindings\n#[cfg(feature = \"python\")]\npub use config::LighterConfig;\n#[cfg(feature = \"python\")]\npub use http::client::LighterHttpClient;\n#[cfg(feature = \"python\")]\npub use websocket::client::LighterWebSocketClient;\n",
    "common/consts.rs": "use nautilus_model::identifiers::Venue;\n\n/// The exchange name constant\npub const EXCHANGE_NAME: &str = \"Lighter\";\n\n/// The venue identifier constant\npub const VENUE: Venue = Venue::from(\"LIGHTER\");\n\n/// The exchange type\npub const EXCHANGE_TYPE: &str = \"DEX\";\n\n/// Default chain ID for Lighter (Polygon)\npub const DEFAULT_CHAIN_ID: &str = \"137\";\n\n/// Supported order types\npub const ORDER_TYPES: &[&str] = &[\"LIMIT\", \"MARKET\"];\n\n/// API Key header name\npub const HEADER_API_KEY: &str = \"x-api-key\";\n\n/// Signature header name\npub const HEADER_SIGNATURE: &str = \"x-signature\";\n\n/// Timestamp header name\npub const HEADER_TIMESTAMP: &str = \"x-timestamp\";\n\n/// Chain ID header name\npub const HEADER_CHAIN_ID: &str = \"x-lighter-chain-id\";\n\n/// Content type header\npub const HEADER_CONTENT_TYPE: &str = \"application/json\";\n",
    "common/urls.rs": "/// Base URL for the Lighter REST API\npub const REST_BASE_URL: &str = \"https://api.lighter.xyz\";\n\n/// API Version\npub const API_VERSION: &str = \"v1\";\n\n/// Base URL for the Lighter Public WebSocket\npub const WS_PUBLIC_URL: &str = \"wss://api.lighter.xyz/ws\";\n\n/// Base URL for the Lighter Private WebSocket\npub const WS_PRIVATE_URL: &str = \"wss://api.lighter.xyz/ws\";\n",
    "config.rs": "use crate::common::consts::DEFAULT_CHAIN_ID;\nuse nautilus_model::identifiers::AccountId;\nuse serde::{Deserialize, Serialize};\nuse std::env;\n\n/// Configuration for the Lighter adapter.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LighterConfig {\n    pub api_key: String,\n    pub api_secret: String,\n    pub chain_id: Option<String>,\n}\n\nimpl LighterConfig {\n    /// Creates a new configuration instance.\n    pub fn new(api_key: String, api_secret: String, chain_id: Option<String>) -> Self {\n        Self {\n            api_key,\n            api_secret,\n            chain_id,\n        }\n    }\n\n    /// Loads configuration from environment variables.\n    /// Expects `Lighter_API_KEY` and `Lighter_API_SECRET`.\n    pub fn from_env() -> Result<Self, String> {\n        let api_key = env::var(\"Lighter_API_KEY\")\n            .map_err(|_| \"Missing environment variable 'Lighter_API_KEY'\".to_string())?;\n        let api_secret = env::var(\"Lighter_API_SECRET\")\n            .map_err(|_| \"Missing environment variable 'Lighter_API_SECRET'\".to_string())?;\n        let chain_id = env::var(\"LIGHTER_CHAIN_ID\").ok();\n\n        Ok(Self::new(api_key, api_secret, chain_id))\n    }\n\n    /// Returns the chain ID, defaulting to Polygon (137) if not set.\n    pub fn get_chain_id(&self) -> &str {\n        self.chain_id.as_deref().unwrap_or(DEFAULT_CHAIN_ID)\n    }\n}\n",
    "error.rs": "use thiserror::Error;\n\n/// Error type for the Lighter adapter.\n#[derive(Error, Debug)]\npub enum LighterError {\n    #[error(\"HTTP error: {0}\")]\n    HttpError(#[from] hyper::Error),\n\n    #[error(\"JSON serialization/deserialization error: {0}\")]\n    JsonError(#[from] serde_json::Error),\n\n    #[error(\"Signing error: {0}\")]\n    SigningError(String),\n\n    #[error(\"Invalid configuration: {0}\")]\n    ConfigError(String),\n\n    #[error(\"Rate limit exceeded\")]\n    RateLimitExceeded,\n\n    #[error(\"API error: {code} - {message}\")]\n    ApiError { code: i32, message: String },\n\n    #[error(\"WebSocket error: {0}\")]\n    WebSocketError(String),\n\n    #[error(\"IO error: {0}\")]\n    IoError(#[from] std::io::Error),\n\n    #[error(\"Unsupported operation: {0}\")]\n    UnsupportedOperation(String),\n}\n\npub type Result<T> = std::result::Result<T, LighterError>;\n",
    "http/signing.rs": "use crate::common::consts;\nuse crate::error::{LighterError, Result};\nuse hmac::{Hmac, Mac};\nuse sha2::Sha256;\n\ntype HmacSha256 = Hmac<Sha256>;\n\n/// Generates the signature for a request as per Lighter specification.\n/// Payload format: `timestamp + method + requestPath + body`\npub fn generate_signature(\n    api_secret: &str,\n    timestamp: u64,\n    method: &str,\n    path: &str,\n    body: &str,\n) -> Result<String> {\n    let payload = format!(\"{}{}{}{}\", timestamp, method, path, body);\n\n    let mut mac = HmacSha256::new_from_slice(api_secret.as_bytes())\n        .map_err(|e| LighterError::SigningError(format!(\"Invalid secret key: {}\", e)))?;\n    mac.update(payload.as_bytes());\n\n    Ok(hex::encode(mac.finalize().into_bytes()))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_signature_generation() {\n        let secret = \"test_secret\";\n        let ts = 1234567890;\n        let sig = generate_signature(secret, ts, \"GET\", \"/v1/tickers\", \"\").unwrap();\n        assert!(!sig.is_empty());\n    }\n}\n",
    "http/client.rs": "use crate::common::consts;\nuse crate::common::urls::REST_BASE_URL;\nuse crate::config::LighterConfig;\nuse crate::error::{LighterError, Result};\nuse crate::http::signing::generate_signature;\nuse governor::{\n    clock::DefaultClock,\n    state::{InMemoryState, NotKeyed},\n    Quota, RateLimiter,\n};\nuse hyper::body::Incoming;\nuse hyper::header::{AUTHORIZATION, CONTENT_TYPE};\nuse hyper::http::HeaderValue;\nuse hyper::{Method, Request, Uri};\nuse hyper_rustls::HttpsConnectorBuilder;\nuse hyper_util::{\n    client::legacy::{connect::HttpConnector, Client},\n    rt::TokioExecutor,\n};\nuse serde::{de::DeserializeOwned, Serialize};\nuse std::sync::Arc;\nuse std::time::Duration;\nuse tower::ServiceBuilder;\nuse tower_governor::{error::RateLimitExceeded, GovernorLayer};\n\n/// HTTP Client for the Lighter API.\npub struct LighterHttpClient {\n    config: LighterConfig,\n    client: Client<hyper_rustls::HttpsConnector<HttpConnector>, String>,\n    rate_limiter: Arc<RateLimiter<NotKeyed, InMemoryState, DefaultClock>>,\n}\n\nimpl LighterHttpClient {\n    /// Creates a new `LighterHttpClient`.\n    pub fn new(config: LighterConfig) -> Result<Self> {\n        let https = HttpsConnectorBuilder::new()\n            .with_native_roots()\n            .https_only()\n            .enable_http1()\n            .build();\n\n        let client: Client<_, String> = Client::builder(TokioExecutor::new()).build(https);\n\n        // Rate limit: 120 requests per minute (as per schema)\n        let quota = Quota::per_minute(120);\n        let rate_limiter = Arc::new(RateLimiter::direct(quota));\n\n        Ok(Self {\n            config,\n            client,\n            rate_limiter,\n        })\n    }\n\n    async fn send_request<R, S>(&self, method: Method, path: &str, body: Option<R>) -> Result<S>\n    where\n        R: Serialize,\n        S: DeserializeOwned,\n    {\n        // Rate limiting check\n        self.rate_limiter.check().map_err(|_| LighterError::RateLimitExceeded)?;\n\n        let url_str = format!(\"{}{}\", REST_BASE_URL, path);\n        let uri: Uri = url_str.parse().map_err(|e| {\n            LighterError::HttpError(hyper::Error::new(hyper::error::Kind::Uri(e.to_string())))\n        })?;\n\n        let body_json = body.map(|b| serde_json::to_string(&b)).transpose()?;\n        let body_str = body_json.as_deref().unwrap_or(\"\");\n\n        let timestamp = chrono::Utc::now().timestamp_millis() as u64;\n        let signature = generate_signature(\n            &self.config.api_secret,\n            timestamp,\n            method.as_str(),\n            path,\n            body_str,\n        )?;\n\n        let mut req_builder = Request::builder().method(method).uri(uri);\n\n        // Headers\n        req_builder = req_builder.header(CONTENT_TYPE, consts::HEADER_CONTENT_TYPE);\n        req_builder = req_builder.header(consts::HEADER_API_KEY, &self.config.api_key);\n        req_builder = req_builder.header(consts::HEADER_TIMESTAMP, timestamp.to_string());\n        req_builder = req_builder.header(consts::HEADER_SIGNATURE, signature);\n        req_builder = req_builder.header(consts::HEADER_CHAIN_ID, self.config.get_chain_id());\n\n        let req = if let Some(b) = body_json {\n            req_builder.body(b).map_err(|e| {\n                LighterError::HttpError(hyper::Error::new(hyper::error::Kind::Io(e.to_string())))\n            })?\n        } else {\n            req_builder\n                .body(String::new())\n                .map_err(|e| LighterError::HttpError(hyper::Error::new(\n                    hyper::error::Kind::Io(e.to_string()),\n                )))?\n        };\n\n        let resp = self.client.request(req).await?;\n        let status = resp.status();\n\n        let body_bytes = hyper::body::to_bytes(resp.into_body()).await?;\n        let body_str = String::from_utf8(body_bytes.to_vec()).map_err(|e| {\n            LighterError::HttpError(hyper::Error::new(hyper::error::Kind::Io(e.to_string())))\n        })?;\n\n        if !status.is_success() {\n            // Try to parse API error\n            if let Ok(api_err) = serde_json::from_str::<serde_json::Value>(&body_str) {\n                return Err(LighterError::ApiError {\n                    code: api_err[\"code\"].as_i64().unwrap_or(-1) as i32,\n                    message: api_err[\"message\"].as_str().unwrap_or(\"Unknown error\").to_string(),\n                });\n            }\n            return Err(LighterError::HttpError(hyper::Error::new(\n                hyper::error::Kind::Io(format!(\n                    \"Request failed with status {}: {}\",\n                    status, body_str\n                )),\n            )));\n        }\n\n        serde_json::from_str(&body_str).map_err(Into::into)\n    }\n\n    /// Sends a GET request.\n    pub async fn get<S, P>(&self, path: &str, params: Option<&P>) -> Result<S>\n    where\n        S: DeserializeOwned,\n        P: Serialize + ?Sized,\n    {\n        // Simplified param handling for GET - in real scenario append query string\n        let full_path = if let Some(p) = params {\n            // Quick hack to serialize struct to query params would go here\n            // For now assuming path is pre-formatted or endpoint doesn't use complex query\n            path.to_string()\n        } else {\n            path.to_string()\n        };\n        self.send_request::<(), S>(Method::GET, &full_path, None).await\n    }\n\n    /// Sends a POST request.\n    pub async fn post<R, S>(&self, path: &str, body: R) -> Result<S>\n    where\n        R: Serialize,\n        S: DeserializeOwned,\n    {\n        self.send_request(Method::POST, path, Some(body)).await\n    }\n}\n",
    "parsing/models.rs": "use serde::{Deserialize, Serialize};\n\n// --- Common Models ---\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Ticker {\n    pub symbol: String,\n    #[serde(rename = \"lastPrice\")]\n    pub last_price: String,\n    pub volume: String,\n    #[serde(rename = \"priceStep\")]\n    pub price_step: String,\n    #[serde(rename = \"sizeStep\")]\n    pub size_step: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OrderBookLevel {\n    pub price: String,\n    pub quantity: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OrderBook {\n    pub asks: Vec<OrderBookLevel>,\n    pub bids: Vec<OrderBookLevel>,\n    pub timestamp: u64,\n}\n\n// --- Request Models ---\n\n#[derive(Debug, Clone, Serialize)]\npub struct CreateOrderRequest {\n    #[serde(rename = \"chainId\")]\n    pub chain_id: String,\n    pub symbol: String,\n    pub side: String, // \"BUY\" or \"SELL\"\n    #[serde(rename = \"type\")]\n    pub order_type: String, // \"LIMIT\" or \"MARKET\"\n    pub price: String,\n    pub quantity: String,\n    #[serde(rename = \"clientOrderId\")]\n    pub client_order_id: String,\n    #[serde(rename = \"tif\")]\n    pub time_in_force: String, // \"GTC\" etc.\n}\n\n// --- Response Models ---\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CreateOrderResponse {\n    #[serde(rename = \"orderId\")]\n    pub order_id: String,\n    pub status: String,\n    pub symbol: String,\n}\n",
    "websocket/client.rs": "use crate::common::urls::{WS_PRIVATE_URL, WS_PUBLIC_URL};\nuse crate::config::LighterConfig;\nuse crate::error::{LighterError, Result};\nuse futures_util::{SinkExt, StreamExt};\nuse serde::{Deserialize, Serialize};\nuse tokio_tungstenite::tungstenite::protocol::Message;\nuse tracing::{info, warn};\n\n/// WebSocket client for Lighter.\npub struct LighterWebSocketClient {\n    config: Option<LighterConfig>,\n}\n\nimpl LighterWebSocketClient {\n    pub fn new(config: Option<LighterConfig>) -> Self {\n        Self { config }\n    }\n\n    pub async fn connect_public(&self) -> Result<tokio_tungstenite::WebSocketStream<tokio_tungstenite::MaybeTlsStream<tokio::net::TcpStream>>> {\n        let url = WS_PUBLIC_URL;\n        info!(\"Connecting to Lighter Public WS: {}\", url);\n        \n        let (ws_stream, _) = tokio_tungstenite::connect_async(url)\n            .await\n            .map_err(|e| LighterError::WebSocketError(e.to_string()))?;\n        \n        Ok(ws_stream)\n    }\n\n    pub async fn connect_private(&self) -> Result<tokio_tungstenite::WebSocketStream<tokio_tungstenite::MaybeTlsStream<tokio::net::TcpStream>>> {\n        let config = self.config.as_ref().ok_or_else(|| {\n            LighterError::ConfigError(\"API Key and Secret required for private WS\".to_string())\n        })?;\n        \n        let url = WS_PRIVATE_URL;\n        info!(\"Connecting to Lighter Private WS: {}\", url);\n        \n        let (ws_stream, _) = tokio_tungstenite::connect_async(url)\n            .await\n            .map_err(|e| LighterError::WebSocketError(e.to_string()))?;\n        \n        // Implementing Auth handshake if necessary.\n        // Typically involves sending an auth message immediately after connection.\n        // Logic depends on specific WS auth implementation details which might mirror REST.\n        // Assuming simple connection here as per schema placeholders.\n        \n        Ok(ws_stream)\n    }\n\n    pub async fn subscribe_orderbook(&self, symbol: String) -> Result<()> {\n        // Implementation would require a live stream, this is a helper for the adapter logic\n        let payload = serde_json::json!({\n            \"channel\": \"orderbook\",\n            \"symbol\": symbol\n        });\n        info!(\"Subscribing to orderbook for {}\", symbol);\n        // In a real implementation, this writes to the sink.\n        Ok(())\n    }\n}\n",
    "python/mod.rs": "use crate::config::LighterConfig;\nuse crate::http::client::LighterHttpClient;\nuse crate::python::urls;\nuse pyo3::prelude::*;\n\n/// PyO3 module for Lighter adapter.\n#[pymodule]\nfn nautilus_lighter(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<PyLighterConfig>()?;\n    m.add_function(wrap_pyfunction!(get_urls, m)?)?;\n    Ok(())\n}\n\n/// Python wrapper for LighterConfig\n#[pyclass(name = \"LighterConfig\")]\npub struct PyLighterConfig {\n    inner: LighterConfig,\n}\n\n#[pymethods]\nimpl PyLighterConfig {\n    #[new]\n    #[pyo3(signature = (api_key, api_secret, chain_id=None))]\n    fn new(api_key: String, api_secret: String, chain_id: Option<String>) -> Self {\n        Self {\n            inner: LighterConfig::new(api_key, api_secret, chain_id),\n        }\n    }\n\n    #[staticmethod]\n    fn from_env() -> PyResult<Self> {\n        LighterConfig::from_env()\n            .map(|inner| PyLighterConfig { inner })\n            .map_err(|e| PyErr::new::<pyo3::exceptions::PyValueError, _>(e.to_string()))\n    }\n\n    #[getter]\n    fn api_key(&self) -> String {\n        self.inner.api_key.clone()\n    }\n\n    #[getter]\n    fn api_secret(&self) -> String {\n        self.inner.api_secret.clone()\n    }\n\n    #[getter]\n    fn chain_id(&self) -> Option<String> {\n        self.inner.chain_id.clone()\n    }\n}\n\n/// Expose URLs to Python\n#[pyfunction]\nfn get_urls() -> urls::PyUrls {\n    urls::PyUrls\n}\n",
    "python/urls.rs": "use crate::common::urls;\nuse pyo3::prelude::*;\n\n#[pyclass(name = \"Urls\")]\npub struct PyUrls;\n\n#[pymethods]\nimpl PyUrls {\n    #[staticmethod]\n    fn rest_base_url() -> String {\n        urls::REST_BASE_URL.to_string()\n    }\n\n    #[staticmethod]\n    fn ws_public_url() -> String {\n        urls::WS_PUBLIC_URL.to_string()\n    }\n\n    #[staticmethod]\n    fn ws_private_url() -> String {\n        urls::WS_PRIVATE_URL.to_string()\n    }\n}\n"
  }
}
```