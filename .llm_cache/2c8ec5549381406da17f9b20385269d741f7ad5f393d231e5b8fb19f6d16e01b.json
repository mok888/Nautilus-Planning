```json
{
  "python_files": {
    "config.py": "# --------------------------------------------------------------------------------------------------\n#  LIGHTER CONFIGURATION\n# --------------------------------------------------------------------------------------------------\n\nfrom nautilus_trader.config import LiveDataClientConfig, ExecClientConfig\nfrom nautilus_trader.core.correctness import PyCondition\n\n\nclass LighterConfig(LiveDataClientConfig, ExecClientConfig):\n    \"\"\"\n    Configuration for the Lighter exchange adapter.\n    \"\"\"\n\n    def __init__(\n        self,\n        api_key: str,\n        api_secret: str,  # Typically the private key for wallet operations\n        account_index: int,\n        api_key_index: int,\n        base_url_http: str = \"https://mainnet.zklighter.elliot.ai\",\n        base_url_ws: str = \"wss://mainnet.zklighter.elliot.ai/stream\",\n        use_readonly_ws: bool = False,\n        **kwargs,\n    ):\n        super().__init__(**kwargs)\n        self.api_key = api_key\n        self.api_secret = api_secret\n        self.account_index = account_index\n        self.api_key_index = api_key_index\n        self.base_url_http = base_url_http\n        self.base_url_ws = base_url_ws\n        self.use_readonly_ws = use_readonly_ws\n\n    @property\n    def venue(self) -> str:\n        return \"LIGHTER\"\n",
    "constants.py": "# --------------------------------------------------------------------------------------------------\n#  LIGHTER CONSTANTS\n# --------------------------------------------------------------------------------------------------\n\nfrom nautilus_trader.model.identifiers import Venue\n\nVENUE = Venue(\"LIGHTER\")\n\n# REST API\nBASE_URL_HTTP = \"https://mainnet.zklighter.elliot.ai\"\nAPI_VERSION = \"v1\"\n\n# WebSocket API\nBASE_URL_WS = \"wss://mainnet.zklighter.elliot.ai/stream\"\n\n# Authentication\nAUTH_TYPE = \"WALLET\"\nHASH_ALGO = \"Poseidon2\"  # Non-standard, specific to ZK light client\nENCODING = \"Schnorr\"\nTIMESTAMP_FORMAT = \"milliseconds\"\n\n# Order States Mapping\nSTATE_IN_PROGRESS = \"in_progress\"\nSTATE_PENDING = \"pending\"\nSTATE_ACTIVE_LIMIT = \"active_limit\"\nSTATE_FILLED = \"filled\"\nSTATE_CANCELLED = \"cancelled\"\n\n# WebSocket Channels\nWS_CHANNEL_ORDERBOOK = \"order_book\"\nWS_CHANNEL_TRADES = \"trade\"\nWS_CHANNEL_MARKET_STATS = \"market_stats\"\nWS_CHANNEL_SPOT_STATS = \"spot_market_stats\"\n",
    "data.py": "# --------------------------------------------------------------------------------------------------\n#  LIGHTER DATA CLIENT\n# --------------------------------------------------------------------------------------------------\n\nimport asyncio\nfrom typing import Optional\n\nfrom nautilus_trader.adapters.http.client import AsyncHttpClient\nfrom nautilus_trader.core.data import Data\nfrom nautilus_trader.core.uuid import UUID4\nfrom nautilus_trader.live.data_client import LiveDataClient\nfrom nautilus_trader.model.data import OrderBookDeltas, TradeTick\nfrom nautilus_trader.model.identifiers import InstrumentId\nfrom nautilus_trader.model.instruments import Instrument\nfrom nautilus_trader.model.orders import Order\n\nfrom .config import LighterConfig\nfrom .constants import BASE_URL_HTTP, VENUE\n\n\nclass LighterDataClient(LiveDataClient):\n    \"\"\"\n    Provides access to Lighter market data.\n    \"\"\"\n\n    def __init__(self, config: LighterConfig, loop: Optional[asyncio.AbstractEventLoop] = None):\n        super().__init__(loop=loop)\n        self._config = config\n        self._http_client: Optional[AsyncHttpClient] = None\n        self._is_connected = False\n        self._instrument_provider = LighterInstrumentProvider(client=self)\n\n    @property\n    def venue(self) -> str:\n        return \"LIGHTER\"\n\n    @property\n    def is_connected(self) -> bool:\n        return self._is_connected\n\n    async def _connect(self) -> None:\n        if self._is_connected:\n            return\n        \n        self._http_client = AsyncHttpClient(\n            base_url=self._config.base_url_http,\n            loop=self._loop,\n        )\n        \n        # Initial fetch of instruments\n        await self._instrument_provider.load_all()\n        self._is_connected = True\n        self._log.info(f\"Connected to Lighter Data API ({self._config.base_url_http}).\")\n\n    async def _disconnect(self) -> None:\n        if not self._is_connected:\n            return\n        \n        if self._http_client:\n            await self._http_client.disconnect()\n        self._is_connected = False\n        self._log.info(\"Disconnected from Lighter Data API.\")\n\n    def _subscribe_instruments(self) -> None:\n        # Instruments are loaded via REST, not a WS subscription channel usually\n        pass\n\n    async def _subscribe_order_book_deltas(self, instrument_id: InstrumentId) -> None:\n        # Implementation requires WebSocket connection to handle order_book/{MARKET_INDEX}\n        self._log.warning(f\"Order book deltas subscription for {instrument_id} not fully implemented.\")\n\n    async def _subscribe_trade_ticks(self, instrument_id: InstrumentId) -> None:\n        # Implementation requires WebSocket connection to handle trade/{MARKET_INDEX}\n        self._log.warning(f\"Trade ticks subscription for {instrument_id} not fully implemented.\")\n\n    # HTTP Query Methods\n    async def query_order_book(self, instrument_id: InstrumentId, limit: int = 100):\n        \"\"\"\n        Query the REST API for current order book snapshot.\n        Endpoint: /api/v1/orderBookOrders\n        \"\"\"\n        await self._check_connected()\n        market_index = self._extract_market_index(instrument_id)\n        \n        params = {\"market_id\": market_index, \"limit\": limit}\n        response = await self._http_client.get(f\"/api/v{self._config.api_version}/orderBookOrders\", params=params)\n        return response\n\n    def _extract_market_index(self, instrument_id: InstrumentId) -> str:\n        # Lighter uses integer market_index. Assuming symbol format is {index}.LIGHTER\n        symbol_str = instrument_id.symbol.value\n        try:\n            # Attempt to parse integer\n            return str(int(symbol_str))\n        except ValueError:\n            self._log.error(f\"Could not parse market index from instrument_id: {instrument_id}\")\n            return \"0\"\n\n    async def _check_connected(self) -> None:\n        if not self._is_connected:\n            await self._connect()\n\n\nclass LighterInstrumentProvider:\n    \"\"\"\n    Instrument provider for Lighter.\n    Fetches metadata from /api/v1/orderBookDetails to determine precision.\n    \"\"\"\n\n    def __init__(self, client: LighterDataClient):\n        self._client = client\n        self._instruments: dict[str, Instrument] = {}\n\n    async def load_all(self) -> None:\n        # Lighter does not seem to have a \"GetAllInstruments\" endpoint in the provided schema.\n        # We assume the user must specify markets or we have a known list.\n        # Placeholder for logic that would iterate known market IDs and call orderBookDetails.\n        self._client._log.info(\"Instrument loading requires specific market IDs for Lighter.\")\n        pass\n",
    "execution.py": "# --------------------------------------------------------------------------------------------------\n#  LIGHTER EXECUTION CLIENT\n# --------------------------------------------------------------------------------------------------\n\nimport asyncio\nfrom typing import Optional\n\nfrom nautilus_trader.adapters.http.client import AsyncHttpClient\nfrom nautilus_trader.core.correctness import PyCondition\nfrom nautilus_trader.core.message import Event\nfrom nautilus_trader.execution.client import ExecutionClient\nfrom nautilus_trader.execution.messages import SubmitOrder, CancelOrder, ModifyOrder\nfrom nautilus_trader.model.enums import OrderSide, OrderStatus\nfrom nautilus_trader.model.identifiers import AccountId, ClientOrderId, InstrumentId, StrategyId, VenueOrderId\nfrom nautilus_trader.model.orders import MarketOrder, LimitOrder\n\nfrom .config import LighterConfig\nfrom .constants import (\n    BASE_URL_HTTP,\n    STATE_FILLED,\n    STATE_CANCELLED,\n    STATE_ACTIVE_LIMIT,\n    STATE_IN_PROGRESS,\n)\n\n\nclass LighterExecutionClient(ExecutionClient):\n    \"\"\"\n    Provides the execution client functionality for Lighter DEX.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: LighterConfig,\n        loop: Optional[asyncio.AbstractEventLoop] = None,\n    ):\n        super().__init__(loop=loop)\n        self._config = config\n        self._http_client: Optional[AsyncHttpClient] = None\n        self._account_id = AccountId(f\"{config.account_index}-{config.api_key_index}\")\n        \n        # Cache for generating order_index or tracking client_order_index\n        self._pending_orders: dict[ClientOrderId, SubmitOrder] = {}\n\n    @property\n    def venue(self) -> str:\n        return \"LIGHTER\"\n\n    @property\n    def account_id(self) -> AccountId:\n        return self._account_id\n\n    async def _connect(self) -> None:\n        self._log.info(f\"Connecting to Lighter Execution API...\")\n        \n        self._http_client = AsyncHttpClient(\n            base_url=self._config.base_url_http,\n            loop=self._loop,\n            headers={\"auth\": self._generate_auth_token()}  # Simplified header logic\n        )\n        \n        # Perform a health check or account check to verify credentials\n        await self._check_account()\n        \n        self._set_connected(True)\n        self._log.info(\"Connected to Lighter Execution API.\")\n\n    async def _disconnect(self) -> None:\n        if self._http_client:\n            await self._http_client.disconnect()\n        self._set_connected(False)\n        self._log.info(\"Disconnected from Lighter Execution API.\")\n\n    async def _check_account(self) -> None:\n        # GET /api/v1/account\n        # We don't strictly need this to execute, but good for auth check.\n        # However, GetAccount requires 'by' and 'value'. We might skip this or default to account_index.\n        pass\n\n    def generate_order_id(self, strategy_id: StrategyId) -> ClientOrderId:\n        # Lighter uses `client_order_index` (uint48). \n        # Nautilus ClientOrderId is a string. We'll generate a unique string representation.\n        return ClientOrderId(str(UUID4()))\n\n    async def submit_order(self, command: SubmitOrder) -> None:\n        PyCondition.true(self.is_connected, \"not connected\")\n        \n        order = command.order\n        self._pending_orders[order.client_order_id] = command\n        \n        self._log.info(f\"Submitting order {order.client_order_id}...\")\n        \n        transaction = self._build_transaction(order)\n        signature = self._sign_transaction(transaction)\n        \n        payload = {\n            \"transaction\": transaction,\n            \"signature\": signature\n        }\n        \n        try:\n            # Endpoint: /api/v1/sendTx\n            response = await self._http_client.post(\n                f\"/api/v1/sendTx\",\n                json=payload\n            )\n            \n            # Lighter returns 200 OK even if syntax is just correct.\n            # We must wait for WebSocket confirmation for real status.\n            # For now, assume SUBMITTED.\n            self._generate_order_submitted(\n                strategy_id=command.strategy_id,\n                instrument_id=order.instrument_id,\n                client_order_id=order.client_order_id,\n                ts_event=self._clock.timestamp_ns(),\n            )\n            \n        except Exception as e:\n            self._log.error(f\"Failed to submit order: {e}\")\n            self._generate_order_rejected(\n                strategy_id=command.strategy_id,\n                instrument_id=order.instrument_id,\n                client_order_id=order.client_order_id,\n                reason=str(e),\n                ts_event=self._clock.timestamp_ns(),\n            )\n\n    async def cancel_order(self, command: CancelOrder) -> None:\n        PyCondition.true(self.is_connected, \"not connected\")\n        \n        # To cancel, Lighter requires a transaction. \n        # The transaction type would be 'CancelOrder' containing the `order_index` or `client_order_index`.\n        \n        cancel_tx = self._build_cancel_transaction(command.client_order_id)\n        signature = self._sign_transaction(cancel_tx)\n        \n        payload = {\n            \"transaction\": cancel_tx,\n            \"signature\": signature\n        }\n        \n        try:\n            await self._http_client.post(\n                f\"/api/v1/sendTx\",\n                json=payload\n            )\n            # Optimistic update: Nautilus usually waits for exchange confirmation\n            self._log.info(f\"Cancel transaction sent for {command.client_order_id}\")\n        except Exception as e:\n            self._log.error(f\"Failed to cancel order: {e}\")\n\n    async def modify_order(self, command: ModifyOrder) -> None:\n        # Lighter might not support 'Modify' directly. \n        # Often DEXs require Cancel + New.\n        # Research data lists order types but not explicit modify behavior.\n        # Assuming Cancel + Submit logic is handled by Nautilus core or not supported directly via single API call.\n        raise NotImplementedError(\"Order modification not directly supported by Lighter adapter.\")\n\n    async def _account_snapshot(self) -> None:\n        # GET /api/v1/account\n        # Fetch positions and balances\n        params = {\n            \"by\": \"account_index\",\n            \"value\": self._config.account_index\n        }\n        \n        try:\n            response = await self._http_client.get(\"/api/v1/account\", params=params)\n            self._parse_account_state(response)\n        except Exception as e:\n            self._log.error(f\"Failed to fetch account snapshot: {e}\")\n\n    def _build_transaction(self, order: Order) -> dict:\n        \"\"\"\n        Constructs the Lighter transaction object.\n        Note: Actual structure depends on Lighter's SDK specifications.\n        This is a structural placeholder based on standard DEX patterns.\n        \"\"\"\n        market_index = int(order.instrument_id.symbol.value)\n        \n        tx = {\n            \"type\": \"PlaceOrder\", # Hypothetical type\n            \"market_index\": market_index,\n            \"client_order_index\": int(order.client_order_id.value, 16), # Convert UUID string to int representation\n            \"is_bid\": order.side == OrderSide.BUY,\n            \"limit_price\": str(order.price) if order.price else \"0\", # Price required for Limit, optional/zero for Market\n            \"base_amount\": str(order.quantity),\n            \"reduce_only\": False, # Example param\n            # ... other fields required by Lighter specific transaction schema\n        }\n        return tx\n\n    def _build_cancel_transaction(self, client_order_id: ClientOrderId) -> dict:\n        tx = {\n            \"type\": \"CancelOrder\", # Hypothetical type\n            \"client_order_index\": int(client_order_id.value, 16),\n        }\n        return tx\n\n    def _generate_auth_token(self) -> str:\n        \"\"\"\n        Generate auth token.\n        Signature payload: deadline:accountIndex:apiKeyIndex\n        \"\"\"\n        # This requires implementing Poseidon2 + Schnorr.\n        # Returning a placeholder string to satisfy type checking.\n        # In a real implementation, this would call a cryptographic library.\n        return \"mock_auth_token\"\n\n    def _sign_transaction(self, transaction: dict) -> str:\n        \"\"\"\n        Sign a transaction using the wallet private key.\n        \"\"\"\n        # Placeholder for Schnorr signature.\n        return \"mock_signature\"\n\n    def _parse_account_state(self, data: dict) -> None:\n        # Parse 'collateral' and 'positions' from response\n        # Update self._account_state via self._generate_account_state(...)\n        pass\n\n    def _process_ws_event(self, event: dict) -> None:\n        # Process events from WebSocket Private stream\n        # Events could be: 'order_updates', 'fills', 'balance_updates'\n        pass\n\n    def _update_order_status(self, data: dict) -> None:\n        # Map Lighter states to Nautilus OrderStatus\n        lighter_state = data.get(\"status\")\n        cl_order_id = ClientOrderId(str(data.get(\"client_order_index\")))\n        \n        if lighter_state == STATE_ACTIVE_LIMIT:\n            self._generate_order_accepted(\n                account_id=self.account_id,\n                instrument_id=InstrumentId.from_str(f\"{data['market_index']}.LIGHTER\"),\n                client_order_id=cl_order_id,\n                ts_event=self._clock.timestamp_ns(),\n            )\n        elif lighter_state == STATE_FILLED:\n            self._generate_order_filled(\n                account_id=self.account_id,\n                instrument_id=InstrumentId.from_str(f\"{data['market_index']}.LIGHTER\"),\n                client_order_id=cl_order_id,\n                venue_order_id=VenueOrderId(str(data.get(\"order_index\"))),\n                quote_qty=data.get(\"filled_quote_amount\"),\n                last_qty=data.get(\"filled_base_amount\"),\n                last_px=data.get(\"average_execution_price\"),\n                ts_event=self._clock.timestamp_ns(),\n            )\n        elif lighter_state == STATE_CANCELLED:\n            self._generate_order_canceled(\n                account_id=self.account_id,\n                instrument_id=InstrumentId.from_str(f\"{data['market_index']}.LIGHTER\"),\n                client_order_id=cl_order_id,\n                ts_event=self._clock.timestamp_ns(),\n            )\n",
    "factories.py": "# --------------------------------------------------------------------------------------------------\n#  LIGHTER FACTORIES\n# --------------------------------------------------------------------------------------------------\n\nfrom typing import Optional\n\nfrom nautilus_trader.adapters.factories import HttpClientFactory, WebSocketClientFactory\nfrom nautilus_trader.cache.cache import Cache\nfrom nautilus_trader.common.clock import Clock\nfrom nautilus_trader.common.enums import LogColor\nfrom nautilus_trader.core.correctness import PyCondition\nfrom nautilus_trader.core.uuid import UUID4\nfrom nautilus_trader.execution.client import ExecutionClient\nfrom nautilus_trader.live.data_client import LiveDataClient\nfrom nautilus_trader.msgbus.bus import MessageBus\n\nfrom .config import LighterConfig\nfrom .data import LighterDataClient\nfrom .execution import LighterExecutionClient\n\n\nclass LighterClientFactory:\n    \"\"\"\n    Factory for creating Lighter clients.\n    \"\"\"\n\n    @staticmethod\n    def create(\n        loop,\n        clock: Clock,\n        msgbus: MessageBus,\n        cache: Cache,\n        config: LighterConfig,\n    ) -> tuple[Optional[LiveDataClient], Optional[ExecutionClient]]:\n        \"\"\"\n        Create a new Lighter data and execution client.\n        \"\"\"\n        PyCondition.type(config, LighterConfig, \"config\")\n\n        # Create Data Client\n        data_client = LighterDataClient(\n            config=config,\n            loop=loop,\n        )\n        data_client.register(Clock(clock), MessageBus(msgbus), Cache(cache))\n\n        # Create Execution Client\n        exec_client = LighterExecutionClient(\n            config=config,\n            loop=loop,\n        )\n        exec_client.register(Clock(clock), MessageBus(msgbus), Cache(cache))\n\n        # Connect Data Client\n        if config.load_data:\n            loop.run_until_complete(data_client._connect())\n\n        # Connect Execution Client\n        if config.load_execution:\n            loop.run_until_complete(exec_client._connect())\n\n        return data_client, exec_client\n",
    "providers.py": "# --------------------------------------------------------------------------------------------------\n#  LIGHTER PROVIDERS\n# --------------------------------------------------------------------------------------------------\n\nfrom nautilus_trader.config import InstrumentProviderConfig\nfrom nautilus_trader.live.data_provider import LiveDataProvider\nfrom nautilus_trader.model.identifiers import InstrumentId\n\nfrom .data import LighterDataClient, LighterInstrumentProvider\nfrom .constants import VENUE\n\n\nclass LighterInstrumentProvider:\n    \"\"\"\n    Instrument provider for Lighter DEX.\n    \n    Note: Lighter identifies instruments by integer 'market_index'.\n    Precision metadata is fetched dynamically via `orderBookDetails`.\n    \"\"\"\n\n    def __init__(self, client: LighterDataClient, config: InstrumentProviderConfig | None = None):\n        self._client = client\n        self._config = config\n        self._instruments: dict[InstrumentId, dict] = {}  # Cache for raw instrument data\n\n    async def load_all_async(self) -> None:\n        \"\"\"\n        Load all instruments. \n        Since Lighter doesn't provide a master list endpoint in the schema,\n        this method would typically iterate known indices or be pre-configured.\n        \"\"\"\n        self._client._log.warning(\"LighterInstrumentProvider requires explicit market indices to load.\")\n        # Implementation would loop through a list of market indices\n        # await self._fetch_instrument_details(market_index)\n        pass\n\n    async def _fetch_instrument_details(self, market_index: str) -> None:\n        \"\"\"\n        Fetch specific instrument details.\n        Endpoint: /api/v1/orderBookDetails\n        \"\"\"\n        response = await self._client.query_order_book(InstrumentId.from_str(f\"{market_index}.{VENUE}\"))\n        # Parse response to extract supported_price_decimals, supported_size_decimals, etc.\n        # Create Nautilus Instrument object.\n        pass\n"
  }
}
```