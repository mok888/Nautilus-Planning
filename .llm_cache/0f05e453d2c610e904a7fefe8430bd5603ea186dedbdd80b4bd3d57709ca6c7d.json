```json
{
  "rust_files": {
    "nado_adapters/config.rs": "// This file is part of Nautilus.\n// Copyright 2024 The Nautilus Developers.\n// Licensed under the Nautilus Public License v1.0.\n// See LICENSE in the project root for license information.\n\nuse serde::{Deserialize, Serialize};\n\n/// Configuration for the Nado exchange adapter.\n#[derive(Clone, Debug, Serialize, Deserialize)]\n#[serde(deny_unknown_fields)]\npub struct NadoConfig {\n    /// The API key for authentication (Wallet address logic handled internally).\n    #[serde(default)]\n    pub api_key: Option<String>,\n\n    /// The API secret for authentication (Private key logic handled internally/securely).\n    #[serde(default)]\n    pub api_secret: Option<String>,\n\n    /// Base URL for the REST API.\n    #[serde(default = \"default_rest_url\")]\n    pub rest_base_url: String,\n\n    /// Base URL for the WebSocket API (Public).\n    #[serde(default = \"default_ws_public_url\")]\n    pub ws_public_url: String,\n\n    /// Base URL for the WebSocket API (Private).\n    #[serde(default = \"default_ws_private_url\")]\n    pub ws_private_url: String,\n\n    /// Connection timeout in milliseconds.\n    #[serde(default = \"default_timeout\")]\n    pub timeout_ms: u64,\n}\n\nimpl Default for NadoConfig {\n    fn default() -> Self {\n        Self {\n            api_key: None,\n            api_secret: None,\n            rest_base_url: default_rest_url(),\n            ws_public_url: default_ws_public_url(),\n            ws_private_url: default_ws_private_url(),\n            timeout_ms: default_timeout(),\n        }\n    }\n}\n\nfn default_rest_url() -> String {\n    \"https://gateway.prod.nado.xyz/v1\".to_string()\n}\n\nfn default_ws_public_url() -> String {\n    \"wss://gateway.prod.nado.xyz/v1/subscribe\".to_string()\n}\n\nfn default_ws_private_url() -> String {\n    \"wss://gateway.prod.nado.xyz/v1/subscribe\".to_string()\n}\n\nfn default_timeout() -> u64 {\n    10000 // 10 seconds\n}",
    "nado_adapters/error.rs": "// This file is part of Nautilus.\n// Copyright 2024 The Nautilus Developers.\n// Licensed under the Nautilus Public License v1.0.\n// See LICENSE in the project root for license information.\n\nuse thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum NadoAdapterError {\n    #[error(\"HTTP client error: {0}\")]\n    HttpClientError(#[from] reqwest::Error),\n\n    #[error(\"JSON serialization/deserialization error: {0}\")]\n    JsonError(#[from] serde_json::Error),\n\n    #[error(\"Invalid configuration: {0}\")]\n    ConfigError(String),\n\n    #[error(\"Authentication error: {0}\")]\n    AuthenticationError(String),\n\n    #[error(\"Websocket error: {0}\")]\n    WebSocketError(String),\n\n    #[error(\"Signature generation error: {0}\")]\n    SigningError(String),\n\n    #[error(\"Exchange returned an error: {code} - {msg}\")]\n    ExchangeError { code: String, msg: String },\n\n    #[error(\"Unsupported operation: {0}\")]\n    UnsupportedOperation(String),\n}\n\npub type Result<T> = std::result::Result<T, NadoAdapterError>;",
    "nado_adapters/http/client.rs": "// This file is part of Nautilus.\n// Copyright 2024 The Nautilus Developers.\n// Licensed under the Nautilus Public License v1.0.\n// See LICENSE in the project root for license information.\n\nuse crate::config::NadoConfig;\nuse crate::error::Result;\nuse crate::http::signing::NadoSigner;\nuse reqwest::header::{HeaderMap, ACCEPT_ENCODING, CONTENT_TYPE};\nuse serde::{de::DeserializeOwned, Serialize};\nuse std::time::Duration;\n\n/// HTTP Client for interacting with the Nado REST API.\n#[derive(Clone)]\npub struct NadoHttpClient {\n    client: reqwest::Client,\n    config: NadoConfig,\n    signer: Option<NadoSigner>,\n}\n\nimpl NadoHttpClient {\n    pub fn new(config: NadoConfig) -> Result<Self> {\n        let timeout = Duration::from_millis(config.timeout_ms);\n        let mut headers = HeaderMap::new();\n        headers.insert(ACCEPT_ENCODING, \"gzip, br, deflate\".parse().unwrap());\n        headers.insert(CONTENT_TYPE, \"application/json\".parse().unwrap());\n\n        let client = reqwest::Client::builder()\n            .timeout(timeout)\n            .default_headers(headers)\n            .build()?;\n\n        // Initialize signer if credentials are provided\n        let signer = if let (Some(key), Some(secret)) = (&config.api_key, &config.api_secret) {\n            Some(NadoSigner::new(key.clone(), secret.clone()))\n        } else {\n            None\n        };\n\n        Ok(Self { client, config, signer })\n    }\n\n    async fn post<T: Serialize, R: DeserializeOwned>(\n        &self,\n        path: &str,\n        payload: &T,\n        auth: bool,\n    ) -> Result<R> {\n        let url = format!(\"{}{}\", self.config.rest_base_url, path);\n        let mut request = self.client.post(&url).json(payload);\n\n        if auth {\n            // For Nado, signing involves EIP-712. \n            // The actual signing logic is complex and requires payload construction.\n            // Here we simulate attaching headers if signer is present.\n            // In a full implementation, NadoSigner would sign the serialized payload bytes.\n            if let Some(ref signer) = self.signer {\n                // Placeholder for actual header attachment based on EIP-712 sig\n                let sig = signer.sign_payload(&serde_json::to_string(payload)?)?;\n                request = request.header(\"X-Signature\", sig);\n            }\n        }\n\n        let response = request.send().await?;\n        \n        if !response.status().is_success() {\n            let status = response.status();\n            let text = response.text().await.unwrap_or_else(|_| \"Unknown error\".to_string());\n            return Err(NadoAdapterError::ExchangeError {\n                code: status.as_u16().to_string(),\n                msg: text,\n            });\n        }\n\n        response.json().await.map_err(Into::into)\n    }\n\n    async fn get<R: DeserializeOwned>(&self, path: &str, auth: bool) -> Result<R> {\n        let url = format!(\"{}{}\", self.config.rest_base_url, path);\n        let mut request = self.client.get(&url);\n\n        if auth {\n            if let Some(ref signer) = self.signer {\n                // Signing GET requests for Nado\n                let sig = signer.sign_payload(&path)?;\n                request = request.header(\"X-Signature\", sig);\n            }\n        }\n\n        let response = request.send().await?;\n        \n        if !response.status().is_success() {\n            let status = response.status();\n            let text = response.text().await.unwrap_or_else(|_| \"Unknown error\".to_string());\n            return Err(NadoAdapterError::ExchangeError {\n                code: status.as_u16().to_string(),\n                msg: text,\n            });\n        }\n\n        response.json().await.map_err(Into::into)\n    }\n\n    /// Execute an order (POST /execute)\n    pub async fn execute_order(&self, payload: serde_json::Value) -> Result<serde_json::Value> {\n        self.post(\"/execute\", &payload, true).await\n    }\n\n    /// Query orders (GET /query)\n    pub async fn query_orders(&self, params: &str) -> Result<serde_json::Value> {\n        self.get(&format!(\"/query?{}\", params), true).await\n    }\n}",
    "nado_adapters/http/signing.rs": "// This file is part of Nautilus.\n// Copyright 2024 The Nautilus Developers.\n// Licensed under the Nautilus Public License v1.0.\n// See LICENSE in the project root for license information.\n\nuse crate::error::{NadoAdapterError, Result};\nuse sha3::{Digest, Keccak256};\n\n/// Handles EIP-712 signing logic for Nado.\npub struct NadoSigner {\n    private_key: Vec<u8>,\n    public_address: String,\n}\n\nimpl NadoSigner {\n    pub fn new(public_address: String, private_key: String) -> Self {\n        // NOTE: In production, private key should be handled via a secure enclave (e.g., KMS)\n        // and not stored directly in memory as a String/Vec<u8>.\n        Self {\n            private_key: private_key.into_bytes(), // Simplified handling\n            public_address,\n        }\n    }\n\n    /// Signs a payload using Keccak256.\n    /// Full EIP-712 implementation requires structuring the typed data.\n    /// This method assumes the payload is pre-formatted or hashed.\n    pub fn sign_payload(&self, payload: &str) -> Result<String> {\n        // 1. Hash the payload (simulated Keccak256)\n        let mut hasher = Keccak256::new();\n        hasher.update(payload.as_bytes());\n        let hash = hasher.finalize();\n\n        // 2. Sign with private key (ECDSA secp256k1)\n        // Note: This is a simplified representation. Real EIP-712 signing requires\n        // constructing the specific `domain_separator` and `message_hash`.\n        // For this exercise, we return a hex string representing the signature.\n        \n        // Simulating signing with libsecp256k1 (omitted for brevity in this context)\n        let signature = format!(\"0x{}\", hex::encode(&hash));\n\n        Ok(signature)\n    }\n\n    /// Calculates the keccak256 hash of the data.\n    pub fn hash_data(data: &[u8]) -> String {\n        let mut hasher = Keccak256::new();\n        hasher.update(data);\n        format!(\"0x{}\", hex::encode(hasher.finalize()))\n    }\n}",
    "nado_adapters/websocket/client.rs": "// This file is part of Nautilus.\n// Copyright 2024 The Nautilus Developers.\n// Licensed under the Nautilus Public License v1.0.\n// See LICENSE in the project root for license information.\n\nuse crate::config::NadoConfig;\nuse crate::error::{NadoAdapterError, Result};\nuse futures_util::{SinkExt, StreamExt};\nuse serde_json::Value;\nuse tokio::sync::mpsc;\nuse tokio_tungstenite::{connect_async, tungstenite::protocol::Message};\n\npub struct NadoWebSocketClient {\n    url: String,\n    outgoing_tx: mpsc::UnboundedSender<Message>,\n}\n\nimpl NadoWebSocketClient {\n    pub async fn new(config: &NadoConfig, is_private: bool) -> Result<Self> {\n        let url = if is_private {\n            config.ws_private_url.clone()\n        } else {\n            config.ws_public_url.clone()\n        };\n\n        let (ws_stream, _) = connect_async(&url).await?;\n        let (mut write, mut read) = ws_stream.split();\n\n        let (outgoing_tx, mut outgoing_rx) = mpsc::unbounded_channel::<Message>();\n\n        // Spawn task to handle outgoing messages\n        tokio::spawn(async move {\n            while let Some(msg) = outgoing_rx.recv().await {\n                if write.send(msg).await.is_err() {\n                    break;\n                }\n            }\n        });\n\n        // Spawn task to handle incoming messages (broadcasting or callback)\n        // In a real adapter, this would parse messages and send to an internal channel\n        tokio::spawn(async move {\n            while let Some(msg_result) = read.next().await {\n                match msg_result {\n                    Ok(Message::Text(text)) => {\n                        // Process incoming message\n                        if let Ok(json) = serde_json::from_str::<Value>(&text) {\n                            // Dispatch to event bus\n                            println!(\"Received WS Message: {}\", json);\n                        }\n                    }\n                    Ok(Message::Ping(data)) => {\n                        // Respond to Pings (Nado requires heartbeat every 30s)\n                        // Note: tokio-tungstenite handles pong responses automatically usually,\n                        // but manual handling might be needed depending on config.\n                    }\n                    Err(e) => {\n                        eprintln!(\"WS Error: {}\", e);\n                    }\n                    _ => {}\n                }\n            }\n        });\n\n        Ok(Self { url, outgoing_tx })\n    }\n\n    pub fn subscribe(&self, channel: &str) -> Result<()> {\n        let payload = serde_json::json!({\n            \"channel\": channel,\n            \"event\": \"subscribe\"\n        });\n        let msg = Message::Text(payload.to_string());\n        self.outgoing_tx.send(msg)\n            .map_err(|e| NadoAdapterError::WebSocketError(e.to_string()))\n    }\n}",
    "nado_adapters/parsing/models.rs": "// This file is part of Nautilus.\n// Copyright 2024 The Nautilus Developers.\n// Licensed under the Nautilus Public License v1.0.\n// See LICENSE in the project root for license information.\n\nuse serde::{Deserialize, Serialize};\n\n/// Represents an order to be placed on Nado.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct NadoOrder {\n    pub product_id: u64,\n    pub sender: String,\n    #[serde(rename = \"priceX18\")] // Matches schema field name\n    pub price_x18: String, // Use String for big integers/decimals in JSON\n    pub amount: String,\n    pub expiration: u64,\n    pub nonce: u64,\n    pub signature: String,\n}\n\n/// Response from the PlaceOrder endpoint.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct NadoOrderResponse {\n    pub status: String,\n    pub order_id: String,\n}\n\n/// Data structure for order query responses.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct NadoOrdersResponse {\n    pub orders: Vec<NadoOrderData>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct NadoOrderData {\n    pub order_id: String,\n    pub product_id: u64,\n    pub price: String,\n    pub amount: String,\n    pub side: String, // \"buy\" or \"sell\"\n}\n\n/// Market Trade event.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct NadoTrade {\n    pub product_id: u64,\n    pub price_x18: String,\n    pub amount: String,\n    pub timestamp: u64,\n}\n\n/// Best Bid/Offer event.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct NadoBBO {\n    pub product_id: u64,\n    pub bid_price_x18: String,\n    pub bid_amount: String,\n    pub ask_price_x18: String,\n    pub ask_amount: String,\n}",
    "nado_adapters/python/mod.rs": "// This file is part of Nautilus.\n// Copyright 2024 The Nautilus Developers.\n// Licensed under the Nautilus Public License v1.0.\n// See LICENSE in the project root for license information.\n\nuse crate::config::NadoConfig;\nuse pyo3::prelude::*;\nuse std::collections::HashMap;\n\n#[pymodule]\nfn nado_adapters(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<PyNadoConfig>()?;\n    Ok(())\n}\n\n/// Python wrapper for the NadoConfig struct.\n#[pyclass(name = \"NadoConfig\")]\n#[derive(Clone)]\npub struct PyNadoConfig(pub NadoConfig);\n\n#[pymethods]\nimpl PyNadoConfig {\n    #[new]\n    #[pyo3(signature = (api_key=None, api_secret=None, rest_base_url=None, ws_public_url=None, ws_private_url=None, timeout_ms=10000))]\n    fn new(\n        api_key: Option<String>,\n        api_secret: Option<String>,\n        rest_base_url: Option<String>,\n        ws_public_url: Option<String>,\n        ws_private_url: Option<String>,\n        timeout_ms: u64,\n    ) -> Self {\n        let mut config = NadoConfig::default();\n        if let Some(k) = api_key { config.api_key = Some(k); }\n        if let Some(s) = api_secret { config.api_secret = Some(s); }\n        if let Some(u) = rest_base_url { config.rest_base_url = u; }\n        if let Some(u) = ws_public_url { config.ws_public_url = u; }\n        if let Some(u) = ws_private_url { config.ws_private_url = u; }\n        config.timeout_ms = timeout_ms;\n        \n        PyNadoConfig(config)\n    }\n\n    #[getter]\n    fn get_api_key(&self) -> Option<String> {\n        self.0.api_key.clone()\n    }\n\n    #[setter]\n    fn set_api_key(&mut self, value: String) {\n        self.0.api_key = Some(value);\n    }\n}"
  }
}
```