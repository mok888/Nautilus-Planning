```json
{
  "rust_files": {
    "config.rs": "// Copyright (C) 2024 Nautilus Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse serde::{Deserialize, Serialize};\nuse nautilus_model::identifiers::venue::Venue;\n\n/// Configuration for the Lighter exchange adapter.\n#[derive(Clone, Debug, Deserialize, Serialize)]\n#[serde(tag = \"type\")]\npub struct LighterConfig {\n    /// The API key for authentication.\n    pub api_key: String,\n    /// The secret key for signing requests.\n    pub api_secret: String,\n    /// The chain ID (e.g., 137 for Polygon Mainnet).\n    pub chain_id: u64,\n    /// The base URL for the REST API.\n    #[serde(default = \"default_rest_url\")]\n    pub rest_base_url: String,\n    /// The URL for the WebSocket connection.\n    #[serde(default = \"default_ws_url\")]\n    pub ws_base_url: String,\n    /// Whether to use TLS for the WebSocket connection (usually true).\n    #[serde(default = \"default_ws_tls\")]\n    pub ws_use_tls: bool,\n}\n\nfn default_rest_url() -> String {\n    \"https://api.lighter.xyz\".to_string()\n}\n\nfn default_ws_url() -> String {\n    \"api.lighter.xyz\".to_string() // Host only, constructed into ws:// or wss://\n}\n\nfn default_ws_use_tls() -> bool {\n    true\n}\n\nimpl LighterConfig {\n    pub const VENUE: Venue = Venue::from(\"LIGHTER\");\n\n    pub fn new(api_key: String, api_secret: String, chain_id: u64) -> Self {\n        Self {\n            api_key,\n            api_secret,\n            chain_id,\n            rest_base_url: default_rest_url(),\n            ws_base_url: default_ws_url(),\n            ws_use_tls: default_ws_tls(),\n        }\n    }\n\n    pub fn rest_endpoint(&self, path: &str) -> String {\n        format!(\"{}{}\", self.rest_base_url.trim_end_matches('/'), path)\n    }\n\n    pub fn ws_endpoint(&self) -> String {\n        let protocol = if self.ws_use_tls { \"wss\" } else { \"ws\" };\n        format!(\"{}://{}\", protocol, self.ws_base_url)\n    }\n}",
    "error.rs": "// Copyright (C) 2024 Nautilus Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse thiserror::Error;\n\n/// Errors that can occur during interaction with the Lighter API.\n#[derive(Debug, Error)]\npub enum LighterAdapterError {\n    #[error(\"HTTP request failed: {0}\")]\n    RequestError(#[from] nautilus_network::http::HttpError),\n\n    #[error(\"WebSocket connection error: {0}\")]\n    WebSocketError(String),\n\n    #[error(\"Authentication failed: {0}\")]\n    AuthenticationError(String),\n\n    #[error(\"Parsing error: {0}\")\n    ParseError(String),\n\n    #[error(\"Invalid configuration: {0}\")]\n    ConfigError(String),\n\n    #[error(\"Exchange returned an error: code={code}, message={message}\")]\n    ExchangeError { code: String, message: String },\n\n    #[error(\"Signature generation error: {0}\")]\n    SignatureError(String),\n}\n\npub type Result<T> = std::result::Result<T, LighterAdapterError>;",
    "http/client.rs": "// Copyright (C) 2024 Nautilus Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::config::LighterConfig;\nuse crate::error::{LighterAdapterError, Result};\nuse crate::http::signing::LighterSigner;\nuse nautilus_core::time::UnixTimestamp;\nuse nautilus_network::http::{HttpClient, HttpMethod, HttpRequest, HttpResponse};\nuse serde::de::DeserializeOwned;\nuse serde::Serialize;\n\nconst API_VERSION: &str = \"/v1\";\n\npub struct LighterHttpClient {\n    client: HttpClient,\n    config: LighterConfig,\n    signer: LighterSigner,\n}\n\nimpl LighterHttpClient {\n    pub fn new(config: LighterConfig) -> Self {\n        Self {\n            client: HttpClient::new(),\n            signer: LighterSigner::new(config.api_secret.clone()),\n            config,\n        }\n    }\n\n    async fn request<T: DeserializeOwned>(\n        &self,\n        method: HttpMethod,\n        path: &str,\n        auth_required: bool,\n        body: Option<String>,\n    ) -> Result<T> {\n        let full_path = format!(\"{}{}\", API_VERSION, path);\n        let url = self.config.rest_endpoint(&full_path);\n        let timestamp = UnixTimestamp::now().as_millis();\n\n        let mut req = HttpRequest::new(method, url);\n\n        // Add standard headers\n        req.header(\"x-lighter-chain-id\", self.config.chain_id.to_string());\n        req.header(\"x-timestamp\", timestamp.to_string());\n\n        if auth_required {\n            req.header(\"x-api-key\", self.config.api_key.clone());\n            \n            let signature = self.signer.sign(\n                timestamp,\n                method.as_str(),\n                &full_path,\n                body.as_deref().unwrap_or(\"\"),\n            )?;\n            req.header(\"x-signature\", signature);\n        }\n\n        if let Some(b) = body {\n            req.header(\"Content-Type\", \"application/json\");\n            req.body(b);\n        }\n\n        let resp: HttpResponse = self.client.execute(req).await?;\n        self.handle_response(resp).await\n    }\n\n    async fn handle_response<T: DeserializeOwned>(&self, resp: HttpResponse) -> Result<T> {\n        if !resp.status.is_success() {\n            return Err(LighterAdapterError::ExchangeError {\n                code: resp.status.as_u16().to_string(),\n                message: format!(\"HTTP {}\", resp.status.as_u16()),\n            });\n        }\n\n        let body = resp.body_string().await?;\n        serde_json::from_str(&body).map_err(|e| LighterAdapterError::ParseError(e.to_string()))\n    }\n\n    // Public Endpoints\n\n    pub async fn get_tickers(&self) -> Result<Vec<serde_json::Value>> {\n        self.request(\n            HttpMethod::GET,\n            \"/tickers\",\n            false,\n            None,\n        ).await\n    }\n\n    pub async fn get_orderbook(&self, symbol: &str) -> Result<serde_json::Value> {\n        let path = format!(\"/orderbook?chainId={}&symbol={}\", self.config.chain_id, symbol);\n        self.request(HttpMethod::GET, &path, false, None).await\n    }\n\n    // Private Endpoints\n\n    pub async fn create_order(&self, payload: serde_json::Value) -> Result<serde_json::Value> {\n        let body_str = serde_json::to_string(&payload)\n            .map_err(|e| LighterAdapterError::ParseError(e.to_string()))?;\n        self.request(HttpMethod::POST, \"/order\", true, Some(body_str)).await\n    }\n}",
    "http/signing.rs": "// Copyright (C) 2024 Nautilus Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::error::{LighterAdapterError, Result};\nuse hmac::{Hmac, Mac, NewMac};\nuse sha2::Sha256;\n\ntype HmacSha256 = Hmac<Sha256>;\n\npub struct LighterSigner {\n    secret: Vec<u8>,\n}\n\nimpl LighterSigner {\n    pub fn new(secret: String) -> Self {\n        Self {\n            secret: secret.into_bytes(),\n        }\n    }\n\n    /// Signs the request payload.\n    /// Format: timestamp + method + requestPath + body\n    pub fn sign(&self, timestamp: u64, method: &str, request_path: &str, body: &str) -> Result<String> {\n        let payload = format!(\"{}{}{}{}\", timestamp, method, request_path, body);\n\n        let mut mac = HmacSha256::new_from_slice(&self.secret)\n            .map_err(|e| LighterAdapterError::SignatureError(e.to_string()))?;\n        mac.update(payload.as_bytes());\n        \n        let result = mac.finalize();\n        let code_bytes = result.into_bytes();\n        \n        Ok(hex::encode(code_bytes))\n    }\n}",
    "websocket/client.rs": "// Copyright (C) 2024 Nautilus Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::config::LighterConfig;\nuse crate::error::{LighterAdapterError, Result};\nuse crate::http::signing::LighterSigner;\nuse nautilus_core::time::UnixTimestamp;\nuse nautilus_network::websocket::WebSocketClient;\nuse serde_json::Value;\n\npub struct LighterWebSocketClient {\n    client: WebSocketClient,\n    config: LighterConfig,\n    signer: LighterSigner,\n}\n\nimpl LighterWebSocketClient {\n    pub fn new(config: LighterConfig) -> Self {\n        Self {\n            client: WebSocketClient::new(),\n            signer: LighterSigner::new(config.api_secret.clone()),\n            config,\n        }\n    }\n\n    /// Connects to the WebSocket server. If `auth` is true, sends an authentication payload.\n    pub async fn connect(&mut self, auth: bool) -> Result<()> {\n        let url = self.config.ws_endpoint();\n        self.client.connect(url).await?;\n\n        if auth {\n            self.authenticate().await?;\n        }\n\n        Ok(())\n    }\n\n    async fn authenticate(&mut self) -> Result<()> {\n        let timestamp = UnixTimestamp::now().as_millis();\n        \n        let signature = self.signer.sign(\n            timestamp,\n            \"GET\", \n            \"/ws\",\n            \"\",\n        )?;\n\n        let auth_payload = serde_json::json!({\n            \"method\": \"auth\",\n            \"apiKey\": self.config.api_key,\n            \"timestamp\": timestamp,\n            \"signature\": signature,\n            \"chainId\": self.config.chain_id\n        });\n\n        self.send(auth_payload).await?;\n        Ok(())\n    }\n\n    pub async fn subscribe(&mut self, channel: &str, symbol: Option<&str>) -> Result<()> {\n        let mut payload = serde_json::json!({\n            \"method\": \"subscribe\",\n            \"channel\": channel\n        });\n\n        if let Some(sym) = symbol {\n            payload[\"symbol\"] = serde_json::Value::String(sym.to_string());\n        }\n\n        self.send(payload).await\n    }\n\n    pub async fn send(&mut self, payload: Value) -> Result<()> {\n        let msg_str = serde_json::to_string(&payload)\n            .map_err(|e| LighterAdapterError::ParseError(e.to_string()))?;\n        self.client\n            .send_text(msg_str)\n            .await\n            .map_err(|e| LighterAdapterError::WebSocketError(e.to_string()))\n    }\n\n    pub async fn recv(&mut self) -> Result<Value> {\n        let msg = self.client\n            .recv_text()\n            .await\n            .map_err(|e| LighterAdapterError::WebSocketError(e.to_string()))?;\n\n        serde_json::from_str(&msg)\n            .map_err(|e| LighterAdapterError::ParseError(e.to_string()))\n    }\n}",
    "parsing/models.rs": "// Copyright (C) 2024 Nautilus Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::error::Result;\nuse nautilus_core::time::UnixTimestamp;\nuse nautilus_model::data::{OrderBookDepth, QuoteTick, TradeTick};\nuse nautilus_model::enums::{OrderSide, PriceType};\nuse nautilus_model::identifiers::{InstrumentId, Symbol, TradeId};\nuse nautilus_model::types::{Price, Quantity};\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LighterTicker {\n    pub symbol: String,\n    pub lastPrice: String,\n    pub volume: String,\n    pub priceStep: String,\n    pub sizeStep: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LighterOrderBookLevel {\n    pub price: String,\n    pub size: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LighterOrderBook {\n    pub symbol: String,\n    pub bids: Vec<LighterOrderBookLevel>,\n    pub asks: Vec<LighterOrderBookLevel>,\n    pub timestamp: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LighterTrade {\n    pub id: String,\n    pub symbol: String,\n    pub price: String,\n    pub quantity: String,\n    pub side: String,\n    pub timestamp: u64,\n}\n\nimpl LighterTicker {\n    pub fn parse_last_price(&self) -> Result<Price> {\n        Price::from_str(&self.lastPrice).map_err(|e| crate::error::LighterAdapterError::ParseError(format!(\"Invalid price: {}\", e)))\n    }\n}\n\nimpl LighterOrderBook {\n    pub fn timestamp(&self) -> UnixTimestamp {\n        UnixTimestamp::from_millis(self.timestamp)\n    }\n\n    pub fn instrument_id(&self) -> InstrumentId {\n        InstrumentId::from(Symbol::from(self.symbol.as_str()), crate::config::LighterConfig::VENUE)\n    }\n}\n\nimpl LighterTrade {\n    pub fn to_trade_tick(&self) -> Result<TradeTick> {\n        let instrument_id = InstrumentId::from(Symbol::from(self.symbol.as_str()), crate::config::LighterConfig::VENUE);\n        let price = Price::from_str(&self.price)?;\n        let size = Quantity::from_str(&self.quantity)?;\n        let side = match self.side.to_lowercase().as_str() {\n            \"buy\" => OrderSide::Buy,\n            \"sell\" => OrderSide::Sell,\n            _ => return Err(crate::error::LighterAdapterError::ParseError(format!(\"Invalid side: {}\", self.side))),\n        };\n        let trade_id = TradeId::new(self.id.clone());\n        let ts_event = UnixTimestamp::from_millis(self.timestamp);\n        let ts_init = ts_event;\n\n        TradeTick::new(\n            instrument_id,\n            price,\n            size,\n            side,\n            trade_id,\n            ts_event,\n            ts_init,\n        )\n    }\n}",
    "python/mod.rs": "// Copyright (C) 2024 Nautilus Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nuse crate::config::LighterConfig;\nuse pyo3::prelude::*;\n\n#[pymodule]\nfn nautilus_lighter(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<PyLighterConfig>()?;\n    Ok(())\n}\n\n/// Python wrapper for LighterConfig\n#[pyclass(name = \"LighterConfig\")]\npub struct PyLighterConfig {\n    config: LighterConfig,\n}\n\n#[pymethods]\nimpl PyLighterConfig {\n    #[new]\n    fn new(api_key: String, api_secret: String, chain_id: u64) -> Self {\n        Self {\n            config: LighterConfig::new(api_key, api_secret, chain_id),\n        }\n    }\n\n    #[getter]\n    fn api_key(&self) -> String {\n        self.config.api_key.clone()\n    }\n\n    #[getter]\n    fn api_secret(&self) -> String {\n        self.config.api_secret.clone()\n    }\n\n    #[getter]\n    fn chain_id(&self) -> u64 {\n        self.config.chain_id\n    }\n\n    fn __repr__(&self) -> String {\n        format!(\"LighterConfig(chain_id={}, ...)\", self.config.chain_id)\n    }\n}"
  }
}
```