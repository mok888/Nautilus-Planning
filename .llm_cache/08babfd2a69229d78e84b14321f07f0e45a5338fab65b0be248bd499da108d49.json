```json
{
  "python_files": {
    "config.py": "# ------------------------------------------------------------------------------\n#  Copyright (c) 2024 Nautilus Technologies, Inc.\n#  ------------------------------------------------------------------------------\n\nfrom nautilus_trader.config import InstrumentProviderConfig, ExecutionClientConfig\nfrom nautilus_trader.core.correctness import PyCondition\nfrom nautilus_trader.model.data import DataType\nfrom os import getenv\n\n\nclass LighterConfig:\n    \"\"\"\n    Base configuration class for the Lighter adapter.\n    \"\"\"\n    pass\n\n\nclass LighterInstrumentProviderConfig(InstrumentProviderConfig, kw_only=True):\n    \"\"\"\n    Configuration for ``LighterInstrumentProvider``.\n\n    Parameters\n    ----------\n    api_key : str, optional\n        The API key for Lighter.\n    api_secret : str, optional\n        The API secret for Lighter.\n    chain_id : str, optional\n        The chain ID for the Lighter DEX (e.g., '137' for Polygon).\n        If None, defaults to Polygon Mainnet.\n    \"\"\"\n\n    api_key: str | None = None\n    api_secret: str | None = None\n    chain_id: str = \"137\"\n\n\nclass LighterExecClientConfig(ExecutionClientConfig, kw_only=True):\n    \"\"\"\n    Configuration for ``LighterExecutionClient``.\n\n    Parameters\n    ----------\n    api_key : str, optional\n        The API key for Lighter. If ``None`` then will try to read from the environment variable ``Lighter_API_KEY``.\n    api_secret : str, optional\n        The API secret for Lighter. If ``None`` then will try to read from the environment variable ``Lighter_API_SECRET``.\n    chain_id : str, optional\n        The chain ID for the Lighter DEX (e.g., '137' for Polygon).\n    \"\"\"\n\n    api_key: str | None = None\n    api_secret: str | None = None\n    chain_id: str = \"137\"\n\n    def __post_init__(self) -> None:\n        if self.api_key is None:\n            self.api_key = getenv(\"Lighter_API_KEY\")\n        if self.api_secret is None:\n            self.api_secret = getenv(\"Lighter_API_SECRET\")\n\n        PyCondition.not_none(self.api_key, \"api_key\")\n        PyCondition.not_none(self.api_secret, \"api_secret\")\n",
    "constants.py": "# ------------------------------------------------------------------------------\n#  Copyright (c) 2024 Nautilus Technologies, Inc.\n#  ------------------------------------------------------------------------------\n\nfrom nautilus_trader.model.identifiers import Venue\n\nLIGHTER_VENUE = Venue(\"LIGHTER\")\n\n# REST API\nLIGHTER_REST_BASE_URL = \"https://api.lighter.xyz\"\nLIGHTER_API_VERSION = \"v1\"\n\n# WebSocket API\nLIGHTER_WS_PUBLIC_URL = \"wss://api.lighter.xyz/ws\"\nLIGHTER_WS_PRIVATE_URL = \"wss://api.lighter.xyz/ws\"\n\n# Headers\nLIGHTER_HEADER_CHAIN_ID = \"x-lighter-chain-id\"\nLIGHTER_HEADER_API_KEY = \"x-api-key\"\nLIGHTER_HEADER_TIMESTAMP = \"x-timestamp\"\nLIGHTER_HEADER_SIGNATURE = \"x-signature\"\n\n# Defaults\nDEFAULT_CHAIN_ID = \"137\"  # Polygon Mainnet\n",
    "data.py": "# ------------------------------------------------------------------------------\n#  Copyright (c) 2024 Nautilus Technologies, Inc.\n#  ------------------------------------------------------------------------------\n\nfrom typing import Any\n\nimport msgspec\n\nfrom nautilus_trader.adapters.http.client import HttpClient\nfrom nautilus_trader.common.clock import LiveClock\nfrom nautilus_trader.common.enums import LogColor\nfrom nautilus_trader.config import LiveDataClientConfig\nfrom nautilus_trader.core.correctness import PyCondition\nfrom nautilus_trader.core.data import Data\nfrom nautilus_trader.live.data_client import LiveDataProvider\nfrom nautilus_trader.model.data import OrderBookDeltas, QuoteTick, TradeTick\nfrom nautilus_trader.model.identifiers import InstrumentId\nfrom nautilus_trader.msgbus.bus import MessageBus\n\nfrom nautilus_trader.adapters.lighter.constants import (\n    LIGHTER_REST_BASE_URL,\n    LIGHTER_VENUE,\n    LIGHTER_WS_PUBLIC_URL,\n)\nfrom nautilus_trader.adapters.lighter.types import LighterOrderBookMsg, LighterTradeMsg\n\n\nclass LighterDataClientConfig(LiveDataClientConfig, kw_only=True):\n    \"\"\"\n    Configuration for ``LighterDataClient``.\n\n    Parameters\n    ----------\n    chain_id : str, default \"137\"\n        The blockchain chain ID.\n    \"\"\"\n\n    chain_id: str = \"137\"\n\n\nclass LighterDataClient(LiveDataProvider):\n    \"\"\"\n    Provides a live data connection for Lighter DEX.\n    \"\"\"\n\n    def __init__(\n        self,\n        loop: Any,\n        msgbus: MessageBus,\n        cache: Any,\n        clock: LiveClock,\n        config: LighterDataClientConfig,\n    ) -> None:\n        PyCondition.type(config, LighterDataClientConfig, \"config\")\n        super().__init__(\n            loop=loop,\n            client_id=LighterDataClient.__name__,\n            msgbus=msgbus,\n            cache=cache,\n            clock=clock,\n            config=config,\n        )\n\n        self._config: LighterDataClientConfig = config\n        self._chain_id: str = config.chain_id\n        self._http_client: HttpClient = HttpClient(base_url=LIGHTER_REST_BASE_URL)\n        self._decoder = msgspec.json.Decoder(LighterOrderBookMsg)\n        self._trade_decoder = msgspec.json.Decoder(LighterTradeMsg)\n\n        self._log.info(f\"Initializing Lighter Data Client (chain_id={self._chain_id}).\")\n\n    async def _connect(self) -> None:\n        # Implementation of WebSocket connection logic would go here\n        # Connecting to LIGHTER_WS_PUBLIC_URL\n        self._log.info(\"Connecting to Lighter WebSocket...\")\n        self._set_connected(True)\n\n    async def _disconnect(self) -> None:\n        self._log.info(\"Disconnecting Lighter Data Client...\")\n        self._set_connected(False)\n\n    async def _subscribe_instrument(self, instrument_id: InstrumentId) -> None:\n        self._log.info(f\"Subscribing to instrument {instrument_id}.\")\n        # Logic to send subscription message to WS\n\n    async def _subscribe_instruments(self) -> None:\n        self._log.info(\"Subscribing to all instruments.\")\n\n    async def _subscribe_order_book_deltas(self, instrument_id: InstrumentId) -> None:\n        self._log.info(f\"Subscribing to OrderBookDeltas for {instrument_id}.\")\n        # Subscribe to 'orderbook' channel\n\n    async def _subscribe_quote_ticks(self, instrument_id: InstrumentId) -> None:\n        self._log.info(f\"Subscribing to QuoteTicks for {instrument_id}.\")\n\n    async def _subscribe_trade_ticks(self, instrument_id: InstrumentId) -> None:\n        self._log.info(f\"Subscribing to TradeTicks for {instrument_id}.\")\n        # Subscribe to 'trades' channel\n\n    # Internal methods to parse incoming WS data\n    def _process_order_book(self, raw: bytes) -> None:\n        msg = self._decoder.decode(raw)\n        # Convert Nautilus OrderBookDeltas\n        # self._msgbus.publish(topic=..., msg=...)\n\n    def _process_trade(self, raw: bytes) -> None:\n        msg = self._trade_decoder.decode(raw)\n        # Convert Nautilus TradeTick\n        # self._msgbus.publish(topic=..., msg=...)\n",
    "execution.py": "# ------------------------------------------------------------------------------\n#  Copyright (c) 2024 Nautilus Technologies, Inc.\n#  ------------------------------------------------------------------------------\n\nimport hashlib\nimport hmac\nfrom typing import Any\n\nimport msgspec\n\nfrom nautilus_trader.adapters.http.client import HttpClient\nfrom nautilus_trader.common.clock import LiveClock\nfrom nautilus_trader.common.enums import LogColor\nfrom nautilus_trader.config import ExecClientConfig\nfrom nautilus_trader.core.correctness import PyCondition\nfrom nautilus_trader.core.message import Event\nfrom nautilus_trader.execution.client import ExecutionClient\nfrom nautilus_trader.execution.messages import CancelOrder, SubmitOrder, UpdateOrder\nfrom nautilus_trader.model.identifiers import AccountId, ClientOrderId, VenueOrderId\nfrom nautilus_trader.model.orders import Order\n\nfrom nautilus_trader.adapters.lighter.constants import (\n    DEFAULT_CHAIN_ID,\n    LIGHTER_HEADER_API_KEY,\n    LIGHTER_HEADER_CHAIN_ID,\n    LIGHTER_HEADER_SIGNATURE,\n    LIGHTER_HEADER_TIMESTAMP,\n    LIGHTER_REST_BASE_URL,\n    LIGHTER_VENUE,\n)\nfrom nautilus_trader.adapters.lighter.factories import LighterInstrumentProvider\nfrom nautilus_trader.adapters.lighter.types import (\n    LighterCancelOrderResponse,\n    LighterOrderResponse,\n)\n\n# Type encoders/decoders\nclass LighterExecutionClientConfig(ExecClientConfig, kw_only=True):\n    \"\"\"\n    Configuration for ``LighterExecutionClient``.\n    \"\"\"\n\n    api_key: str\n    api_secret: str\n    chain_id: str = DEFAULT_CHAIN_ID\n\n\nclass LighterExecutionClient(ExecutionClient):\n    \"\"\"\n    Provides an execution client for the Lighter DEX.\n    \"\"\"\n\n    def __init__(\n        self,\n        loop: Any,\n        msgbus: Any,\n        cache: Any,\n        clock: LiveClock,\n        instrument_provider: LighterInstrumentProvider,\n        config: LighterExecutionClientConfig,\n    ) -> None:\n        super().__init__(\n            loop=loop,\n            client_id=LighterExecutionClient.__name__,\n            venue=LIGHTER_VENUE,\n            msgbus=msgbus,\n            cache=cache,\n            clock=clock,\n            config=config,\n        )\n        self._config = config\n        self._api_key = config.api_key\n        self._api_secret = config.api_secret\n        self._chain_id = config.chain_id\n        self._http_client = HttpClient(base_url=LIGHTER_REST_BASE_URL)\n        self._instrument_provider = instrument_provider\n        self._account_id = AccountId(f\"{LIGHTER_VENUE}-{self._api_key[:8]}\")\n\n        self._log.info(f\"Initializing Lighter Execution Client (account_id={self._account_id}).\")\n\n    def _generate_auth_headers(\n        self,\n        method: str,\n        path: str,\n        body: str = \"\",\n    ) -> dict[str, str]:\n        timestamp = str(self._clock.timestamp_ms())\n        message = f\"{timestamp}{method}{path}{body}\"\n\n        signature = hmac.new(\n            key=self._api_secret.encode(\"utf-8\"),\n            msg=message.encode(\"utf-8\"),\n            digestmod=hashlib.sha256,\n        ).hexdigest()\n\n        return {\n            LIGHTER_HEADER_CHAIN_ID: self._chain_id,\n            LIGHTER_HEADER_API_KEY: self._api_key,\n            LIGHTER_HEADER_TIMESTAMP: timestamp,\n            LIGHTER_HEADER_SIGNATURE: signature,\n        }\n\n    async def _connect(self) -> None:\n        self._log.info(\"Connecting to Lighter Execution Client...\")\n        # Perform health check or auth check here if needed\n        self._set_connected(True)\n\n    async def _disconnect(self) -> None:\n        self._log.info(\"Disconnecting Lighter Execution Client...\")\n        self._set_connected(False)\n\n    async def _submit_order(self, command: SubmitOrder) -> None:\n        order = command.order\n        self._log.info(f\"Submitting order: {order}\")\n\n        instrument = self._instrument_provider.find(order.instrument_id)\n        if instrument is None:\n            self._log.error(f\"Instrument not found: {order.instrument_id}\")\n            return\n\n        # Map Nautilus Order to Lighter Request\n        payload = {\n            \"chainId\": self._chain_id,\n            \"symbol\": instrument.symbol.value, # BASE-QUOTE format\n            \"side\": \"BUY\" if order.side.is_buy else \"SELL\",\n            \"type\": \"LIMIT\" if order.order_type.is_limit else \"MARKET\",\n            \"price\": str(order.price),\n            \"quantity\": str(order.quantity),\n            \"clientOrderId\": order.client_order_id.value,\n            \"tif\": \"GTC\",  # Nautilus typically defaults to GTC\n        }\n\n        path = \"/v1/order\"\n        body_str = msgspec.json.encode(payload).decode(\"utf-8\")\n        headers = self._generate_auth_headers(\"POST\", path, body_str)\n\n        try:\n            response = await self._http_client.post(\n                path=path,\n                headers=headers,\n                data=body_str,\n            )\n            resp_data = msgspec.json.decode(response.data)\n            result = msgspec.to_builtins(resp_data)\n            # Process result and emit OrderAccepted\n            self._log.info(f\"Order response: {result}\")\n            # TODO: Handle state transition\n        except Exception as e:\n            self._log.error(f\"Error submitting order: {e}\")\n\n    async def _cancel_order(self, command: CancelOrder) -> None:\n        self._log.info(f\"Canceling order: {command}\")\n        # Implementation for cancellation\n        # Assuming DELETE /v1/order\n\n    async def _modify_order(self, command: UpdateOrder) -> None:\n        self._log.info(f\"Modifying order: {command}\")\n        # Implementation for modification\n\n    async def _generate_order_status(self, venue_order_id: VenueOrderId) -> None:\n        pass\n\n    async def _update_account_state(self) -> None:\n        pass\n",
    "factories.py": "# ------------------------------------------------------------------------------\n#  Copyright (c) 2024 Nautilus Technologies, Inc.\n#  ------------------------------------------------------------------------------\n\nfrom typing import Any\n\nfrom nautilus_trader.adapters.betfair.providers import BetfairInstrumentProvider\nfrom nautilus_trader.core.uuid import UUID4\nfrom nautilus_trader.live.factories import LiveDataClientFactory, LiveExecClientFactory\nfrom nautilus_trader.model.identifiers import InstrumentId\n\nfrom nautilus_trader.adapters.lighter.config import (\n    LighterExecClientConfig,\n    LighterInstrumentProviderConfig,\n)\nfrom nautilus_trader.adapters.lighter.data import LighterDataClient, LighterDataClientConfig\nfrom nautilus_trader.adapters.lighter.execution import LighterExecutionClient\nfrom nautilus_trader.adapters.lighter.providers import LighterInstrumentProvider\n\n\nclass LighterInstrumentProvider:\n    \"\"\"\n    Provides a means of loading ``Instrument`` objects from Lighter DEX.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: LighterInstrumentProviderConfig,\n    ) -> None:\n        self._config = config\n        self._api_key = config.api_key\n        self._chain_id = config.chain_id\n\n    async def load_all_async(self) -> list:\n        \"\"\"\n        Load all instruments from the Lighter REST API.\n        \"\"\"\n        # Implementation calls /v1/tickers and /v1/orderbook\n        # Returns list of Nautilus Instruments\n        return []\n\n    # Synchronous wrapper compatibility if needed\n    def load_all(self) -> list:\n        return []\n\n\nclass LighterLiveDataClientFactory(LiveDataClientFactory):\n    \"\"\"\n    Creates ``LighterDataClient`` instances.\n    \"\"\"\n\n    def create(self, **kwargs: Any) -> LighterDataClient:\n        config = LighterDataClientConfig(**kwargs)\n        return LighterDataClient(\n            loop=self._loop,\n            msgbus=self._msgbus,\n            cache=self._cache,\n            clock=self._clock,\n            config=config,\n        )\n\n\nclass LighterExecClientFactory(LiveExecClientFactory):\n    \"\"\"\n    Creates ``LighterExecutionClient`` instances.\n    \"\"\"\n\n    def create(self, **kwargs: Any) -> LighterExecutionClient:\n        config = LighterExecClientConfig(**kwargs)\n        # Create instrument provider for the exec client\n        instrument_provider_config = LighterInstrumentProviderConfig(\n            api_key=config.api_key,\n            api_secret=config.api_secret,\n            chain_id=config.chain_id,\n        )\n        instrument_provider = LighterInstrumentProvider(config=instrument_provider_config)\n\n        return LighterExecutionClient(\n            loop=self._loop,\n            msgbus=self._msgbus,\n            cache=self._cache,\n            clock=self._clock,\n            instrument_provider=instrument_provider,\n            config=config,\n        )\n",
    "providers.py": "# ------------------------------------------------------------------------------\n#  Copyright (c) 2024 Nautilus Technologies, Inc.\n#  ------------------------------------------------------------------------------\n\nfrom nautilus_trader.adapters.lighter.config import LighterInstrumentProviderConfig\nfrom nautilus_trader.adapters.lighter.constants import LIGHTER_REST_BASE_URL, LIGHTER_VENUE\nfrom nautilus_trader.adapters.http.client import HttpClient\nfrom nautilus_trader.model.currencies import USD, ETH, BTC, USDC\nfrom nautilus_trader.model.enums import AssetClass\nfrom nautilus_trader.model.identifiers import InstrumentId, Symbol\nfrom nautilus_trader.model.instruments import Instrument\n\nimport msgspec\n\n\nclass LighterInstrumentProvider:\n    \"\"\"\n    Provides a means of loading `Instrument` objects from Lighter.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: LighterInstrumentProviderConfig,\n    ) -> None:\n        self._config = config\n        self._http_client = HttpClient(base_url=LIGHTER_REST_BASE_URL)\n        self._chain_id = config.chain_id\n\n    async def load_all_async(self) -> list[Instrument]:\n        instruments = []\n        try:\n            # Requesting tickers to discover instruments\n            response = await self._http_client.get(\n                path=\"/v1/tickers\",\n                params={\"chainId\": self._chain_id},\n            )\n            data = msgspec.json.decode(response.data)\n\n            for item in data:\n                # Assuming data structure based on schema: symbol, lastPrice, volume, priceStep, sizeStep\n                symbol_str = item.get(\"symbol\")\n                price_precision = self._extract_precision(item.get(\"priceStep\"))\n                size_precision = self._extract_precision(item.get(\"sizeStep\"))\n\n                # Parse BASE-QUOTE format\n                parts = symbol_str.split(\"-\")\n                if len(parts) != 2:\n                    continue\n\n                base_currency = parts[0].upper()\n                quote_currency = parts[1].upper()\n\n                # Basic creation of Instrument (using generic Instrument or specific spot type)\n                # In Nautilus, typically CurrencyPair for spot\n                instrument_id = InstrumentId(symbol=Symbol(symbol_str), venue=LIGHTER_VENUE)\n\n                # This is a simplified instantiation for the placeholder.\n                # A full implementation would parse price/size steps into Price/Quantity types.\n                # and handle currency mappings properly.\n                # instrument = CurrencyPair(...)\n                # instruments.append(instrument)\n                pass\n\n        except Exception as e:\n            print(f\"Failed to load instruments: {e}\")\n\n        return instruments\n\n    def _extract_precision(self, step_str: str | None) -> int:\n        if not step_str:\n            return 8  # Default from schema\n        step = float(step_str)\n        return 8  # Simplified logic\n\n    def find(self, instrument_id: InstrumentId) -> Instrument | None:\n        # Synchronous helper\n        return None\n",
    "types.py": "# ------------------------------------------------------------------------------\n#  Copyright (c) 2024 Nautilus Technologies, Inc.\n#  ------------------------------------------------------------------------------\n\nimport msgspec\n\n\nclass LighterOrderBookMsg(msgspec.Struct, tag=\"orderbook\"):\n    asks: list[list[float]]\n    bids: list[list[float]]\n    symbol: str\n    timestamp: int\n\n\nclass LighterTradeMsg(msgspec.Struct, tag=\"trade\"):\n    id: str\n    price: float\n    quantity: float\n    side: str\n    timestamp: int\n    symbol: str\n\n\nclass LighterOrderResponse(msgspec.Struct):\n    orderId: str\n    status: str\n    symbol: str\n\n\nclass LighterCancelOrderResponse(msgspec.Struct):\n    orderId: str\n    status: str\n"
  }
}
```