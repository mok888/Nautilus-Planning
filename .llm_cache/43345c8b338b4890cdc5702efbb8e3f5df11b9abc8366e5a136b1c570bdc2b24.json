```json
{
  "rust_files": {
    "lib.rs": "// NautilusTrader Adapter for {Nado}\n// Copyright 2024 NautilusTrader\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nmod common;\nmod config;\nmod error;\nmod http;\nmod parsing;\nmod websocket;\n\n#[cfg(feature = \"python\")]\npub mod python;\n\n// Public API exports\npub use common::consts::*;\npub use common::urls::*;\npub use config::NadoConfig;\npub use error::NadoAdapterError;\npub use http::client::NadoHttpClient;\npub use parsing::models::*;\n",
    "common/consts.rs": "//! Constants for the {Nado} adapter.\n\n/// The exchange name.\npub const EXCHANGE_NAME: &str = \"{Nado}\";\n\n/// The venue identifier.\npub const VENUE_ID: &str = \"{NADO}\";\n\n/// The API version being used.\npub const API_VERSION: &str = \"v1\";\n\n/// Supported order types (Placeholder as DEX uses atomic swaps).\npub const SUPPORTED_ORDER_TYPES: &[&str] = &[];\n\n/// Request timeout in seconds.\npub const REQUEST_TIMEOUT_SEC: u64 = 10;\n",
    "common/urls.rs": "//! API URL endpoints for {Nado}.\n\n/// Base REST API URL.\npub const REST_BASE_URL: &str = \"https://api.nado.xyz\";\n\n/// WebSocket Public URL (Placeholder - Unsupported/Unknown).\npub const WS_PUBLIC_URL: &str = \"UNKNOWN\";\n\n/// WebSocket Private URL (Placeholder - Unsupported/Unknown).\npub const WS_PRIVATE_URL: &str = \"UNKNOWN\";\n\n/// Endpoint for getting a quote.\npub const ENDPOINT_QUOTE: &str = \"/v1/quote\";\n\n/// Endpoint for executing a swap.\npub const ENDPOINT_SWAP: &str = \"/v1/swap\";\n",
    "config.rs": "//! Configuration for the {Nado} adapter.\n\nuse serde::{Deserialize, Serialize};\n\n/// Configuration for the {Nado} exchange adapter.\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct NadoConfig {\n    /// The API key for authentication.\n    pub api_key: String,\n\n    /// The API secret for authentication (if applicable, though schema implies API Key header).\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub api_secret: Option<String>,\n\n    /// Base URL for the REST API (defaults to production).\n    #[serde(default = \"default_rest_url\")]\n    pub rest_base_url: String,\n}\n\nfn default_rest_url() -> String {\n    crate::common::urls::REST_BASE_URL.to_string()\n}\n\nimpl Default for NadoConfig {\n    fn default() -> Self {\n        Self {\n            api_key: std::env::var(\"Nado_API_KEY\").unwrap_or_else(|_| \"\".to_string()),\n            api_secret: std::env::var(\"Nado_API_SECRET\").ok(),\n            rest_base_url: default_rest_url(),\n        }\n    }\n}\n",
    "error.rs": "//! Error types for the {Nado} adapter.\n\nuse thiserror::Error;\n\n/// The main error type for the {Nado} adapter.\n#[derive(Debug, Error)]\npub enum NadoAdapterError {\n    #[error(\"HTTP client error: {0}\")]\n    HttpClientError(String),\n\n    #[error(\"Authentication failed: {0}\")]\n    AuthenticationError(String),\n\n    #[error(\"Parsing error: {0}\")]\n    ParseError(String),\n\n    #[error(\"Invalid parameter: {0}\")]\n    InvalidParameter(String),\n\n    #[error(\"Exchange returned an error: {code} - {msg}\")]\n    ExchangeError { code: String, msg: String },\n\n    #[error(\"Unsupported operation: {0}\")]\n    UnsupportedOperation(String),\n}\n\nimpl From<serde_json::Error> for NadoAdapterError {\n    fn from(err: serde_json::Error) -> Self {\n        Self::ParseError(err.to_string())\n    }\n}\n",
    "http/client.rs": "//! HTTP client for interacting with the {Nado} API.\n\nuse crate::{\n    common::urls::{ENDPOINT_QUOTE, ENDPOINT_SWAP},\n    config::NadoConfig,\n    error::NadoAdapterError,\n    http::signing::NadoSigner,\n    parsing::models::{QuoteRequest, QuoteResponse, SwapRequest, SwapResponse},\n};\nuse nautilus_network::http::HttpClient;\nuse serde_json::Value;\n\n/// Client for the {Nado} REST API.\npub struct NadoHttpClient {\n    client: HttpClient,\n    config: NadoConfig,\n    signer: NadoSigner,\n}\n\nimpl NadoHttpClient {\n    /// Creates a new `NadoHttpClient`.\n    pub fn new(config: NadoConfig) -> Self {\n        // In a real implementation, HttpClient construction might require runtime handles\n        // Here we assume a default or provided constructor\n        let client = HttpClient::new(\n            config.rest_base_url.clone(),\n            std::time::Duration::from_secs(crate::common::consts::REQUEST_TIMEOUT_SEC),\n        );\n        let signer = NadoSigner::new(config.api_key.clone(), config.api_secret.clone());\n\n        Self {\n            client,\n            config,\n            signer,\n        }\n    }\n\n    /// Fetches a quote for a swap.\n    pub async fn get_quote(&self, req: &QuoteRequest) -> Result<QuoteResponse, NadoAdapterError> {\n        let body = serde_json::to_string(req).map_err(|e| NadoAdapterError::ParseError(e.to_string()))?;\n        \n        let headers = self.signer.get_headers();\n        \n        let response = self.client\n            .post(ENDPOINT_QUOTE)\n            .headers(headers)\n            .body(body)\n            .send()\n            .await\n            .map_err(|e| NadoAdapterError::HttpClientError(e.to_string()))?;\n\n        let status = response.status();\n        let response_body = response\n            .text()\n            .await\n            .map_err(|e| NadoAdapterError::HttpClientError(e.to_string()))?;\n\n        if !status.is_success() {\n            return Err(Self::handle_error(status, &response_body));\n        }\n\n        let quote: QuoteResponse = serde_json::from_str(&response_body)?;\n        Ok(quote)\n    }\n\n    /// Executes a swap.\n    pub async fn execute_swap(&self, req: &SwapRequest) -> Result<SwapResponse, NadoAdapterError> {\n        let body = serde_json::to_string(req).map_err(|e| NadoAdapterError::ParseError(e.to_string()))?;\n        \n        let headers = self.signer.get_headers();\n\n        let response = self.client\n            .post(ENDPOINT_SWAP)\n            .headers(headers)\n            .body(body)\n            .send()\n            .await\n            .map_err(|e| NadoAdapterError::HttpClientError(e.to_string()))?;\n\n        let status = response.status();\n        let response_body = response\n            .text()\n            .await\n            .map_err(|e| NadoAdapterError::HttpClientError(e.to_string()))?;\n\n        if !status.is_success() {\n            return Err(Self::handle_error(status, &response_body));\n        }\n\n        let swap: SwapResponse = serde_json::from_str(&response_body)?;\n        Ok(swap)\n    }\n\n    fn handle_error(status: reqwest::StatusCode, body: &str) -> NadoAdapterError {\n        // Attempt to parse exchange error message\n        if let Ok(value) = serde_json::from_str::<Value>(body) {\n            if let Some(msg) = value.get(\"message\").and_then(|v| v.as_str()) {\n                return NadoAdapterError::ExchangeError {\n                    code: status.as_u16().to_string(),\n                    msg: msg.to_string(),\n                };\n            }\n        }\n        NadoAdapterError::HttpClientError(format!(\"Status {} - Body: {}\", status, body))\n    }\n}\n",
    "http/signing.rs": "//! Authentication and signing logic for {Nado}.\n\nuse http::HeaderMap;\n\n/// Handles authentication headers for {Nado}.\npub struct NadoSigner {\n    api_key: String,\n    _api_secret: Option<String>, // Kept for future compatibility if HMAC is introduced\n}\n\nimpl NadoSigner {\n    pub fn new(api_key: String, api_secret: Option<String>) -> Self {\n        Self {\n            api_key,\n            _api_secret: api_secret,\n        }\n    }\n\n    /// Returns the necessary headers for an authenticated request.\n    pub fn get_headers(&self) -> HeaderMap {\n        let mut headers = HeaderMap::new();\n        headers.insert(\"X-API-KEY\", self.api_key.parse().unwrap());\n        headers.insert(\"Content-Type\", \"application/json\".parse().unwrap());\n        headers.insert(\"Accept\", \"application/json\".parse().unwrap());\n        headers\n    }\n}\n",
    "websocket/client.rs": "//! WebSocket client for {Nado}.\n\n// Note: WebSocket URLs and channels are marked UNKNOWN in the schema.\n// This is a placeholder implementation to satisfy the adapter structure.\n\nuse crate::error::NadoAdapterError;\n\n/// Client for {Nado} WebSocket feeds (Public/Private).\npub struct NadoWebSocketClient {\n    _url: String,\n}\n\nimpl NadoWebSocketClient {\n    pub fn new(_url: String) -> Result<Self, NadoAdapterError> {\n        Err(NadoAdapterError::UnsupportedOperation(\n            \"WebSocket connectivity is currently unsupported for {Nado}\".to_string(),\n        ))\n    }\n\n    pub async fn connect(&mut self) -> Result<(), NadoAdapterError> {\n        Err(NadoAdapterError::UnsupportedOperation(\n            \"WebSocket connect is currently unsupported for {Nado}\".to_string(),\n        ))\n    }\n}\n",
    "parsing/models.rs": "//! Data models for requests and responses.\n\nuse serde::{Deserialize, Serialize};\n\n/// Request to get a swap quote.\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct QuoteRequest {\n    /// Source token address (e.g., 0x...)\n    pub src: String,\n    /// Destination token address (e.g., 0x...)\n    pub dst: String,\n    /// Amount to swap\n    pub amount: String,\n    /// Slippage tolerance percentage\n    pub slippage: f64,\n}\n\n/// Response containing swap quote details.\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct QuoteResponse {\n    /// Estimated price\n    pub price: String,\n    /// Gas price for the transaction\n    pub gas_price: String,\n    /// Protocol fee\n    pub protocol_fee: String,\n    /// Unique ID for this quote\n    pub quote_id: String,\n}\n\n/// Request to execute a swap.\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct SwapRequest {\n    /// The ID of the quote to execute\n    pub quote_id: String,\n}\n\n/// Response containing the transaction details.\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct SwapResponse {\n    /// Encoded transaction data\n    pub encoded_tx: String,\n    /// Transaction hash (if pre-submitted/mocked)\n    pub tx_hash: Option<String>,\n}\n",
    "python/mod.rs": "//! Python bindings via PyO3.\n\nuse pyo3::prelude::*;\nuse crate::config::NadoConfig;\n\n/// {Nado} adapter module.\n#[pymodule]\npub fn nado(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<PyNadoConfig>()?;\n    Ok(())\n}\n\n/// Python wrapper for `NadoConfig`.\n#[pyclass(name = \"NadoConfig\")]\npub struct PyNadoConfig {\n    config: NadoConfig,\n}\n\n#[pymethods]\nimpl PyNadoConfig {\n    #[new]\n    #[pyo3(signature = (api_key=None, api_secret=None, rest_base_url=None))]\n    fn new(\n        api_key: Option<String>,\n        api_secret: Option<String>,\n        rest_base_url: Option<String>,\n    ) -> Self {\n        let c = NadoConfig {\n            api_key: api_key.unwrap_or_else(|| std::env::var(\"Nado_API_KEY\").unwrap_or_default()),\n            api_secret: api_secret.or_else(|| std::env::var(\"Nado_API_SECRET\").ok()),\n            rest_base_url: rest_base_url.unwrap_or_else(|| crate::common::urls::REST_BASE_URL.to_string()),\n        };\n        Self { config: c }\n    }\n\n    #[getter]\n    fn api_key(&self) -> String {\n        self.config.api_key.clone()\n    }\n\n    #[getter]\n    fn rest_base_url(&self) -> String {\n        self.config.rest_base_url.clone()\n    }\n}\n",
    "python/urls.rs": "//! Constants exposed to Python.\n\nuse pyo3::prelude::*;\n\n/// Returns the base URL for the {Nado} REST API.\n#[pyfunction]\npub fn get_rest_base_url() -> &'static str {\n    crate::common::urls::REST_BASE_URL\n}\n\n/// Returns the WebSocket Public URL.\n#[pyfunction]\npub fn get_ws_public_url() -> &'static str {\n    crate::common::urls::WS_PUBLIC_URL\n}\n"
  }
}
```