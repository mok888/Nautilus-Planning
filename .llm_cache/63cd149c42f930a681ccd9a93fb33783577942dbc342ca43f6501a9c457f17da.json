```json
{
  "rust_files": {
    "common/consts.rs": "use nautilus_model::identifiers::venue::Venue;\n\npub const EXCHANGE_NAME: &str = \"Lighter\";\npub const VENUE: Venue = Venue::from(\"LIGHTER\");\npub const API_VERSION: &str = \"v1\";\npub const DEFAULT_CHAIN_ID: &str = \"137\"; // Polygon Mainnet\n\n// Headers\npub const HEADER_CHAIN_ID: &str = \"x-lighter-chain-id\";\npub const HEADER_API_KEY: &str = \"x-api-key\";\npub const HEADER_TIMESTAMP: &str = \"x-timestamp\";\npub const HEADER_SIGNATURE: &str = \"x-signature\";\n\n// Rate Limits (120 requests per minute)\npub const RATE_LIMIT_QUOTA: u32 = 120;\npub const RATE_LIMIT_DURATION_MS: u64 = 60_000;\n",
    "common/urls.rs": "pub const REST_BASE_URL: &str = \"https://api.lighter.xyz\";\npub const WS_PUBLIC_URL: &str = \"wss://api.lighter.xyz/ws\";\npub const WS_PRIVATE_URL: &str = \"wss://api.lighter.xyz/ws\";\n\n// REST Endpoints\npub const PATH_TICKERS: &str = \"/v1/tickers\";\npub const PATH_ORDERBOOK: &str = \"/v1/orderbook\";\npub const PATH_ORDER: &str = \"/v1/order\";\n",
    "config.rs": "use crate::common::consts::DEFAULT_CHAIN_ID;\nuse serde::{Deserialize, Serialize};\nuse std::env;\nuse std::sync::Arc;\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct LighterConfig {\n    pub api_key: String,\n    pub api_secret: String,\n    pub chain_id: Option<String>,\n}\n\nimpl LighterConfig {\n    pub fn new(api_key: String, api_secret: String) -> Self {\n        Self {\n            api_key,\n            api_secret,\n            chain_id: Some(DEFAULT_CHAIN_ID.to_string()),\n        }\n    }\n\n    pub fn from_env() -> Option<Arc<Self>> {\n        let api_key = env::var(\"Lighter_API_KEY\").ok()?;\n        let api_secret = env::var(\"Lighter_API_SECRET\").ok()?;\n        let chain_id = env::var(\"LIGHTER_CHAIN_ID\").ok();\n        Some(Arc::new(Self {\n            api_key,\n            api_secret,\n            chain_id,\n        }))\n    }\n}\n",
    "error.rs": "use thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum LighterError {\n    #[error(\"HTTP request failed: {0}\")]\n    HttpError(#[from] hyper::Error),\n\n    #[error(\"JSON serialization/deserialization error: {0}\")]\n    JsonError(#[from] serde_json::Error),\n\n    #[error(\"Signing error: {0}\")]\n    SigningError(String),\n\n    #[error(\"Rate limit exceeded\")]\n    RateLimitExceeded,\n\n    #[error(\"Exchange returned error: {code} - {msg}\")]\n    ExchangeError { code: i32, msg: String },\n\n    #[error(\"Invalid configuration: {0}\")]\n    ConfigError(String),\n\n    #[error(\"WebSocket error: {0}\")]\n    WebSocketError(String),\n}\n\npub type Result<T> = std::result::Result<T, LighterError>;\n",
    "http/signing.rs": "use crate::error::LighterError;\nuse hex::ToHex;\nuse hmac::{Hmac, Mac};\nuse sha2::Sha256;\n\npub type HmacSha256 = Hmac<Sha256>;\n\npub fn generate_signature(\n    timestamp: u64,\n    method: &str,\n    request_path: &str,\n    body: &str,\n    secret: &str,\n) -> Result<String> {\n    // Payload format: timestamp + method + requestPath + body\n    let payload = format!(\"{}{}{}{}\", timestamp, method, request_path, body);\n\n    let mut mac = HmacSha256::new_from_slice(secret.as_bytes())\n        .map_err(|e| LighterError::SigningError(format!(\"Invalid key length: {}\", e)))?;\n\n    mac.update(payload.as_bytes());\n    let signature = mac.finalize().into_bytes();\n\n    Ok(signature.encode_hex::<String>())\n}\n",
    "http/client.rs": "use crate::common::consts::{HEADER_API_KEY, HEADER_CHAIN_ID, HEADER_SIGNATURE, HEADER_TIMESTAMP, RATE_LIMIT_DURATION_MS, RATE_LIMIT_QUOTA};\nuse crate::common::urls::{REST_BASE_URL, PATH_ORDER, PATH_ORDERBOOK, PATH_TICKERS};\nuse crate::config::LighterConfig;\nuse crate::error::{LighterError, Result};\nuse crate::http::signing::generate_signature;\nuse governor::{clock, state, Quota, RateLimiter};\nuse hyper::body::Incoming;\nuse hyper::http::{header, HeaderValue, Method, Request, StatusCode};\nuse hyper::rt::exec;\nuse hyper_util::client::legacy::Client;\nuse hyper_util::rt::TokioExecutor;\nuse hyper_rustls::HttpsConnectorBuilder;\nuse serde::de::DeserializeOwned;\nuse serde::Serialize;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\nuse tower::ServiceBuilder;\n\npub struct LighterHttpClient {\n    config: Arc<LighterConfig>,\n    client: Client<hyper_rustls::HttpsConnector<hyper::client::HttpConnector>, String>,\n    rate_limiter: Arc<RateLimiter<state::NotKeyed, state::InMemoryState, clock::DefaultClock>>,\n}\n\nimpl LighterHttpClient {\n    pub fn new(config: Arc<LighterConfig>) -> Self {\n        // Setup HTTPS connector\n        let https = HttpsConnectorBuilder::new()\n            .with_native_roots()\n            .https_or_http()\n            .enable_http1()\n            .build();\n\n        let client: Client<_, String> = Client::builder(TokioExecutor::new()).build(https);\n\n        // Setup Rate Limiter (Governor)\n        let quota = Quota::per_minute(RATE_LIMIT_QUOTA);\n        let rate_limiter = Arc::new(RateLimiter::direct(quota));\n\n        Self {\n            config,\n            client,\n            rate_limiter,\n        }\n    }\n\n    async fn send_request<T: DeserializeOwned>(\n        &self,\n        method: Method,\n        path: &str,\n        body: Option<String>,\n        auth_required: bool,\n    ) -> Result<T> {\n        // Rate limiting check\n        self.rate_limiter.until_ready().await;\n\n        let chain_id = self.config.chain_id.as_ref().unwrap(); // Should be set in config\n        let timestamp = chrono::Utc::now().timestamp_millis();\n        \n        let body_str = body.clone().unwrap_or_default();\n        let mut request = Request::builder()\n            .method(method.clone())\n            .uri(format!(\"{}{}\", REST_BASE_URL, path))\n            .header(HEADER_CHAIN_ID, chain_id);\n\n        if auth_required {\n            let signature = generate_signature(timestamp as u64, method.as_str(), path, &body_str, &self.config.api_secret)?;\n            request = request\n                .header(HEADER_API_KEY, &self.config.api_key)\n                .header(HEADER_TIMESTAMP, timestamp.to_string())\n                .header(HEADER_SIGNATURE, signature);\n        }\n\n        let request = if let Some(b) = body {\n            request\n                .header(header::CONTENT_TYPE, \"application/json\")\n                .body(b)\n                .map_err(|e| LighterError::HttpError(hyper::Error::new(e.to_string())))?\n        } else {\n            request\n                .body(String::new())\n                .map_err(|e| LighterError::HttpError(hyper::Error::new(e.to_string())))?\n        };\n\n        let response = self.client\n            .request(request)\n            .await\n            .map_err(LighterError::HttpError)?;\n\n        let status = response.status();\n        let body_bytes = hyper::body::collect(response.into_body())\n            .await\n            .map_err(LighterError::HttpError)?\n            .to_bytes();\n\n        if status.is_success() {\n            serde_json::from_slice(&body_bytes).map_err(Into::into)\n        } else {\n            // Attempt to parse error format if available\n            let error_msg = String::from_utf8_lossy(&body_bytes).to_string();\n            Err(LighterError::ExchangeError {\n                code: status.as_u16() as i32,\n                msg: error_msg,\n            })\n        }\n    }\n\n    pub async fn get_tickers(&self) -> Result<TickersResponse> {\n        self.send_request(Method::GET, PATH_TICKERS, None, false).await\n    }\n\n    pub async fn get_orderbook(&self, symbol: &str) -> Result<OrderbookResponse> {\n        // Append query params manually or implement in send_request. For simplicity, assuming path takes struct or manual.\n        // Here we pass path with query string for the example.\n        let path = format!(\"{}?symbol={}\", PATH_ORDERBOOK, symbol);\n        self.send_request(Method::GET, &path, None, false).await\n    }\n\n    pub async fn create_order(&self, order_req: CreateOrderRequest) -> Result<OrderResponse> {\n        let body = serde_json::to_string(&order_req)?;\n        self.send_request(Method::POST, PATH_ORDER, Some(body), true).await\n    }\n}\n\n// --- Data Models for Serialization ---\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct TickersResponse {\n    pub symbol: String,\n    pub lastPrice: String,\n    pub volume: String,\n    pub priceStep: String,\n    pub sizeStep: String,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct OrderbookResponse {\n    pub asks: Vec<[String; 2]>, // [price, size]\n    pub bids: Vec<[String; 2]>,\n    pub timestamp: u64,\n}\n\n#[derive(Debug, Serialize)]\npub struct CreateOrderRequest {\n    pub chainId: String,\n    pub symbol: String,\n    pub side: String, // \"BUY\" or \"SELL\"\n    #[serde(rename = \"type\")]\n    pub order_type: String, // \"LIMIT\", \"MARKET\"\n    pub price: String,\n    pub quantity: String,\n    pub clientOrderId: String,\n    pub tif: String, // \"GTC\", \"IOC\", etc.\n}\n\n#[derive(Debug, Deserialize)]\npub struct OrderResponse {\n    pub orderId: String,\n    pub status: String,\n    pub symbol: String,\n}\n",
    "websocket/client.rs": "use crate::common::urls::WS_PUBLIC_URL;\nuse crate::config::LighterConfig;\nuse crate::error::{LighterError, Result};\nuse futures_util::{SinkExt, StreamExt};\nuse nautilus_model::identifiers::instrument_id::InstrumentId;\nuse serde::{Deserialize, Serialize};\nuse std::sync::Arc;\nuse tokio::net::TcpStream;\nuse tokio_tungstenite::{connect_async, tungstenite::Message, MaybeTlsStream, WebSocketStream};\n\npub struct LighterWebSocketClient {\n    config: Arc<LighterConfig>,\n    ws_stream: Option<WebSocketStream<MaybeTlsStream<TcpStream>>>,\n}\n\nimpl LighterWebSocketClient {\n    pub fn new(config: Arc<LighterConfig>) -> Self {\n        Self {\n            config,\n            ws_stream: None,\n        }\n    }\n\n    pub async fn connect(&mut self) -> Result<()> {\n        let url = WS_PUBLIC_URL;\n        let (ws_stream, _) = connect_async(url)\n            .await\n            .map_err(|e| LighterError::WebSocketError(e.to_string()))?;\n        \n        self.ws_stream = Some(ws_stream);\n        Ok(())\n    }\n\n    pub async fn authenticate(&mut self) -> Result<()> {\n        // Auth via specific message or headers in handshake. \n        // Research says WS auth required, usually via payload or handshake. \n        // Assuming handshake headers are not possible in raw ws stream after connect (unlike HTTP),\n        // we send an auth message. \n        // NOTE: Schema doesn't define Auth payload, only headers for REST. \n        // Implementing a placeholder for the specific auth message.\n        \n        if let Some(stream) = &mut self.ws_stream {\n            // Example auth payload logic would go here based on exchange specifics.\n            // For now, we assume connection established.\n            Ok(())\n        } else {\n            Err(LighterError::WebSocketError(\"Not connected\".to_string()))\n        }\n    }\n\n    pub async fn subscribe_orderbook(&mut self, symbol: &str) -> Result<()> {\n        let sub_msg = WsSubscribe {\n            op: \"subscribe\".to_string(),\n            channel: \"orderbook\".to_string(),\n            symbol: symbol.to_string(),\n        };\n\n        let json = serde_json::to_string(&sub_msg)?;\n        if let Some(stream) = &mut self.ws_stream {\n            stream.send(Message::Text(json)).await\n                .map_err(|e| LighterError::WebSocketError(e.to_string()))?;\n        }\n        Ok(())\n    }\n\n    pub async fn next_message(&mut self) -> Result<WsMessage> {\n        if let Some(stream) = &mut self.ws_stream {\n            let msg = stream.next().await.ok_or(LighterError::WebSocketError(\"Connection closed\".to_string()))??;\n            match msg {\n                Message::Text(text) => {\n                    let parsed: WsMessage = serde_json::from_str(&text)?;\n                    Ok(parsed)\n                }\n                Message::Ping(payload) => {\n                    // Handle ping/pong automatically usually handled by lib, but explicit if needed\n                    let _ = stream.send(Message::Pong(payload)).await;\n                    self.next_message().await\n                }\n                _ => Err(LighterError::WebSocketError(\"Unexpected message type\".to_string()))\n            }\n        } else {\n            Err(LighterError::WebSocketError(\"Not connected\".to_string()))\n        }\n    }\n}\n\n// --- WS Models ---\n\n#[derive(Debug, Serialize)]\nstruct WsSubscribe {\n    op: String,\n    channel: String,\n    symbol: String,\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(tag = \"channel\")]\npub enum WsMessage {\n    #[serde(rename = \"orderbook\")]\n    Orderbook(OrderbookUpdate),\n    #[serde(rename = \"trades\")]\n    Trades(TradeUpdate),\n    // Add other channels as needed\n}\n\n#[derive(Debug, Deserialize)]\npub struct OrderbookUpdate {\n    pub symbol: String,\n    pub bids: Vec<[String; 2]>,\n    pub asks: Vec<[String; 2]>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct TradeUpdate {\n    pub symbol: String,\n    pub side: String,\n    pub price: String,\n    pub quantity: String,\n    pub timestamp: u64,\n}\n",
    "parsing/models.rs": "// This module contains shared models for parsing and validation\n// used across the adapter.\n\nuse nautilus_model::identifiers::instrument_id::InstrumentId;\nuse nautilus_model::identifiers::symbol::Symbol;\nuse nautilus_model::identifiers::venue::Venue;\n\n/// Helper to create InstrumentId from the raw string format \"BASE-QUOTE\"\npub fn parse_instrument_id(raw: &str, venue: Venue) -> InstrumentId {\n    let symbol = Symbol::new(raw.to_string()).expect(\"Invalid symbol format\");\n    InstrumentId::new(symbol, venue)\n}\n\n#[derive(Debug, Clone)]\npub struct LighterTicker {\n    pub instrument_id: InstrumentId,\n    pub price: f64,\n    pub volume: f64,\n}\n",
    "python/mod.rs": "use crate::common::urls::{REST_BASE_URL, WS_PUBLIC_URL};\nuse crate::config::LighterConfig;\nuse pyo3::prelude::*;\nuse std::sync::Arc;\n\n#[pymodule]\npub fn lighter_nautilus(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<PyLighterConfig>()?;\n    m.add_function(wrap_pyfunction!(get_urls, m)?)?;\n    Ok(())\n}\n\n#[pyclass(name = \"LighterConfig\")]\npub struct PyLighterConfig {\n    config: LighterConfig,\n}\n\n#[pymethods]\nimpl PyLighterConfig {\n    #[new]\n    pub fn new(api_key: String, api_secret: String) -> Self {\n        Self {\n            config: LighterConfig::new(api_key, api_secret),\n        }\n    }\n\n    #[getter]\n    pub fn api_key(&self) -> String {\n        self.config.api_key.clone()\n    }\n\n    #[getter]\n    pub fn api_secret(&self) -> String {\n        self.config.api_secret.clone()\n    }\n}\n\n#[pyfunction]\npub fn get_urls() -> PyResult<(String, String)> {\n    Ok((REST_BASE_URL.to_string(), WS_PUBLIC_URL.to_string()))\n}\n",
    "python/urls.rs": "// Expose URLs to Python side directly\nuse pyo3::prelude::*;\n\n#[pyfunction]\npub fn get_rest_url() -> String {\n    \"https://api.lighter.xyz\".to_string()\n}\n\n#[pyfunction]\npub fn get_ws_url() -> String {\n    \"wss://api.lighter.xyz/ws\".to_string()\n}\n"
  }
}
```