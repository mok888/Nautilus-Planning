```json
{
  "rust_files": {
    "lib.rs": "#![allow(clippy::too_many_arguments)]\n\npub mod common;\npub mod config;\npub mod credential;\npub mod error;\npub mod http;\npub mod parsing;\npub mod websocket;\n\n#[cfg(feature = \"python\")]\npub mod python;\n\n// Re-exports\npub use config::NadoConfig;\npub use error::NadoError;\n",
    "common/consts.rs": "/// NautilusTrader Venue identifier for Nado\npub const VENUE: &str = \"NADO\";\n\n/// Exchange Name\npub const EXCHANGE_NAME: &str = \"Nado\";\n\n/// Default API Version\npub const API_VERSION: &str = \"v1\";\n",
    "common/urls.rs": "use crate::common::consts::API_VERSION;\n\n/// Base REST URL for Nado\npub const REST_BASE_URL: &str = \"https://api.nado.xyz\";\n\n/// Public Websocket URL (Unsupported per schema)\npub const WS_PUBLIC_URL: &str = \"UNKNOWN\";\n\n/// Private Websocket URL (Unsupported per schema)\npub const WS_PRIVATE_URL: &str = \"UNKNOWN\";\n\n/// Helper to generate full endpoint URL\npub fn get_endpoint(path: &str) -> String {\n    format!(\"{}/{}/{}\", REST_BASE_URL, API_VERSION, path.trim_start_matches('/'))\n}\n",
    "config.rs": "use crate::credential::NadoCredential;\nuse serde::{Deserialize, Serialize};\n\n/// Configuration for the Nado adapter.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct NadoConfig {\n    pub api_key: Option<String>,\n    pub api_secret: Option<String>,\n}\n\nimpl NadoConfig {\n    pub fn new(api_key: Option<String>, api_secret: Option<String>) -> Self {\n        Self { api_key, api_secret }\n    }\n\n    /// Loads configuration from environment variables if not provided.\n    /// Environment variables: `Nado_API_KEY`, `Nado_API_SECRET`\n    pub fn from_env() -> Self {\n        Self {\n            api_key: std::env::var(\"Nado_API_KEY\").ok(),\n            api_secret: std::env::var(\"Nado_API_SECRET\").ok(),\n        }\n    }\n\n    pub fn get_credential(&self) -> Option<NadoCredential> {\n        match (&self.api_key, &self.api_secret) {\n            (Some(key), Some(secret)) => Some(NadoCredential::new(key.clone(), secret.clone())),\n            _ => None,\n        }\n    }\n}\n",
    "credential.rs": "use serde::{Deserialize, Serialize};\n\n/// Represents the API credentials for Nado.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct NadoCredential {\n    pub api_key: String,\n    pub api_secret: String,\n}\n\nimpl NadoCredential {\n    pub fn new(api_key: String, api_secret: String) -> Self {\n        Self { api_key, api_secret }\n    }\n}\n",
    "error.rs": "use thiserror::Error;\n\n/// Core error type for the Nado adapter.\n#[derive(Debug, Error)]\npub enum NadoError {\n    #[error(\"Network error: {0}\")]\n    Network(String),\n\n    #[error(\"Authentication error: {0}\")]\n    Authentication(String),\n\n    #[error(\"Rate limit exceeded\")]\n    RateLimit,\n\n    #[error(\"Parsing error: {0}\")]\n    Parsing(String),\n\n    #[error(\"Unsupported operation: {0}\")]\n    Unsupported(String),\n\n    #[error(\"Exchange error (Code {code}): {msg}\")]\n    Exchange { code: u16, msg: String },\n\n    #[error(\"Configuration error: {0}\")]\n    Config(String),\n}\n\nimpl NadoError {\n    pub fn exchange(code: u16, msg: String) -> Self {\n        Self::Exchange { code, msg }\n    }\n}\n",
    "http/signing.rs": "use crate::credential::NadoCredential;\nuse std::collections::HashMap;\n\n/// Handles request signing for Nado.\n/// Note: Schema specifies hash algorithm as UNKNOWN, so this implementation\n/// currently assumes API Key header injection is sufficient or prepares\n/// the payload for standard HMAC if the algo becomes known.\npub struct NadoSigner;\n\nimpl NadoSigner {\n    pub fn sign_request(\n        _credential: &NadoCredential,\n        _method: &str,\n        _path: &str,\n        _body: Option<&str>,\n    ) -> Result<HashMap<String, String>, crate::error::NadoError> {\n        // Schema indicates signature_algo is UNKNOWN.\n        // For now, we return headers required for auth (X-API-KEY) which is handled\n        // in the client construction.\n        // If signing were required, we would implement HMAC-SHA256 or similar here.\n        Ok(HashMap::new())\n    }\n}\n",
    "http/client.rs": "use crate::common::urls::get_endpoint;\nuse crate::credential::NadoCredential;\nuse crate::error::NadoError;\nuse crate::parsing::models::{QuoteRequest, QuoteResponse, SwapRequest, SwapResponse};\nuse bytes::Bytes;\nuse governor::{Quota, RateLimiter};\nuse http::{header, Method, Request, StatusCode};\nuse hyper::body::Incoming;\nuse hyper_util::rt::TokioIo;\nuse nautilus_network::http::Full;\nuse std::num::NonZeroU32;\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\n\n/// HTTP Client for Nado API.\n/// Uses `hyper` via `nautilus_network` interface.\npub struct NadoHttpClient {\n    pub(crate) credential: Option<NadoCredential>,\n    // We assume nautilus_network::http::HttpClient is the provided Hyper wrapper\n    pub(crate) client: nautilus_network::http::HttpClient,\n    rate_limiter: Arc<Mutex<RateLimiter<governor::state::direct::NotKeyed>>>,\n}\n\nimpl NadoHttpClient {\n    pub fn new(credential: Option<NadoCredential>) -> Result<Self, NadoError> {\n        // Initialize standard Hyper client inside the wrapper or use provided one.\n        // Assuming nautilus_network::HttpClient has a default or similar.\n        // For this implementation, we instantiate a wrapper.\n        \n        // Example initialization of a simple hyper client if the wrapper allows it,\n        // otherwise we assume the type is passed in or constructed.\n        // Since we cannot see the internals of nautilus_network, we assume\n        // `nautilus_network::http::HttpClient::new()` exists or similar.\n        // However, to follow the strict prompt \"USE nautilus_network::http::HttpClient\",\n        // we will assume it is provided or constructed via a helper.\n        \n        let client = nautilus_network::http::HttpClient::new().map_err(|e| NadoError::Network(e.to_string()))?;\n\n        // Rate Limit: 10 requests per second (Governor config)\n        let quota = Quota::per_second(NonZeroU32::new(10).unwrap());\n        let rate_limiter = Arc::new(Mutex::new(RateLimiter::direct(quota)));\n\n        Ok(Self {\n            credential,\n            client,\n            rate_limiter,\n        })\n    }\n\n    async fn send_request(&self, method: Method, path: &str, body: Option<String>) -> Result<Bytes, NadoError> {\n        // Rate Limit Check\n        {\n            let limiter = self.rate_limiter.lock().await;\n            limiter.until_ready().await;\n        }\n\n        let url = get_endpoint(path);\n        let body_bytes = body.map(|b| Bytes::from(b));\n        let full_body = match &body_bytes {\n            Some(b) => Full::new(b.clone()),\n            None => Full::new(Bytes::new()),\n        };\n\n        let mut builder = Request::builder().method(method).uri(url);\n\n        // Inject Headers\n        if let Some(cred) = &self.credential {\n            builder = builder.header(\"X-API-KEY\", &cred.api_key);\n        }\n        builder = builder.header(\"Content-Type\", \"application/json\");\n\n        let request = builder\n            .body(full_body)\n            .map_err(|e| NadoError::Network(format!(\"Request build error: {}\", e)))?;\n\n        let response = self.client.send(request).await.map_err(|e| NadoError::Network(e.to_string()))?;\n\n        let status = response.status();\n        let body_parts = response.into_body();\n        // Collect body bytes. Since Incoming is a http_body::Body, we use hyper body util\n        let collected_bytes = hyper::body::to_bytes(body_parts)\n            .await\n            .map_err(|e| NadoError::Network(format!(\"Failed to read response body: {}\", e)))?;\n\n        if status.as_u16() >= 400 {\n            // Attempt to parse error message if JSON\n            let error_msg = String::from_utf8_lossy(&collected_bytes).to_string();\n            return Err(NadoError::exchange(status.as_u16(), error_msg));\n        }\n\n        Ok(collected_bytes)\n    }\n\n    /// Get a quote for a swap.\n    pub async fn quote(&self, req: &QuoteRequest) -> Result<QuoteResponse, NadoError> {\n        let body = serde_json::to_string(req)\n            .map_err(|e| NadoError::Parsing(format!(\"Failed to serialize QuoteRequest: {}\", e)))?;\n        \n        let bytes = self.send_request(Method::POST, \"/quote\", Some(body)).await?;\n        let resp: QuoteResponse = serde_json::from_slice(&bytes)\n            .map_err(|e| NadoError::Parsing(format!(\"Failed to parse QuoteResponse: {}\", e)))?;\n        Ok(resp)\n    }\n\n    /// Execute a swap.\n    pub async fn swap(&self, req: &SwapRequest) -> Result<SwapResponse, NadoError> {\n        let body = serde_json::to_string(req)\n            .map_err(|e| NadoError::Parsing(format!(\"Failed to serialize SwapRequest: {}\", e)))?;\n            \n        let bytes = self.send_request(Method::POST, \"/swap\", Some(body)).await?;\n        let resp: SwapResponse = serde_json::from_slice(&bytes)\n            .map_err(|e| NadoError::Parsing(format!(\"Failed to parse SwapResponse: {}\", e)))?;\n        Ok(resp)\n    }\n}\n",
    "parsing/models.rs": "use serde::{Deserialize, Serialize};\n\n/// Request model for getting a quote.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct QuoteRequest {\n    pub src: String,  // Source token address\n    pub dst: String,  // Destination token address\n    pub amount: String,\n    pub slippage: String,\n}\n\n/// Response model for a quote.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct QuoteResponse {\n    pub price: String,\n    pub gasPrice: String,\n    pub protocolFee: String,\n}\n\n/// Request model for executing a swap.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SwapRequest {\n    pub quoteId: String,\n}\n\n/// Response model for a swap.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SwapResponse {\n    pub encodedTx: String,\n    pub txHash: String,\n}\n",
    "websocket/client.rs": "use crate::error::NadoError;\nuse tokio_tungstenite::tungstenite::protocol::Message;\n\n/// WebSocket client for Nado.\n/// Note: Schema specifies WS URLs as UNKNOWN.\npub struct NadoWebSocketClient {\n    _dummy: u8,\n}\n\nimpl NadoWebSocketClient {\n    pub fn new(_endpoint: &str) -> Result<Self, NadoError> {\n        Err(NadoError::Unsupported(\n            \"WebSocket connection is not supported by Nado adapter (URL UNKNOWN).\".to_string(),\n        ))\n    }\n\n    pub async fn connect(&mut self) -> Result<(), NadoError> {\n        Err(NadoError::Unsupported(\n            \"WebSocket connection is not supported by Nado adapter (URL UNKNOWN).\".to_string(),\n        ))\n    }\n\n    pub async fn send(&mut self, _msg: Message) -> Result<(), NadoError> {\n        Err(NadoError::Unsupported(\n            \"WebSocket operations are not supported.\".to_string(),\n        ))\n    }\n\n    pub async fn recv(&mut self) -> Result<Message, NadoError> {\n        Err(NadoError::Unsupported(\n            \"WebSocket operations are not supported.\".to_string(),\n        ))\n    }\n}\n",
    "python/mod.rs": "use crate::common::urls;\nuse crate::config::NadoConfig;\nuse pyo3::prelude::*;\nuse pyo3::types::PyDict;\n\n/// Python module for Nautilus Nado adapter.\n#[pymodule]\nfn nautilus_nado(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<PyNadoConfig>()?;\n    m.add_function(wrap_pyfunction!(get_rest_base_url, m)?)?;\n    Ok(())\n}\n\n#[pyclass(name = \"NadoConfig\")]\npub struct PyNadoConfig {\n    config: NadoConfig,\n}\n\n#[pymethods]\nimpl PyNadoConfig {\n    #[new]\n    #[pyo3(signature = (api_key=None, api_secret=None))]\n    fn new(api_key: Option<String>, api_secret: Option<String>) -> Self {\n        Self {\n            config: NadoConfig::new(api_key, api_secret),\n        }\n    }\n\n    #[staticmethod]\n    fn from_env() -> Self {\n        Self {\n            config: NadoConfig::from_env(),\n        }\n    }\n\n    fn to_dict(&self, py: Python) -> PyResult<PyObject> {\n        let dict = PyDict::new(py);\n        if let Some(key) = &self.config.api_key {\n            dict.set_item(\"api_key\", key)?;\n        }\n        if let Some(secret) = &self.config.api_secret {\n            dict.set_item(\"api_secret\", secret)?;\n        }\n        Ok(dict.into())\n    }\n}\n\n#[pyfunction]\nfn get_rest_base_url() -> String {\n    urls::REST_BASE_URL.to_string()\n}\n",
    "python/urls.rs": "//! Python bindings for Nado URLs.\n\nuse pyo3::prelude::*;\n\n/// Returns the base REST URL for Nado.\n#[pyfunction]\npub fn get_rest_base_url() -> String {\n    crate::common::urls::REST_BASE_URL.to_string()\n}\n"
  }
}
```