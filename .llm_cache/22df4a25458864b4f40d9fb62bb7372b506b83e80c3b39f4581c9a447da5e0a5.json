```json
{
  "rust_files": {
    "common/consts.rs": "//! NautilusTrader Adapter - Lighter Common Constants\n\n/// The exchange identifier for Lighter.\npub const EXCHANGE_NAME: &str = \"LIGHTER\";\n\n/// The default API version.\npub const API_VERSION: &str = \"v1\";\n\n/// The default WebSocket heartbeat interval in seconds.\npub const WS_HEARTBEAT_INTERVAL_SEC: u64 = 30;\n\n/// HTTP Header keys\npub const HEADER_CHAIN_ID: &str = \"x-lighter-chain-id\";\npub const HEADER_API_KEY: &str = \"x-api-key\";\npub const HEADER_TIMESTAMP: &str = \"x-timestamp\";\npub const HEADER_SIGNATURE: &str = \"x-signature\";\n\n/// Rate Limits (120 requests per minute)\npub const RATE_LIMIT_LIMIT: u32 = 120;\npub const RATE_LIMIT_PERIOD_MS: u64 = 60_000;",
    "common/urls.rs": "//! NautilusTrader Adapter - Lighter URLs\n\n/// Base URL for Lighter REST API\npub const REST_BASE_URL: &str = \"https://api.lighter.xyz\";\n\n/// Base URL for Lighter WebSocket API\npub const WS_BASE_URL: &str = \"wss://api.lighter.xyz/ws\";\n\npub struct Endpoints;\n\nimpl Endpoints {\n    pub fn tickers() -> String {\n        format!(\"/{}{}\", crate::common::consts::API_VERSION, \"/tickers\")\n    }\n\n    pub fn orderbook() -> String {\n        format!(\"/{}{}\", crate::common::consts::API_VERSION, \"/orderbook\")\n    }\n\n    pub fn order() -> String {\n        format!(\"/{}{}\", crate::common::consts::API_VERSION, \"/order\")\n    }\n}",
    "config.rs": "//! NautilusTrader Adapter - Lighter Configuration\n\nuse serde::{Deserialize, Serialize};\nuse std::env;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LighterConfig {\n    pub api_key: Option<String>,\n    pub api_secret: Option<String>,\n    pub chain_id: String,\n    pub timeout_ms: u64,\n}\n\nimpl Default for LighterConfig {\n    fn default() -> Self {\n        Self {\n            api_key: env::var(\"Lighter_API_KEY\").ok(),\n            api_secret: env::var(\"Lighter_API_SECRET\").ok(),\n            chain_id: \"137\".to_string(), // Default to Polygon Mainnet\n            timeout_ms: 5000,\n        }\n    }\n}\n\nimpl LighterConfig {\n    pub fn new(chain_id: String, api_key: String, api_secret: String) -> Self {\n        Self {\n            api_key: Some(api_key),\n            api_secret: Some(api_secret),\n            chain_id,\n            ..Default::default()\n        }\n    }\n}",
    "error.rs": "//! NautilusTrader Adapter - Lighter Error Types\n\nuse thiserror::Error;\n\npub type Result<T> = std::result::Result<T, LighterError>;\n\n#[derive(Error, Debug)]\npub enum LighterError {\n    #[error(\"HTTP request failed: {0}\")]\n    HttpError(#[from] hyper::Error),\n\n    #[error(\"JSON serialization/deserialization error: {0}\")]\n    JsonError(#[from] serde_json::Error),\n\n    #[error(\"IO error: {0}\")]\n    IoError(#[from] std::io::Error),\n\n    #[error(\"Authentication failed: {0}\")]\n    AuthError(String),\n\n    #[error(\"Rate limit exceeded\")]\n    RateLimitExceeded,\n\n    #[error(\"Invalid configuration: {0}\")]\n    ConfigError(String),\n\n    #[error(\"WebSocket error: {0}\")]\n    WsError(String),\n\n    #[error(\"API Error (Code {code}): {message}\")]\n    ApiError { code: i32, message: String },\n}",
    "http/signing.rs": "//! NautilusTrader Adapter - Lighter Signing Logic\n\nuse crate::config::LighterConfig;\nuse crate::error::{LighterError, Result};\nuse hex::ToHex;\nuse hmac::{Hmac, Mac};\nuse sha2::Sha256;\n\ntype HmacSha256 = Hmac<Sha256>;\n\n/// Generates the X-Signature header value.\n/// Payload format: timestamp + method + requestPath + body\npub fn generate_signature(\n    config: &LighterConfig,\n    timestamp: u64,\n    method: &str,\n    path: &str,\n    body: &str,\n) -> Result<String> {\n    let secret = config\n        .api_secret\n        .as_ref()\n        .ok_or_else(|| LighterError::AuthError(\"API Secret missing\".to_string()))?;\n\n    // Construct payload: timestamp + method + requestPath + body\n    let payload = format!(\"{}{}{}{}\", timestamp, method, path, body);\n\n    let mut mac = HmacSha256::new_from_slice(secret.as_bytes())\n        .map_err(|e| LighterError::AuthError(format!(\"HMAC Error: {}\", e)))?;\n    mac.update(payload.as_bytes());\n\n    Ok(mac.finalize().into_bytes().encode_hex())\n}",
    "http/client.rs": "//! NautilusTrader Adapter - Lighter HTTP Client\n\nuse crate::common::consts::{\n    HEADER_API_KEY, HEADER_CHAIN_ID, HEADER_SIGNATURE, HEADER_TIMESTAMP, RATE_LIMIT_LIMIT,\n    RATE_LIMIT_PERIOD_MS,\n};\nuse crate::common::urls::REST_BASE_URL;\nuse crate::config::LighterConfig;\nuse crate::error::{LighterError, Result};\nuse crate::http::signing::generate_signature;\nuse governor::{\n    clock::DefaultClock, state::InMemoryState, Quota, RateLimiter,\n};\nuse hyper::body::{Body, Incoming};\nuse hyper::http::HeaderMap;\nuse hyper::Request;\nuse hyper_rustls::HttpsConnectorBuilder;\nuse hyper_util::{\n    client::legacy::{connect::HttpConnector, Client},\n    rt::TokioExecutor,\n};\nuse std::sync::Arc;\nuse std::time::{Duration, SystemTime, UNIX_EPOCH};\n\npub struct LighterHttpClient {\n    config: LighterConfig,\n    client: Client<HttpsConnector<HttpConnector>, Body>,\n    rate_limiter: Arc<RateLimiter<InMemoryState, DefaultClock>>,\n}\n\nimpl LighterHttpClient {\n    pub fn new(config: LighterConfig) -> Self {\n        let https = HttpsConnectorBuilder::new()\n            .with_native_roots()\n            .unwrap()\n            .https_or_http()\n            .enable_http1()\n            .build();\n\n        let client: Client<_, Body> = Client::builder(TokioExecutor::new()).build(https);\n\n        // Rate Limit: 120 requests per 1 minute\n        let quota = Quota::per_minute(RATE_LIMIT_LIMIT);\n        let rate_limiter = RateLimiter::direct(quota);\n\n        Self {\n            config,\n            client,\n            rate_limiter: Arc::new(rate_limiter),\n        }\n    }\n\n    async fn request_inner<B>(&self, method: hyper::Method, path: &str, body: B) -> Result<String>\n    where\n        B: hyper::body::Body + Send + 'static,\n        B::Data: Send,\n        B::Error: Into<Box<dyn std::error::Error + Send + Sync>>,\n    {\n        // Rate limiting check\n        self.rate_limiter\n            .until_ready()\n            .await;\n\n        let full_url = format!(\"{}{}\", REST_BASE_URL, path);\n\n        let timestamp = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .unwrap()\n            .as_millis() as u64;\n\n        // Determine body string for signing\n        let body_bytes = match std::mem::replace(&mut body.into_eof(), true) {\n            true => String::new(), // Hacky check, normally we'd buffer. For Lighter GET body is empty.\n            false => {\n                // Since we can't easily extract generic Body bytes without consuming,\n                // we assume GET/DELETE empty, POST/PUT known.\n                // We will pass explicit string to helper methods.\n                String::new()\n            }\n        };\n\n        // Since hyper body consumption is tricky before sending, we restructure request building\n        // to expect explicit body string for signing logic separation.\n        // This method is generic, but signing needs the body content.\n        // We'll implement specific verbs to handle this cleanly.\n        Err(LighterError::ConfigError(\n            \"Use specific methods (get/post)\".to_string(),\n        ))\n    }\n\n    pub async fn get(&self, path: &str, query: Option<&str>) -> Result<String> {\n        let req_path = if let Some(q) = query {\n            format!(\"{}?{}\", path, q)\n        } else {\n            path.to_string()\n        };\n        self.execute(\"GET\", &req_path, \"\").await\n    }\n\n    pub async fn post(&self, path: &str, body_json: &str) -> Result<String> {\n        self.execute(\"POST\", path, body_json).await\n    }\n\n    async fn execute(&self, method: &str, path: &str, body_str: &str) -> Result<String> {\n        let timestamp = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .unwrap()\n            .as_millis() as u64;\n\n        let signature = generate_signature(&self.config, timestamp, method, path, body_str)?;\n\n        let full_uri = format!(\"{}{}\", REST_BASE_URL, path);\n        let uri = full_uri.parse().map_err(|e| LighterError::ConfigError(format!(\"Invalid URI: {}\", e)))?;\n\n        let mut req_builder = Request::builder()\n            .method(method)\n            .uri(uri)\n            .header(\"content-type\", \"application/json\")\n            .header(HEADER_CHAIN_ID, &self.config.chain_id)\n            .header(HEADER_TIMESTAMP, timestamp.to_string())\n            .header(HEADER_SIGNATURE, signature);\n\n        if let Some(api_key) = &self.config.api_key {\n            req_builder = req_builder.header(HEADER_API_KEY, api_key);\n        }\n\n        let req = if body_str.is_empty() {\n            req_builder.body(Body::empty())?\n        } else {\n            req_builder.body(Body::from(body_str.to_owned()))?\n        };\n\n        let mut resp = self.client.request(req).await?;\n\n        let status = resp.status();\n        let body_bytes = hyper::body::collect(resp.into_body())\n            .await?\n            .to_bytes();\n\n        let response_str = String::from_utf8(body_bytes.to_vec())\n            .map_err(|e| LighterError::JsonError(serde_json::Error::custom(e)))?;\n\n        if !status.is_success() {\n            // Attempt to parse API error\n            if let Ok(api_err) = serde_json::from_str::<serde_json::Value>(&response_str) {\n                return Err(LighterError::ApiError {\n                    code: status.as_u16() as i32,\n                    message: api_err[\"message\"].as_str().unwrap_or(\"Unknown error\").to_string(),\n                });\n            }\n            return Err(LighterError::HttpError(hyper::Error::new(\n                format!(\"HTTP {} error: {}\", status, response_str).as_str(),\n            )));\n        }\n\n        Ok(response_str)\n    }\n}",
    "parsing/models.rs": "//! NautilusTrader Adapter - Lighter Models\n\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Ticker {\n    pub symbol: String,\n    #[serde(rename = \"lastPrice\")]\n    pub last_price: String,\n    pub volume: String,\n    #[serde(rename = \"priceStep\")]\n    pub price_step: String,\n    #[serde(rename = \"sizeStep\")]\n    pub size_step: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OrderBookLevel {\n    pub price: String,\n    pub quantity: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OrderBook {\n    pub asks: Vec<OrderBookLevel>,\n    pub bids: Vec<OrderBookLevel>,\n    pub timestamp: i64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct OrderRequest {\n    #[serde(rename = \"chainId\")]\n    pub chain_id: String,\n    pub symbol: String,\n    pub side: String, // \"BUY\" or \"SELL\"\n    #[serde(rename = \"type\")]\n    pub order_type: String, // \"LIMIT\" or \"MARKET\"\n    pub price: String,\n    pub quantity: String,\n    #[serde(rename = \"clientOrderId\")]\n    pub client_order_id: String,\n    #[serde(rename = \"tif\")]\n    pub time_in_force: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OrderResponse {\n    #[serde(rename = \"orderId\")]\n    pub order_id: String,\n    pub status: String,\n    pub symbol: String,\n}\n\n// WebSocket Messages\n\n#[derive(Debug, Clone, Deserialize)]\n#[serde(tag = \"channel\", content = \"data\")]\npub enum WsResponse {\n    #[serde(rename = \"orderbook\")]\n    OrderBook(OrderBook),\n    #[serde(rename = \"trades\")]\n    Trades(Vec<Trade>),\n    #[serde(rename = \"orderUpdate\")]\n    OrderUpdate(OrderUpdate),\n    #[serde(rename = \"account\")]\n    Account(AccountUpdate),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Trade {\n    pub id: String,\n    pub price: String,\n    pub quantity: String,\n    pub side: String,\n    pub timestamp: i64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OrderUpdate {\n    #[serde(rename = \"orderId\")]\n    pub order_id: String,\n    pub symbol: String,\n    pub status: String,\n    pub price: String,\n    pub filled_qty: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AccountUpdate {\n    pub balances: Vec<Balance>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Balance {\n    pub asset: String,\n    pub free: String,\n    pub locked: String,\n}\n",
    "websocket/client.rs": "//! NautilusTrader Adapter - Lighter WebSocket Client\n\nuse crate::common::consts::WS_HEARTBEAT_INTERVAL_SEC;\nuse crate::config::LighterConfig;\nuse crate::error::{LighterError, Result};\nuse crate::http::signing::generate_signature;\nuse crate::parsing::models::WsResponse;\nuse futures_util::{SinkExt, StreamExt};\nuse serde_json::{json, Value};\nuse std::time::SystemTime;\nuse tokio::time::{interval, Duration};\nuse tokio_tungstenite::{connect_async, tungstenite::Message};\n\npub struct LighterWebSocketClient {\n    config: LighterConfig,\n}\n\nimpl LighterWebSocketClient {\n    pub fn new(config: LighterConfig) -> Self {\n        Self { config }\n    }\n\n    pub async fn connect_and_run<F>(\n        &self,\n        subscription_message: Value,\n        mut callback: F,\n    ) -> Result<()>\n    where\n        F: FnMut(WsResponse) + Send + 'static,\n    {\n        let url = \"wss://api.lighter.xyz/ws\";\n        let (ws_stream, _) = connect_async(url)\n            .await\n            .map_err(|e| LighterError::WsError(e.to_string()))?;\n\n        let (mut write, mut read) = ws_stream.split();\n\n        // Authenticate if API key is present\n        if let (Some(key), Some(secret)) = (&self.config.api_key, &self.config.api_secret) {\n            let timestamp = SystemTime::now()\n                .duration_since(SystemTime::UNIX_EPOCH)\n                .unwrap()\n                .as_millis() as u64;\n            \n            // Sign: timestamp + \"CONNECT\" + \"/\" + \"\" (based on standard auth flow, or empty payload)\n            // Assuming auth requires a signed message payload.\n            // Constructing a generic auth message struct based on DEX norms.\n            let signature = generate_signature(&self.config, timestamp, \"CONNECT\", \"/\", \"\")?;\n            \n            let auth_msg = json!(\n                {\n                    \"method\": \"AUTH\",\n                    \"params\": {\n                        \"apiKey\": key,\n                        \"timestamp\": timestamp,\n                        \"signature\": signature,\n                        \"chainId\": self.config.chain_id\n                    }\n                }\n            );\n\n            write\n                .send(Message::Text(auth_msg.to_string()))\n                .await\n                .map_err(|e| LighterError::WsError(e.to_string()))?;\n        }\n\n        // Send initial subscription\n        write\n            .send(Message::Text(subscription_message.to_string()))\n            .await\n            .map_err(|e| LighterError::WsError(e.to_string()))?;\n\n        // Heartbeat task\n        let mut write_clone = write;\n        let heartbeat_task = tokio::spawn(async move {\n            let mut interval = interval(Duration::from_secs(WS_HEARTBEAT_INTERVAL_SEC));\n            loop {\n                interval.tick().await;\n                // Standard ping frame\n                if write_clone.send(Message::Ping(vec![])).await.is_err() {\n                    break;\n                }\n            }\n        });\n\n        // Read loop\n        while let Some(msg) = read.next().await {\n            match msg {\n                Ok(Message::Text(text)) => {\n                    if let Ok(json_val) = serde_json::from_str::<Value>(&text) {\n                        // Try to parse into known models\n                        if let Ok(parsed) = serde_json::from_value::<WsResponse>(json_val.clone()) {\n                            callback(parsed);\n                        } else {\n                            // Handle raw logs or unknown messages if necessary\n                            log::debug!(\"Unknown WS message: {}\", json_val);\n                        }\n                    }\n                }\n                Ok(Message::Pong(_)) => {\n                    // Pong received, connection alive\n                }\n                Err(e) => {\n                    log::error!(\"WS Error: {}\", e);\n                    break;\n                }\n                _ => {}\n            }\n        }\n\n        heartbeat_task.abort();\n        Ok(())\n    }\n}",
    "python/mod.rs": "//! NautilusTrader Adapter - Python Bindings (PyO3)\n\nuse crate::common::urls::Endpoints;\nuse crate::config::LighterConfig;\nuse crate::http::client::LighterHttpClient;\nuse crate::parsing::models::{OrderBook, OrderRequest, OrderResponse, Ticker};\nuse pyo3::prelude::*;\nuse pyo3::types::PyDict;\n\n/// Python wrapper for the Lighter Client\n#[pyclass(name = \"LighterClient\")]\npub struct PyLighterClient {\n    client: LighterHttpClient,\n}\n\n#[pymethods]\nimpl PyLighterClient {\n    #[new]\n    #[pyo3(signature = (chain_id, api_key, api_secret))]\n    pub fn new(chain_id: String, api_key: String, api_secret: String) -> PyResult<Self> {\n        let config = LighterConfig::new(chain_id, api_key, api_secret);\n        Ok(Self {\n            client: LighterHttpClient::new(config),\n        })\n    }\n\n    /// Fetch tickers for a given chain ID\n    pub fn get_tickers(&self, py: Python) -> PyResult<Vec<PyObject>> {\n        let path = Endpoints::tickers();\n        py.allow_threads(|| {\n            let runtime = tokio::runtime::Runtime::new().unwrap();\n            let json_str = runtime.block_on(self.client.get(&path, Some(&\"chainId=137\".to_string())))?; // Example query param\n            let tickers: Vec<Ticker> = serde_json::from_str(&json_str)?;\n            \n            let py_list = tickers.into_iter().map(|t| {\n                Python::with_gil(|py| {\n                    let dict = PyDict::new(py);\n                    dict.set_item(\"symbol\", t.symbol).unwrap();\n                    dict.set_item(\"lastPrice\", t.last_price).unwrap();\n                    dict.set_item(\"volume\", t.volume).unwrap();\n                    dict.into()\n                })\n            }).collect();\n            Ok(py_list)\n        })\n    }\n\n    /// Fetch orderbook\n    pub fn get_orderbook(&self, py: Python, symbol: String) -> PyResult<PyObject> {\n        let path = Endpoints::orderbook();\n        py.allow_threads(|| {\n            let runtime = tokio::runtime::Runtime::new().unwrap();\n            let query = format!(\"chainId=137&symbol={}\", symbol);\n            let json_str = runtime.block_on(self.client.get(&path, Some(&query)))?;\n            let orderbook: OrderBook = serde_json::from_str(&json_str)?;\n            \n            Python::with_gil(|py| {\n                let dict = PyDict::new(py);\n                dict.set_item(\"asks\", orderbook.asks).unwrap();\n                dict.set_item(\"bids\", orderbook.bids).unwrap();\n                dict.set_item(\"timestamp\", orderbook.timestamp).unwrap();\n                Ok(dict.into())\n            })\n        })\n    }\n\n    /// Create an order\n    pub fn create_order(\n        &self,\n        py: Python,\n        symbol: String,\n        side: String,\n        order_type: String,\n        price: String,\n        quantity: String,\n        client_order_id: String,\n    ) -> PyResult<String> {\n        let path = Endpoints::order();\n        let order_req = OrderRequest {\n            chain_id: \"137\".to_string(), // Assuming Polygon for simplicity in Python binding\n            symbol,\n            side,\n            order_type,\n            price,\n            quantity,\n            client_order_id,\n            time_in_force: \"GTC\".to_string(),\n        };\n        \n        let body = serde_json::to_string(&order_req)?;\n        \n        py.allow_threads(|| {\n            let runtime = tokio::runtime::Runtime::new().unwrap();\n            let json_str = runtime.block_on(self.client.post(&path, &body))?;\n            let resp: OrderResponse = serde_json::from_str(&json_str)?;\n            Ok(resp.order_id)\n        })\n    }\n}",
    "python/urls.rs": "//! NautilusTrader Adapter - Python URL Helpers\n\nuse pyo3::prelude::*;\n\n#[pyfunction]\npub fn get_rest_base_url() -> String {\n    crate::common::urls::REST_BASE_URL.to_string()\n}\n\n#[pyfunction]\npub fn get_ws_base_url() -> String {\n    crate::common::urls::WS_BASE_URL.to_string()\n}\n\n#[pymodule]\nfn _lighter_urls(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_function(wrap_pyfunction!(get_rest_base_url, m)?)?;\n    m.add_function(wrap_pyfunction!(get_ws_base_url, m)?)?;\n    Ok(())\n}"
  }
}
```