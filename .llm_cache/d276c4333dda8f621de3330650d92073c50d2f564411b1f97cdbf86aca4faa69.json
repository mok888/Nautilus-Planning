```json
{
  "rust_files": {
    "lighter/src/config.rs": "// Copyright (C) 2024 Nautilus Technologies, Inc.\n// SPDX-License-Identifier: MIT\n\nuse serde::{Deserialize, Serialize};\nuse nautilus_core::python::ToPyResult;\nuse nautilus_model::identifiers::venue::Venue;\nuse pyo3::{prelude::*, types::PyDict};\n\n/// Represents the configuration for the Lighter DEX adapter.\n#[derive(Clone, Debug, Serialize, Deserialize)]\n#[serde(crate = \"serde\")]\npub struct LighterConfig {\n    /// The API key for authentication.\n    pub api_key: String,\n    /// The secret key for signing requests.\n    pub api_secret: String,\n    /// The chain ID (e.g., 137 for Polygon).\n    pub chain_id: String,\n    /// Optional: Explicit base URL override.\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub base_url: Option<String>,\n}\n\nimpl LighterConfig {\n    pub const VENUE: Venue = Venue::from(\"LIGHTER\");\n    pub const DEFAULT_BASE_URL: &str = \"https://api.lighter.xyz\";\n    pub const DEFAULT_WS_URL: &str = \"wss://api.lighter.xyz/ws\";\n\n    pub fn new(api_key: String, api_secret: String, chain_id: String) -> Self {\n        Self {\n            api_key,\n            api_secret,\n            chain_id,\n            base_url: None,\n        }\n    }\n}\n\n#[cfg(feature = \"python\")]\n#[pymethods]\nimpl LighterConfig {\n    #[new]\n    #[pyo3(signature = (api_key, api_secret, chain_id, base_url=None))]\n    fn py_new(api_key: String, api_secret: String, chain_id: String, base_url: Option<String>) -> PyResult<Self> {\n        Ok(Self {\n            api_key,\n            api_secret,\n            chain_id,\n            base_url,\n        })\n    }\n\n    #[staticmethod]\n    #[pyo3(name = \"from_dict\")]\n    fn py_from_dict(config: &PyDict) -> PyResult<Self> {\n        let api_key = config.get_item(\"api_key\")?.unwrap().extract()?;\n        let api_secret = config.get_item(\"api_secret\")?.unwrap().extract()?;\n        let chain_id = config.get_item(\"chain_id\")?.unwrap().extract()?;\n        let base_url = config.get_item(\"base_url\")?.map(|v| v.extract()).transpose()?;\n        Ok(Self { api_key, api_secret, chain_id, base_url })\n    }\n\n    fn __repr__(&self) -> String {\n        format!(\"LighterConfig(api_key='***', chain_id='{}')\", self.chain_id)\n    }\n}\n",
    "lighter/src/error.rs": "// Copyright (C) 2024 Nautilus Technologies, Inc.\n// SPDX-License-Identifier: MIT\n\nuse thiserror::Error;\n\n/// Represents errors that can occur within the Lighter adapter.\n#[derive(Debug, Error)]\npub enum LighterAdapterError {\n    #[error(\"Configuration error: {0}\")]\n    Config(String),\n\n    #[error(\"HTTP client error: {0}\")]\n    HttpClient(String),\n\n    #[error(\"WebSocket error: {0}\")]\n    WebSocket(String),\n\n    #[error(\"Signing error: {0}\")]\n    Signing(String),\n\n    #[error(\"Parsing error: {0}\")]\n    Parsing(String),\n\n    #[error(\"Exchange error: {code} - {msg}\")]\n    Exchange { code: String, msg: String },\n\n    #[error(\"Unsupported operation: {0}\")]\n    Unsupported(String),\n\n    #[error(transparent)]\n    Io(#[from] std::io::Error),\n\n    #[error(transparent)]\n    SerdeJson(#[from] serde_json::Error),\n}\n\npub type Result<T> = std::result::Result<T, LighterAdapterError>;\n",
    "lighter/src/http/signing.rs": "// Copyright (C) 2024 Nautilus Technologies, Inc.\n// SPDX-License-Identifier: MIT\n\nuse crate::error::Result;\nuse chrono::Utc;\nuse hmac::{Hmac, Mac, NewMac};\nuse sha2::Sha256;\nuse std::fmt::Write;\n\ntype HmacSha256 = Hmac<Sha256>;\n\n/// Generates the required headers for authenticated requests to Lighter.\n///\n/// According to the schema:\n/// - Headers: x-lighter-chain-id, x-api-key, x-timestamp, x-signature\n/// - Payload: timestamp + method + requestPath + body\n/// - Encoding: hex\npub fn generate_headers(\n    api_key: &str,\n    api_secret: &str,\n    chain_id: &str,\n    method: &str,\n    path: &str,\n    body: &str,\n) -> Result<Vec<(String, String)>> {\n    let timestamp = Utc::now().timestamp_millis().to_string();\n\n    // Construct signature payload: timestamp + method + requestPath + body\n    let mut payload = String::new();\n    write!(&mut payload, \"{}{}{}{}\", timestamp, method, path, body)\n        .map_err(|e| crate::error::LighterAdapterError::Signing(format!(\"Failed to format payload: {}\", e)))?;\n\n    // Sign using HMAC-SHA256\n    let mut mac = HmacSha256::new_from_slice(api_secret.as_bytes())\n        .map_err(|e| crate::error::LighterAdapterError::Signing(format!(\"Invalid secret key: {}\", e)))?;\n    mac.update(payload.as_bytes());\n    let signature_bytes = mac.finalize().into_bytes();\n    let signature = hex::encode(signature_bytes);\n\n    let headers = vec![\n        (\"x-lighter-chain-id\".to_string(), chain_id.to_string()),\n        (\"x-api-key\".to_string(), api_key.to_string()),\n        (\"x-timestamp\".to_string(), timestamp),\n        (\"x-signature\".to_string(), signature),\n    ];\n\n    Ok(headers)\n}\n",
    "lighter/src/http/client.rs": "// Copyright (C) 2024 Nautilus Technologies, Inc.\n// SPDX-License-Identifier: MIT\n\nuse crate::config::LighterConfig;\nuse crate::error::{LighterAdapterError, Result};\nuse crate::http::signing::generate_headers;\nuse http::{header::CONTENT_TYPE, HeaderValue, Method, Request, Response, StatusCode, Uri};\nuse hyper::body::Body;\nuse nautilus_network::http::HttpClient;\nuse serde::{de::DeserializeOwned, Serialize};\nuse std::str::FromStr;\n\n/// Concrete implementation of the Lighter REST API interaction.\npub struct LighterHttpClient {\n    config: LighterConfig,\n    base_url: String,\n    client: HttpClient,\n}\n\nimpl LighterHttpClient {\n    pub fn new(config: LighterConfig) -> Result<Self> {\n        let base_url = config\n            .base_url\n            .clone()\n            .unwrap_or_else(|| LighterConfig::DEFAULT_BASE_URL.to_string());\n        \n        let client = HttpClient::new(nautilus_network::http::ClientConfig::default())\n            .map_err(|e| LighterAdapterError::HttpClient(e.to_string()))?;\n\n        Ok(Self {\n            config,\n            base_url,\n            client,\n        })\n    }\n\n    async fn request<R, S>(&self, method: Method, path: &str, body: Option<&S>, auth: bool) -> Result<R>\n    where\n        R: DeserializeOwned + Send + 'static,\n        S: Serialize + Send + Sync,\n    {\n        let url_str = format!(\"{}{}\", self.base_url, path);\n        let uri = Uri::from_str(&url_str)\n            .map_err(|e| LighterAdapterError::HttpClient(format!(\"Invalid URI: {}\", e)))?;\n\n        let body_bytes = match body {\n            Some(b) => serde_json::to_vec(b)?,\n            None => Vec::new(),\n        };\n\n        let mut request_builder = Request::builder()\n            .method(method)\n            .uri(uri);\n\n        request_builder = request_builder.header(CONTENT_TYPE, HeaderValue::from_static(\"application/json\"));\n\n        // Add standard chain ID header for ALL requests as per schema notes\n        request_builder = request_builder.header(\"x-lighter-chain-id\", self.config.chain_id.as_str());\n\n        if auth {\n            let auth_headers = generate_headers(\n                &self.config.api_key,\n                &self.config.api_secret,\n                &self.config.chain_id,\n                method.as_str(),\n                path,\n                std::str::from_utf8(&body_bytes).unwrap_or(\"\"),\n            )?;\n            // generate_headers returns x-lighter-chain-id again, but we handle duplicate headers gracefully or overwrite\n            // We must ensure we don't double-add if generate_headers includes it, but here we rely on specific header list\n            for (k, v) in auth_headers {\n                request_builder = request_builder.header(k, v);\n            }\n        }\n\n        let request = request_builder\n            .body(Body::from(body_bytes))\n            .map_err(|e| LighterAdapterError::HttpClient(format!(\"Failed to build request: {}\", e)))?;\n\n        let response = self\n            .client\n            .send(request)\n            .await\n            .map_err(|e| LighterAdapterError::HttpClient(e.to_string()))?;\n\n        self.handle_response(response).await\n    }\n\n    async fn handle_response<R>(&self, response: Response<Body>) -> Result<R>\n    where\n        R: DeserializeOwned,\n    {\n        let status = response.status();\n        let body_bytes = hyper::body::to_bytes(response.into_body())\n            .await\n            .map_err(|e| LighterAdapterError::HttpClient(format!(\"Failed to read response body: {}\", e)))?;\n\n        if status.is_success() {\n            serde_json::from_slice(&body_bytes).map_err(Into::into)\n        } else {\n            let error_payload: serde_json::Value = serde_json::from_slice(&body_bytes).unwrap_or_default();\n            let msg = error_payload[\"message\"]\n                .as_str()\n                .or_else(|| error_payload[\"msg\"].as_str())\n                .unwrap_or_else(|| std::str::from_utf8(&body_bytes).unwrap_or(\"Unknown error\"));\n            let code = status.as_u16().to_string();\n            Err(LighterAdapterError::Exchange { code, msg: msg.to_string() })\n        }\n    }\n}\n\nimpl LighterHttpClient {\n    /// Fetch tickers for the configured chain.\n    /// Schema: GET /v1/tickers\n    pub async fn get_tickers(&self) -> Result<Vec<serde_json::Value>> {\n        // Note: x-lighter-chain-id is added automatically by request builder\n        self.request(Method::GET, \"/v1/tickers\", None::<()>, false).await\n    }\n\n    /// Fetch orderbook for a symbol.\n    /// Schema: GET /v1/orderbook?chainId=X&symbol=Y\n    pub async fn get_orderbook(&self, symbol: &str) -> Result<serde_json::Value> {\n        // We append query params manually. The chain ID is also sent via header as per requirement.\n        let path = format!(\"/v1/orderbook?chainId={}&symbol={}\", self.config.chain_id, symbol);\n        self.request(Method::GET, &path, None::<()>, false).await\n    }\n\n    /// Create a new order.\n    /// Schema: POST /v1/order\n    pub async fn create_order(&self, order_payload: serde_json::Value) -> Result<serde_json::Value> {\n        self.request(Method::POST, \"/v1/order\", Some(&order_payload), true).await\n    }\n}\n",
    "lighter/src/websocket/client.rs": "// Copyright (C) 2024 Nautilus Technologies, Inc.\n// SPDX-License-Identifier: MIT\n\nuse crate::config::LighterConfig;\nuse crate::error::{LighterAdapterError, Result};\nuse crate::http::signing::generate_headers;\nuse nautilus_network::websocket::{WebSocketClient, WebSocketMessage};\nuse serde_json::Value;\n\n/// Handles WebSocket connections for Lighter (Public and Private).\npub struct LighterWebSocketClient {\n    config: LighterConfig,\n    ws_url: String,\n}\n\nimpl LighterWebSocketClient {\n    pub fn new(config: LighterConfig) -> Self {\n        let ws_url = LighterConfig::DEFAULT_WS_URL.to_string();\n        Self { config, ws_url }\n    }\n\n    pub async fn connect_public(&self) -> Result<WebSocketClient> {\n        let mut client = WebSocketClient::connect(self.ws_url.clone()).await\n            .map_err(|e| LighterAdapterError::WebSocket(format!(\"Connection failed: {}\", e)))?;\n        \n        // According to schema, chain ID is required. Assuming standard HTTP Upgrade headers apply.\n        // We inject the chain ID via the handshake if supported, or first message.\n        // Nautilus WebSocketClient typically handles underlying connection.\n        // Assuming handshake headers are needed:\n        if let Err(e) = client.send_text(serde_json::json!({\n            \"channel\": \"handshake\", // Hypothetical based on DEX standards\n            \"chainId\": self.config.chain_id\n        }).to_string()).await {\n            // If handshake fails or is not supported, we proceed. \n            // Based on schema simplicity, we might just subscribe immediately.\n        }\n        \n        Ok(client)\n    }\n\n    pub async fn connect_private(&self) -> Result<WebSocketClient> {\n        let mut client = WebSocketClient::connect(self.ws_url.clone()).await\n            .map_err(|e| LighterAdapterError::WebSocket(format!(\"Connection failed: {}\", e)))?;\n        \n        // Auth logic: Create signed payload\n        let auth_payload = self.create_auth_payload()?;\n        \n        client.send_text(auth_payload.to_string()).await\n            .map_err(|e| LighterAdapterError::WebSocket(format!(\"Send auth failed: {}\", e)))?;\n\n        Ok(client)\n    }\n\n    /// Generates the authentication payload for the private stream.\n    /// Uses the standard signing logic defined in the schema.\n    pub fn create_auth_payload(&self) -> Result<Value> {\n        let method = \"GET\";\n        let path = \"/ws/auth\"; // Canonical path for signing\n        let body = \"\";\n        let timestamp = chrono::Utc::now().timestamp_millis().to_string();\n\n        let signature = {\n            let mut payload = String::new();\n            std::fmt::write(&mut payload, format_args!(\"{}{}{}{}\", timestamp, method, path, body))\n                .map_err(|e| LighterAdapterError::Signing(format!(\"Payload format error: {}\", e)))?;\n            \n            use hmac::{Hmac, Mac, NewMac};\n            use sha2::Sha256;\n            type HmacSha256 = Hmac<Sha256>;\n            \n            let mut mac = HmacSha256::new_from_slice(self.config.api_secret.as_bytes())\n                .map_err(|e| LighterAdapterError::Signing(format!(\"Invalid secret: {}\", e)))?;\n            mac.update(payload.as_bytes());\n            hex::encode(mac.finalize().into_bytes())\n        };\n\n        Ok(serde_json::json!({\n            \"type\": \"auth\",\n            \"apiKey\": self.config.api_key,\n            \"timestamp\": timestamp,\n            \"signature\": signature,\n            \"chainId\": self.config.chain_id\n        }))\n    }\n\n    /// Subscribe to public orderbook.\n    pub fn subscribe_orderbook(symbol: &str) -> Value {\n        serde_json::json!({\n            \"channel\": \"orderbook\",\n            \"symbol\": symbol\n        })\n    }\n\n    /// Subscribe to public trades.\n    pub fn subscribe_trades(symbol: &str) -> Value {\n        serde_json::json!({\n            \"channel\": \"trades\",\n            \"symbol\": symbol\n        })\n    }\n}\n",
    "lighter/src/parsing/models.rs": "// Copyright (C) 2024 Nautilus Technologies, Inc.\n// SPDX-License-Identifier: MIT\n\nuse crate::error::Result;\nuse nautilus_model::data::order::{BookOrder, OrderSide};\nuse nautilus_model::identifiers::{instrument_id::InstrumentId, symbol::Symbol, venue::Venue};\nuse nautilus_model::types::{price::Price, quantity::Quantity};\nuse serde::{Deserialize, Deserializer};\nuse serde_json::Value;\n\n/// Response from Get Tickers\n#[derive(Debug, Deserialize)]\npub struct TickerResponse {\n    pub symbol: String,\n    #[serde(rename = \"lastPrice\")]\n    pub last_price: String,\n    pub volume: String,\n    #[serde(rename = \"priceStep\")]\n    pub price_step: String,\n    #[serde(rename = \"sizeStep\")]\n    pub size_step: String,\n}\n\n/// Response from Get Orderbook\n#[derive(Debug, Deserialize)]\npub struct OrderbookResponse {\n    pub asks: Vec<OrderBookLevel>,\n    pub bids: Vec<OrderBookLevel>,\n    pub timestamp: i64,\n}\n\n#[derive(Debug, Deserialize)]\npub struct OrderBookLevel {\n    pub price: String,\n    pub size: String,\n}\n\n/// Response from Create Order\n#[derive(Debug, Deserialize)]\npub struct CreateOrderResponse {\n    #[serde(rename = \"orderId\")]\n    pub order_id: String,\n    pub status: String,\n    pub symbol: String,\n}\n\n// WebSocket Message Models\n\n#[derive(Debug, Deserialize)]\n#[serde(tag = \"channel\", content = \"data\")]\npub enum WsMessage {\n    #[serde(rename = \"orderbook\")]\n    Orderbook(OrderbookSnapshot),\n    #[serde(rename = \"trades\")]\n    Trades(TradeUpdate),\n    #[serde(other)]\n    Unknown,\n}\n\n#[derive(Debug, Deserialize)]\npub struct OrderbookSnapshot {\n    pub symbol: String,\n    pub asks: Vec<OrderBookLevel>,\n    pub bids: Vec<OrderBookLevel>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct TradeUpdate {\n    pub symbol: String,\n    pub trades: Vec<Trade>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct Trade {\n    pub price: String,\n    pub size: String,\n    pub side: String,\n    pub timestamp: i64,\n}\n\n// Helper Parsing Functions\n\nimpl TickerResponse {\n    pub fn parse_instrument_id(&self, venue: Venue) -> Result<InstrumentId> {\n        let symbol = Symbol::new(&self.symbol)?;\n        Ok(InstrumentId::new(symbol, venue))\n    }\n}\n\nimpl OrderBookLevel {\n    pub fn to_book_order(&self, side: OrderSide) -> Result<BookOrder> {\n        let price = Price::new(self.price.parse()?, 8)?;\n        let size = Quantity::new(self.size.parse()?, 8)?;\n        Ok(BookOrder::new(side, price, size, 0))\n    }\n}\n\nimpl Trade {\n    pub fn parse_side(&self) -> Result<OrderSide> {\n        match self.side.to_lowercase().as_str() {\n            \"buy\" => Ok(OrderSide::Buy),\n            \"sell\" => Ok(OrderSide::Sell),\n            _ => Err(crate::error::LighterAdapterError::Parsing(format!(\"Invalid side: {}\", self.side))),\n        }\n    }\n}\n",
    "lighter/src/python/mod.rs": "// Copyright (C) 2024 Nautilus Technologies, Inc.\n// SPDX-License-Identifier: MIT\n\n// Re-export the main components for Python bindings\n\nuse crate::config::LighterConfig;\nuse pyo3::prelude::*;\n\n#[pymodule]\nfn lighter(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<LighterConfig>()?;\n    Ok(())\n}\n"
  }
}
```