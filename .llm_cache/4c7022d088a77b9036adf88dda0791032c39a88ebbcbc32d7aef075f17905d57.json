```json
{
  "rust_files": {
    "src/lib.rs": "// Nado Exchange Adapter - NautilusTrader Core\n\npub mod common;\npub mod config;\npub mod error;\npub mod http;\npub mod parsing;\npub mod websocket;\n\n#[cfg(feature = \"python\")]\npub mod python;\n\npub use config::NadoConfig;\npub use error::NadoError;\n",
    "src/common/consts.rs": "//! Nado specific constants\n\n/// The exchange identifier for Nado\npub const EXCHANGE_ID: &str = \"NADO\";\n\n/// The exchange name\npub const EXCHANGE_NAME: &str = \"Nado\";\n\n/// API Key header name\npub const HEADER_API_KEY: &str = \"X-API-KEY\";\n\n/// Default API version\npub const API_VERSION: &str = \"v1\";\n",
    "src/common/urls.rs": "//! Nado API Endpoint URLs\n\n/// Base REST URL for Nado Mainnet\npub const REST_BASE_URL: &str = \"https://api.nado.xyz\";\n\n/// Base REST URL for Nado Testnet (Placeholder)\npub const REST_BASE_URL_TESTNET: &str = \"{{REST_URL_TESTNET}}\";\n\n/// Public WebSocket URL (Placeholder - Not defined in schema)\npub const WS_PUBLIC_URL: &str = \"{WS_PUBLIC_URL}\";\n\n/// Private WebSocket URL (Placeholder - Not defined in schema)\npub const WS_PRIVATE_URL: &str = \"{WS_PRIVATE_URL}\";\n\n/// Endpoint: Get Quote\npub const ENDPOINT_QUOTE: &str = \"/v1/quote\";\n\n/// Endpoint: Execute Swap\npub const ENDPOINT_SWAP: &str = \"/v1/swap\";\n",
    "src/config.rs": "use crate::common::consts::HEADER_API_KEY;\nuse crate::error::NadoError;\nuse nautilus_model::identifiers::AccountId;\nuse std::env;\n\n/// Configuration for the Nado adapter.\n#[derive(Debug, Clone)]\npub struct NadoConfig {\n    /// The API key for authentication.\n    pub api_key: String,\n    /// The API secret (placeholder if not used for signing, but standard in config).\n    pub api_secret: String,\n    /// The base URL for the REST API.\n    pub rest_base_url: String,\n}\n\nimpl NadoConfig {\n    /// Creates a new configuration instance from environment variables.\n    ///\n    /// # Errors\n    /// Fails if `Nado_API_KEY` or `Nado_API_SECRET` are not set.\n    pub fn from_env() -> Result<Self, NadoError> {\n        let api_key = env::var(\"Nado_API_KEY\")\n            .map_err(|_| NadoError::Configuration(\"Nado_API_KEY not found\".into()))?;\n        let api_secret = env::var(\"Nado_API_SECRET\")\n            .map_err(|_| NadoError::Configuration(\"Nado_API_SECRET not found\".into()))?;\n\n        Ok(Self {\n            api_key,\n            api_secret,\n            rest_base_url: \"https://api.nado.xyz\".to_string(), // Default mainnet\n        })\n    }\n\n    /// Creates a new configuration instance with explicit values.\n    pub fn new(api_key: String, api_secret: String, rest_base_url: String) -> Self {\n        Self {\n            api_key,\n            api_secret,\n            rest_base_url,\n        }\n    }\n}\n",
    "src/error.rs": "use thiserror::Error;\n\n/// The error type for Nado operations.\n#[derive(Debug, Error)]\npub enum NadoError {\n    #[error(\"HTTP error: {0}\")]\n    Http(String),\n\n    #[error(\"Serialization error: {0}\")]\n    Serialization(String),\n\n    #[error(\"Authentication error: {0}\")]\n    Authentication(String),\n\n    #[error(\"Configuration error: {0}\")]\n    Configuration(String),\n\n    #[error(\"Exchange error: {code} - {msg}\")]\n    Exchange { code: String, msg: String },\n}\n\nimpl From<serde_json::Error> for NadoError {\n    fn from(err: serde_json::Error) -> Self {\n        NadoError::Serialization(err.to_string())\n    }\n}\n\nimpl From<http::Error> for NadoError {\n    fn from(err: http::Error) -> Self {\n        NadoError::Http(err.to_string())\n    }\n}\n",
    "src/http/signing.rs": "use crate::common::consts::HEADER_API_KEY;\nuse http::HeaderMap;\n\n/// Signs the HTTP request by injecting the necessary headers.\n/// Nado currently uses a simple API Key mechanism via `X-API-KEY`.\npub fn sign_request(headers: &mut HeaderMap, api_key: &str) {\n    headers.insert(HEADER_API_KEY, api_key.parse().unwrap());\n}\n",
    "src/http/client.rs": "use crate::common::urls::{ENDPOINT_QUOTE, ENDPOINT_SWAP, REST_BASE_URL};\nuse crate::config::NadoConfig;\nuse crate::error::NadoError;\nuse crate::http::signing::sign_request;\nuse crate::parsing::models::{QuoteRequest, QuoteResponse, SwapRequest, SwapResponse};\nuse http::{header::CONTENT_TYPE, Method, Request, StatusCode, Uri};\nuse hyper::body::Bytes;\nuse nautilus_network::http::HttpClient;\nuse std::str::FromStr;\n\n/// HTTP client for interacting with the Nado REST API.\npub struct NadoHttpClient {\n    config: NadoConfig,\n    client: HttpClient,\n}\n\nimpl NadoHttpClient {\n    /// Creates a new `NadoHttpClient`.\n    pub fn new(config: NadoConfig, client: HttpClient) -> Self {\n        Self { config, client }\n    }\n\n    /// Helper to build and send a POST request.\n    async fn send_post<T, R>(&self, path: &str, payload: &T) -> Result<R, NadoError>\n    where\n        T: serde::Serialize,\n        R: for<'de> serde::Deserialize<'de>,\n    {\n        let url = format!(\"{}{}\", self.config.rest_base_url, path);\n        let uri = Uri::from_str(&url).map_err(|e| NadoError::Http(e.to_string()))?;\n\n        let body = serde_json::to_string(payload)?;\n\n        let mut request = Request::builder()\n            .method(Method::POST)\n            .uri(uri)\n            .header(CONTENT_TYPE, \"application/json\")\n            .body(body.clone().into())\n            .map_err(|e| NadoError::Http(e.to_string()))?;\n\n        // Sign the request with API Key\n        sign_request(request.headers_mut(), &self.config.api_key);\n\n        // Send request using the Nautilus Network HTTP client\n        let response = self.client.send(request).await?;\n\n        let status = response.status();\n        let body_bytes = response.into_body();\n        let body_vec = hyper::body::to_bytes(body_bytes).await.map_err(|e| NadoError::Http(e.to_string()))?;\n\n        if status.as_u16() >= 400 {\n            return Err(NadoError::Exchange {\n                code: status.as_u16().to_string(),\n                msg: String::from_utf8_lossy(&body_vec).to_string(),\n            });\n        }\n\n        serde_json::from_slice(&body_vec).map_err(Into::into)\n    }\n\n    /// Fetches a quote for a swap.\n    pub async fn get_quote(&self, req: &QuoteRequest) -> Result<QuoteResponse, NadoError> {\n        self.send_post(ENDPOINT_QUOTE, req).await\n    }\n\n    /// Executes a swap.\n    pub async fn execute_swap(&self, req: &SwapRequest) -> Result<SwapResponse, NadoError> {\n        self.send_post(ENDPOINT_SWAP, req).await\n    }\n}\n",
    "src/parsing/models.rs": "use serde::{Deserialize, Serialize};\n\n/// Request payload for fetching a quote.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct QuoteRequest {\n    pub src: String,\n    pub dst: String,\n    pub amount: String,\n    pub slippage: String, // Percentage as string, e.g., \"0.5\"\n}\n\n/// Response payload for a quote.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct QuoteResponse {\n    pub price: String,\n    pub gasPrice: String,\n    pub protocolFee: String,\n}\n\n/// Request payload for executing a swap.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SwapRequest {\n    pub quoteId: String,\n}\n\n/// Response payload for a swap execution.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SwapResponse {\n    pub encodedTx: String,\n    pub txHash: String,\n}\n",
    "src/websocket/client.rs": "use crate::common::urls::WS_PUBLIC_URL;\nuse crate::error::NadoError;\nuse futures_util::{SinkExt, StreamExt};\nuse tokio_tungstenite::tungstenite::protocol::Message;\n\n/// WebSocket client for Nado.\n/// Note: Nado is primarily an aggregator; real-time order book feeds\n/// might not be standard or are via specific protocols.\n/// This is a placeholder implementation adhering to the adapter standard.\npub struct NadoWebSocketClient {\n    url: String,\n}\n\nimpl NadoWebSocketClient {\n    pub fn new(url: Option<String>) -> Self {\n        Self {\n            url: url.unwrap_or_else(|| WS_PUBLIC_URL.to_string()),\n        }\n    }\n\n    /// Connects to the WebSocket.\n    pub async fn connect(&self) -> Result<(), NadoError> {\n        if self.url.contains(\"UNKNOWN\") || self.url.is_empty() {\n            return Err(NadoError::Configuration(\"WebSocket URL not supported\".into()));\n        }\n\n        let url_str = self.url.clone();\n        tokio::spawn(async move {\n            let (ws_stream, _) = tokio_tungstenite::connect_async(url_str)\n                .await\n                .expect(\"Failed to connect\");\n            let (mut write, mut read) = ws_stream.split();\n\n            // Example heartbeat loop\n            loop {\n                tokio::time::sleep(tokio::time::Duration::from_secs(30)).await;\n                write.send(Message::Ping(vec![])).await.unwrap();\n            }\n        });\n\n        Ok(())\n    }\n\n    /// Subscribes to a channel.\n    pub async fn subscribe(&self, _channel: &str) -> Result<(), NadoError> {\n        Err(NadoError::Configuration(\"Subscriptions not supported\".into()))\n    }\n}\n",
    "src/python/mod.rs": "use crate::config::NadoConfig;\nuse crate::http::client::NadoHttpClient;\nuse crate::parsing::models::{QuoteRequest, QuoteResponse, SwapRequest, SwapResponse};\nuse nautilus_common::live::get_runtime;\nuse pyo3::prelude::*;\nuse pyo3::types::PyDict;\n\n/// NautilusTrader Python bindings for the Nado adapter.\n#[pymodule]\nfn nado(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<PyNadoConfig>()?;\n    m.add_class::<PyNadoClient>()?;\n    Ok(())\n}\n\n#[pyclass(name = \"NadoConfig\")]\npub struct PyNadoConfig {\n    config: NadoConfig,\n}\n\n#[pymethods]\nimpl PyNadoConfig {\n    #[new]\n    fn new(api_key: String, api_secret: String, rest_base_url: Option<String>) -> Self {\n        let url = rest_base_url.unwrap_or_else(|| \"https://api.nado.xyz\".to_string());\n        Self {\n            config: NadoConfig::new(api_key, api_secret, url),\n        }\n    }\n}\n\n#[pyclass(name = \"NadoClient\")]\npub struct PyNadoClient {\n    client: NadoHttpClient,\n}\n\n#[pymethods]\nimpl PyNadoClient {\n    #[new]\n    fn new(config: &PyNadoConfig) -> PyResult<Self> {\n        let rt = get_runtime().map_err(|e| {\n            PyErr::new::<pyo3::exceptions::RuntimeError, _>(format!(\"Failed to get runtime: {}\", e))\n        })?;\n\n        let client = rt.block_on(async {\n            // Initialize HttpClient using Nautilus standards\n            let http_client = nautilus_network::http::HttpClient::new(); // Placeholder init logic\n            Ok(NadoHttpClient::new(config.config.clone(), http_client))\n        })?;\n\n        Ok(Self { client })\n    }\n\n    pub fn get_quote(&self, py: Python, req: QuoteRequest) -> PyResult<QuoteResponse> {\n        let rt = get_runtime().map_err(|e| {\n            PyErr::new::<pyo3::exceptions::RuntimeError, _>(format!(\"Failed to get runtime: {}\", e))\n        })?;\n\n        rt.block_on(py, async {\n            self.client.get_quote(&req).await.map_err(|e| {\n                PyErr::new::<pyo3::exceptions::PyException, _>(format!(\"Nado Error: {}\", e))\n            })\n        })\n    }\n\n    pub fn execute_swap(&self, py: Python, req: SwapRequest) -> PyResult<SwapResponse> {\n        let rt = get_runtime().map_err(|e| {\n            PyErr::new::<pyo3::exceptions::RuntimeError, _>(format!(\"Failed to get runtime: {}\", e))\n        })?;\n\n        rt.block_on(py, async {\n            self.client.execute_swap(&req).await.map_err(|e| {\n                PyErr::new::<pyo3::exceptions::PyException, _>(format!(\"Nado Error: {}\", e))\n            })\n        })\n    }\n}\n",
    "src/python/urls.rs": "// Python specific URL constants (if needed for direct exposure)\n\nuse pyo3::prelude::*;\n\n#[pyclass]\npub struct NadoUrls;\n\n#[pymethods]\nimpl NadoUrls {\n    #[staticmethod]\n    fn rest_base() -> String {\n        \"https://api.nado.xyz\".to_string()\n    }\n}\n"
  }
}
```