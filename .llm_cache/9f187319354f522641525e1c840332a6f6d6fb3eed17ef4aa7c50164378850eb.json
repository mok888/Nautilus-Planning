```json
{
  "python_files": {
    "config.py": "from nautilus_trader.config import LiveDataClientConfig, ExecClientConfig\n\n\nclass LighterConfig(LiveDataClientConfig, ExecClientConfig):\n    \"\"\"\n    Configuration for the Lighter exchange adapter.\n    \"\"\"\n    api_key: str\n    api_secret: str\n    chain_id: int  # Required header x-lighter-chain-id\n",
    "constants.py": "from nautilus_trader.model.identifiers import Venue\nfrom nautilus_trader.model.enums import OrderSide, OrderStatus, OrderType\n\nVENUE = Venue(\"LIGHTER\")\n\n# HTTP\nBASE_URL = \"https://api.lighter.xyz\"\nAPI_VERSION = \"v1\"\n\n# WebSocket\nWS_PUBLIC_URL = \"wss://api.lighter.xyz/ws\"\nWS_PRIVATE_URL = \"wss://api.lighter.xyz/ws\"\n\n# Headers\nHEADER_CHAIN_ID = \"x-lighter-chain-id\"\nHEADER_API_KEY = \"x-api-key\"\nHEADER_TIMESTAMP = \"x-timestamp\"\nHEADER_SIGNATURE = \"x-signature\"\n\n# REST Endpoints\nPATH_TICKERS = \"/v1/tickers\"\nPATH_ORDERBOOK = \"/v1/orderbook\"\nPATH_ORDER = \"/v1/order\"\n\n# WebSocket Channels\nCHANNEL_ORDERBOOK = \"orderbook\"\nCHANNEL_TRADES = \"trades\"\n\n# Mappings\nLIGHTER_ORDER_SIDES = {\n    \"BUY\": OrderSide.BUY,\n    \"SELL\": OrderSide.SELL,\n}\n\nNAUTILUS_ORDER_SIDES = {\n    OrderSide.BUY: \"BUY\",\n    OrderSide.SELL: \"SELL\",\n}\n\nLIGHTER_ORDER_TYPES = {\n    \"LIMIT\": OrderType.LIMIT,\n    \"MARKET\": OrderType.MARKET,\n}\n\nNAUTILUS_ORDER_TYPES = {\n    OrderType.LIMIT: \"LIMIT\",\n    OrderType.MARKET: \"MARKET\",\n}\n\nLIGHTER_ORDER_STATUSES = {\n    \"NEW\": OrderStatus.ACCEPTED,\n    \"PARTIALLY_FILLED\": OrderStatus.WORKING,\n    \"FILLED\": OrderStatus.FILLED,\n    \"CANCELLED\": OrderStatus.CANCELLED,\n    \"REJECTED\": OrderStatus.REJECTED,\n    \"EXPIRED\": OrderStatus.EXPIRED,\n}\n",
    "data.py": "import asyncio\nfrom typing import Optional\n\nfrom nautilus_trader.common.clock import LiveClock\nfrom nautilus_trader.common.enums import LogColor\nfrom nautilus_trader.core.data import Data\nfrom nautilus_trader.core.uuid import UUID4\nfrom nautilus_trader.live.data_client import LiveDataClient\nfrom nautilus_trader.model.data import OrderBookDeltas, TradeTick\nfrom nautilus_trader.model.enums import BookType\nfrom nautilus_trader.model.identifiers import InstrumentId\nfrom nautilus_trader.model.orderbook import OrderBook\n\nfrom nautilus_trader.adapters.lighter.constants import VENUE, WS_PUBLIC_URL\nfrom nautilus_trader.adapters.lighter.providers import LighterInstrumentProvider\nfrom nautilus_trader.adapters.lighter.websocket import LighterWebSocketClient\n\n\nclass LighterDataClient(LiveDataClient):\n    \"\"\"\n    Lighter Data Client (Spot).\n    \"\"\"\n\n    def __init__(\n        self,\n        config,\n        msgbus,\n        cache,\n        clock: LiveClock,\n        instrument_provider: LighterInstrumentProvider,\n    ) -> None:\n        super().__init__(\n            name=config.name,\n            venue=VENUE,\n            msgbus=msgbus,\n            cache=cache,\n            clock=clock,\n            config=config,\n        )\n        self._instrument_provider = instrument_provider\n        self._ws_client: Optional[LighterWebSocketClient] = None\n\n    def connect(self) -> None:\n        self._log.info(f\"Connecting {self.venue} DataClient...\")\n        self._ws_client = LighterWebSocketClient(\n            base_url=WS_PUBLIC_URL,\n            handler=self._handle_ws_message,\n            clock=self._clock,\n        )\n        self._create_task(self._ws_client.connect())\n\n    def disconnect(self) -> None:\n        self._log.info(f\"Disconnecting {self.venue} DataClient...\")\n        if self._ws_client:\n            self._ws_client.disconnect()\n\n    def _handle_ws_message(self, raw: str) -> None:\n        # Parse JSON and route to specific handlers\n        import json\n        msg = json.loads(raw)\n        # Logic to handle orderbook or trade updates\n        # This is a simplified structure for the example\n        channel = msg.get(\"channel\")\n        data = msg.get(\"data\")\n        \n        if channel == \"orderbook\" and data:\n            self._process_orderbook(data)\n        elif channel == \"trades\" and data:\n            self._process_trade(data)\n\n    def _process_orderbook(self, data: dict) -> None:\n        # Mapping data to Nautilus OrderBookDeltas\n        # Requires instrument resolution\n        pass\n\n    def _process_trade(self, data: dict) -> None:\n        # Mapping data to Nautilus TradeTick\n        pass\n\n    def subscribe_instruments(self) -> None:\n        pass  # Usually handled via REST polling in provider\n\n    def subscribe_order_book_deltas(self, instrument_id: InstrumentId) -> None:\n        if not self._ws_client or not self._ws_client.is_connected:\n            self._log.warning(\"Cannot subscribe: WebSocket not connected.\")\n            return\n        # Send subscription message\n        payload = {\n            \"op\": \"subscribe\",\n            \"channel\": \"orderbook\",\n            \"symbols\": [instrument_id.symbol.value], # Assuming format matches\n        }\n        self._ws_client.send_json(payload)\n\n    def subscribe_trade_ticks(self, instrument_id: InstrumentId) -> None:\n        if not self._ws_client or not self._ws_client.is_connected:\n            self._log.warning(\"Cannot subscribe: WebSocket not connected.\")\n            return\n        payload = {\n            \"op\": \"subscribe\",\n            \"channel\": \"trades\",\n            \"symbols\": [instrument_id.symbol.value],\n        }\n        self._ws_client.send_json(payload)\n",
    "execution.py": "import asyncio\nimport hmac\nimport hashlib\nfrom typing import Optional\n\nimport requests\nfrom decimal import Decimal\n\nfrom nautilus_trader.adapters.lighter.constants import (\n    BASE_URL,\n    HEADER_CHAIN_ID,\n    HEADER_API_KEY,\n    HEADER_TIMESTAMP,\n    HEADER_SIGNATURE,\n    PATH_ORDER,\n    VENUE,\n    LIGHTER_ORDER_STATUSES,\n    NAUTILUS_ORDER_SIDES,\n    NAUTILUS_ORDER_TYPES,\n)\nfrom nautilus_trader.adapters.lighter.factories import LighterInstrumentProvider\nfrom nautilus_trader.core.uuid import UUID4\nfrom nautilus_trader.execution.client import ExecutionClient\nfrom nautilus_trader.model.enums import OrderSide, OrderType, TimeInForce\nfrom nautilus_trader.model.events import OrderAccepted, OrderRejected, OrderFilled, OrderCanceled\nfrom nautilus_trader.model.identifiers import ClientOrderId, InstrumentId, OrderListId, PositionId, TradeId\nfrom nautilus_trader.model.orders import MarketOrder, LimitOrder\n\n\nclass LighterExecutionClient(ExecutionClient):\n    \"\"\"\n    Lighter Execution Client.\n    \"\"\"\n\n    def __init__(\n        self,\n        config,\n        msgbus,\n        cache,\n        clock,\n        instrument_provider: LighterInstrumentProvider,\n    ) -> None:\n        super().__init__(\n            name=config.name,\n            venue=VENUE,\n            msgbus=msgbus,\n            cache=cache,\n            clock=clock,\n            config=config,\n        )\n        self._api_key = config.api_key\n        self._api_secret = config.api_secret\n        self._chain_id = config.chain_id\n        self._instrument_provider = instrument_provider\n        self._session = requests.Session()\n\n    def connect(self) -> None:\n        self._log.info(f\"Connecting to {self.venue} Execution...\")\n        # In a real implementation, we might start a WebSocket private feed here\n        self._set_connected(True)\n\n    def disconnect(self) -> None:\n        self._log.info(f\"Disconnecting from {self.venue} Execution...\")\n        self._session.close()\n        self._set_connected(False)\n\n    def _generate_order_id(self) -> ClientOrderId:\n        return ClientOrderId(str(UUID4()))\n\n    def _sign(self, timestamp: str, method: str, path: str, body: str = \"\") -> str:\n        message = timestamp + method + path + body\n        mac = hmac.new(\n            self._api_secret.encode(\"utf-8\"),\n            message.encode(\"utf-8\"),\n            hashlib.sha256,\n        )\n        return mac.hexdigest()\n\n    def submit_order(self, order) -> None:\n        # Generate client order ID if not present\n        if order.client_order_id is None:\n            self._cache.add_order_order_id(\n                ClientOrderId(str(UUID4())),\n                VenueOrderId(None), # Unknown until ack\n                order,\n            )\n            # Logic to update the order with this ID locally\n            \n        self._log.info(f\"Submitting order {order.client_order_id} to {self.venue}.\")\n        self._create_task(self._submit_order_async(order))\n\n    async def _submit_order_async(self, order) -> None:\n        instrument = self._instrument_provider.find(order.instrument_id)\n        if not instrument:\n            self._log.error(f\"Instrument not found: {order.instrument_id}\")\n            return\n\n        side = NAUTILUS_ORDER_SIDES[order.side]\n        order_type = NAUTILUS_ORDER_TYPES[order.order_type]\n\n        body = {\n            \"chainId\": self._chain_id,\n            \"symbol\": instrument.symbol.value, # BASE-QUOTE\n            \"side\": side,\n            \"type\": order_type,\n            \"quantity\": str(order.quantity),\n            \"clientOrderId\": order.client_order_id.value,\n            \"tif\": \"GTC\" # Defaulting to GTC per schema note\n        }\n\n        if order.order_type == OrderType.LIMIT:\n            body[\"price\"] = str(order.price)\n\n        method = \"POST\"\n        timestamp = str(int(self._clock.timestamp_ms()))\n        path = PATH_ORDER\n        signature = self._sign(timestamp, method, path, str(body))\n\n        headers = {\n            HEADER_CHAIN_ID: str(self._chain_id),\n            HEADER_API_KEY: self._api_key,\n            HEADER_TIMESTAMP: timestamp,\n            HEADER_SIGNATURE: signature,\n            \"Content-Type\": \"application/json\",\n        }\n\n        try:\n            # Run sync request in thread pool or use aiohttp. Here using requests for clarity.\n            # In production Nautilus adapters, use HTTPClient.\n            response = await asyncio.to_thread(\n                self._session.post,\n                f\"{BASE_URL}{path}\",\n                json=body,\n                headers=headers,\n            )\n            response.raise_for_status()\n            result = response.json()\n            self._handle_order_submit_response(order, result)\n        except Exception as e:\n            self._log.error(f\"Error submitting order: {e}\")\n            # Emit OrderRejected\n            self._generate_order_rejected(\n                order,\n                reason=str(e),\n            )\n\n    def _handle_order_submit_response(self, order, response: dict) -> None:\n        status = response.get(\"status\")\n        exch_order_id = response.get(\"orderId\")\n\n        if status == \"NEW\":\n            self._cache._order_id_index[order.client_order_id] = exch_order_id\n            self._generate_order_accepted(order, VenueOrderId(exch_order_id) if exch_order_id else None)\n        else:\n            self._generate_order_rejected(order, reason=status)\n\n    def _generate_order_accepted(self, order, venue_order_id=None) -> None:\n        event = OrderAccepted(\n            trader_id=self.trader_id,\n            account_id=self.account_id,\n            client_order_id=order.client_order_id,\n            venue_order_id=venue_order_id,\n            venue=VENUE,\n            ts_event=self._clock.timestamp_ns(),\n        )\n        self._send_data_response(event)\n\n    def _generate_order_rejected(self, order, reason: str) -> None:\n        event = OrderRejected(\n            trader_id=self.trader_id,\n            account_id=self.account_id,\n            client_order_id=order.client_order_id,\n            reason=reason,\n            ts_event=self._clock.timestamp_ns(),\n        )\n        self._send_data_response(event)\n\n    def cancel_order(self, order) -> None:\n        # Assumed DELETE /v1/order endpoint based on REST API patterns\n        # and the presence of cancel_behavior in schema.\n        self._log.info(f\"Cancelling order {order.client_order_id}.\")\n        self._create_task(self._cancel_order_async(order))\n\n    async def _cancel_order_async(self, order) -> None:\n        instrument = self._instrument_provider.find(order.instrument_id)\n        body = {\n            \"chainId\": self._chain_id,\n            \"symbol\": instrument.symbol.value,\n            \"clientOrderId\": order.client_order_id.value,\n            # Might need orderId or both, assuming clientOrderId works based on Create schema\n        }\n\n        method = \"DELETE\"\n        timestamp = str(int(self._clock.timestamp_ms()))\n        path = PATH_ORDER # Assuming same path\n        signature = self._sign(timestamp, method, path, str(body))\n\n        headers = {\n            HEADER_CHAIN_ID: str(self._chain_id),\n            HEADER_API_KEY: self._api_key,\n            HEADER_TIMESTAMP: timestamp,\n            HEADER_SIGNATURE: signature,\n            \"Content-Type\": \"application/json\",\n        }\n\n        try:\n            response = await asyncio.to_thread(\n                self._session.delete,\n                f\"{BASE_URL}{path}\",\n                json=body,\n                headers=headers,\n            )\n            # Handling specific response for cancel\n            self._handle_cancel_response(order, response)\n        except Exception as e:\n            self._log.error(f\"Error cancelling order: {e}\")\n\n    def _handle_cancel_response(self, order, response) -> None:\n        if response.status_code == 200:\n            self._generate_order_canceled(\n                order, \n                # response might contain details\n            )\n\n    def _generate_order_canceled(self, order) -> None:\n        event = OrderCanceled(\n            trader_id=self.trader_id,\n            account_id=self.account_id,\n            client_order_id=order.client_order_id,\n            venue_order_id=self._cache.order_id(order.client_order_id),\n            ts_event=self._clock.timestamp_ns(),\n        )\n        self._send_data_response(event)\n",
    "factories.py": "from nautilus_trader.adapters.http.client import HTTPClient\nfrom nautilus_trader.core.livekit import LiveKit\nfrom nautilus_trader.live.execution_factory import LiveExecFactory\nfrom nautilus_trader.model.identifiers import Venue\n\nfrom nautilus_trader.adapters.lighter.config import LighterConfig\nfrom nautilus_trader.adapters.lighter.data import LighterDataClient\nfrom nautilus_trader.adapters.lighter.execution import LighterExecutionClient\nfrom nautilus_trader.adapters.lighter.providers import LighterInstrumentProvider\nfrom nautilus_trader.adapters.lighter.constants import VENUE\n\n\nclass LighterLiveExecFactory(LiveExecFactory):\n    \"\"\"\n    Factory for creating Lighter clients.\n    \"\"\"\n\n    def __init__(\n        self,\n        loop,\n        kit: LiveKit,\n        config: LighterConfig,\n    ):\n        self._loop = loop\n        self._kit = kit\n        self._config = config\n\n    def create(self):\n        # Create Instrument Provider\n        # Using HTTP Client for REST data\n        http_client = HTTPClient( \n            loop=self._loop,\n            # Configure base url etc.\n        )\n        \n        instrument_provider = LighterInstrumentProvider(\n            client=http_client,\n            logger=self._kit.logger,\n            config=self._config,\n        )\n        \n        # Create Execution Client\n        exec_client = LighterExecutionClient(\n            config=self._config,\n            msgbus=self._kit.msgbus,\n            cache=self._kit.cache,\n            clock=self._kit.clock,\n            instrument_provider=instrument_provider,\n        )\n\n        # Create Data Client\n        data_client = LighterDataClient(\n            config=self._config,\n            msgbus=self._kit.msgbus,\n            cache=self._kit.cache,\n            clock=self._kit.clock,\n            instrument_provider=instrument_provider,\n        )\n\n        return exec_client, data_client\n",
    "providers.py": "from typing import List, Optional\n\nfrom nautilus_trader.adapters.http.client import HTTPClient\nfrom nautilus_trader.core.correctness import PyCondition\nfrom nautilus_trader.core.logging import Logger\nfrom nautilus_trader.core.uuid import UUID4\nfrom nautilus_trader.model.identifiers import InstrumentId, Symbol, Venue\nfrom nautilus_trader.model.instruments import CryptoInstrument\nfrom nautilus_trader.model.objects import Price, Quantity, Money\nfrom nautilus_trader.adapters.lighter.constants import VENUE, PATH_TICKERS, BASE_URL\nfrom nautilus_trader.config import InstrumentProviderConfig\n\n\nclass LighterInstrumentProvider:\n    \"\"\"\n    Instrument provider for Lighter.\n    \"\"\"\n\n    def __init__(\n        self,\n        client: HTTPClient,\n        logger: Logger,\n        config,\n    ):\n        self._client = client\n        self._log = logger\n        self._config = config\n        self._chain_id = config.chain_id\n        self._instruments: List[CryptoInstrument] = []\n\n    async def load_all_async(self) -> None:\n        self._log.info(\"Loading instruments from Lighter...\")\n        \n        # Construct query\n        params = {\"chainId\": self._chain_id}\n        \n        # Using the HTTP client to fetch data\n        # Note: In a synchronous context or non-async provider, this would differ.\n        # Assuming async here for modern Nautilus patterns.\n        response = await self._client.get(\n            url=f\"{BASE_URL}{PATH_TICKERS}\",\n            params=params,\n        )\n        \n        self._parse_instruments(response)\n\n    def _parse_instruments(self, data: List[dict]) -> None:\n        for item in data:\n            try:\n                # Schema says instrument_id_format: BASE-QUOTE\n                symbol_raw = item.get(\"symbol\") # e.g., BTC-USDT\n                base_quote = symbol_raw.split(\"-\")\n                \n                if len(base_quote) != 2:\n                    continue\n                    \n                base, quote = base_quote\n                \n                # Precision from schema is 8/8\n                price_prec = item.get(\"priceStep\") or 8\n                size_prec = item.get(\"sizeStep\") or 8\n                \n                # Nautilus Instrument ID format is BASE/QUOTE.VENUE\n                nautilus_symbol = Symbol(f\"{base}/{quote}\")\n                instrument_id = InstrumentId(symbol=nautilus_symbol, venue=VENUE)\n                \n                instrument = CryptoInstrument(\n                    instrument_id=instrument_id,\n                    raw_symbol=symbol_raw,\n                    base_currency=base, # Ideally a Currency object\n                    quote_currency=quote, # Ideally a Currency object\n                    price_precision=int(price_prec), # Simplified parsing\n                    size_precision=int(size_prec), # Simplified parsing\n                    price_increment=Price.from_str(f\"0.{0:0{int(price_prec)}d}1\"), # Hacky calc based on precision\n                    size_increment=Quantity.from_str(f\"0.{0:0{int(size_prec)}d}1\"),\n                    lot_size=Quantity.from_int(1), # Contract size 1\n                    max_quantity=None,\n                    min_quantity=None,\n                    max_price=None,\n                    min_price=None,\n                    margin_init=None,\n                    margin_maint=None,\n                    maker_fee=None,\n                    taker_fee=None,\n                    info=item\n                )\n                self._instruments.append(instrument)\n                self._log.debug(f\"Added instrument {instrument_id}\")\n                \n            except Exception as e:\n                self._log.error(f\"Failed to parse instrument {item}: {e}\")\n\n    def find(self, instrument_id: InstrumentId) -> Optional[CryptoInstrument]:\n        for instrument in self._instruments:\n            if instrument.id == instrument_id:\n                return instrument\n        return None\n\n    def list_all(self) -> List[CryptoInstrument]:\n        return self._instruments\n"
  }
}
```