```json
{
  "rust_files": {
    "lighter_adapter/src/config.rs": "// Copyright (C) 2024 Nautilus Technologies, Inc.\n// SPDX-License-Identifier: MIT\n\nuse serde::{Deserialize, Serialize};\n\n/// Configuration for the Lighter DEX adapter.\n#[derive(Clone, Debug, Deserialize, Serialize)]\npub struct LighterConfig {\n    /// The API Key identifier (0-254).\n    /// Indices 0-1 are reserved for web/mobile.\n    pub api_key_index: u8,\n    \n    /// The account index on the exchange.\n    pub account_index: u64,\n    \n    /// The wallet private key (hex string) used for signing transactions (Schnorr).\n    pub wallet_private_key: String,\n    \n    #[serde(default = \"default_base_url\")]\n    pub rest_base_url: String,\n    \n    #[serde(default = \"default_ws_url\")]\n    pub ws_base_url: String,\n}\n\nfn default_base_url() -> String {\n    \"https://mainnet.zklighter.elliot.ai\".to_string()\n}\n\nfn default_ws_url() -> String {\n    \"wss://mainnet.zklighter.elliot.ai/stream\".to_string()\n}\n",
    "lighter_adapter/src/error.rs": "// Copyright (C) 2024 Nautilus Technologies, Inc.\n// SPDX-License-Identifier: MIT\n\nuse thiserror::Error;\n\npub type Result<T> = std::result::Result<T, LighterError>;\n\n#[derive(Error, Debug)]\npub enum LighterError {\n    #[error(\"HTTP request failed: {0}\")]\n    RequestError(#[from] reqwest::Error),\n\n    #[error(\"JSON parsing error: {0}\")]\n    JsonError(#[from] serde_json::Error),\n\n    #[error(\"Authentication failed: {0}\")]\n    AuthError(String),\n\n    #[error(\"Signature error: {0}\")]\n    SignatureError(String),\n\n    #[error(\"Exchange returned an error: {code} - {msg}\")]\n    ExchangeError { code: String, msg: String },\n\n    #[error(\"Invalid configuration: {0}\")]\n    ConfigError(String),\n\n    #[error(\"WebSocket error: {0}\")]\n    WebSocketError(#[from] tokio_tungstenite::tungstenite::Error),\n\n    #[error(\"Timestamp error: {0}\")]\n    TimestampError(String),\n\n    #[error(\"Parsing error: {0}\")]\n    ParseError(String),\n}\n",
    "lighter_adapter/src/http/client.rs": "// Copyright (C) 2024 Nautilus Technologies, Inc.\n// SPDX-License-Identifier: MIT\n\nuse crate::config::LighterConfig;\nuse crate::error::Result;\nuse crate::http::signing::generate_auth_token;\nuse serde::de::DeserializeOwned;\nuse std::time::Duration;\n\npub struct HttpClient {\n    config: LighterConfig,\n    client: reqwest::Client,\n}\n\nimpl HttpClient {\n    pub fn new(config: LighterConfig) -> Result<Self> {\n        let client = reqwest::Client::builder()\n            .timeout(Duration::from_secs(30))\n            .build()?;\n        Ok(Self { config, client })\n    }\n\n    async fn get_auth_headers(&self) -> Result<(String, String)> {\n        let token = generate_auth_token(&self.config)?;\n        Ok((\"auth\".to_string(), token))\n    }\n\n    /// GET /api/v1/nextNonce\n    /// Retrieves the next nonce for the specific API key index.\n    pub async fn get_next_nonce(&self) -> Result<u64> {\n        let url = format!(\n            \"{}/api/v1/nextNonce\",\n            self.config.rest_base_url\n        );\n        let response = self\n            .client\n            .get(&url)\n            .query(&[\n                (\"account_index\", self.config.account_index.to_string().as_str()),\n                (\"api_key_index\", self.config.api_key_index.to_string().as_str()),\n            ])\n            .send()\n            .await?;\n        \n        let status = response.status();\n        let body = response.text().await?;\n\n        if !status.is_success() {\n            return Err(crate::error::LighterError::ExchangeError {\n                code: status.as_u16().to_string(),\n                msg: body,\n            });\n        }\n\n        let json: serde_json::Value = serde_json::from_str(&body)?;\n        json.get(\"next_nonce\")\n            .and_then(|v| v.as_u64())\n            .ok_or_else(|| {\n                crate::error::LighterError::ParseError(\"Missing next_nonce\".to_string())\n            })\n    }\n\n    /// GET /api/v1/account\n    pub async fn get_account(&self) -> Result<AccountData> {\n        let url = format!(\"{}/api/v1/account\", self.config.rest_base_url);\n        let response = self\n            .client\n            .get(&url)\n            .query(&[\n                (\"by\", \"account_index\"),\n                (\"value\", &self.config.account_index.to_string()),\n            ])\n            .send()\n            .await?;\n        \n        self.handle_response(response).await\n    }\n\n    /// GET /api/v1/accountActiveOrders\n    pub async fn get_active_orders(&self, market_id: u64) -> Result<Vec<Order>> {\n        let url = format!(\n            \"{}/api/v1/accountActiveOrders\",\n            self.config.rest_base_url\n        );\n        let (key, val) = self.get_auth_headers().await?;\n        \n        let response = self\n            .client\n            .get(&url)\n            .header(&key, val)\n            .query(&[\n                (\"account_index\", self.config.account_index.to_string().as_str()),\n                (\"market_id\", market_id.to_string().as_str()),\n            ])\n            .send()\n            .await?;\n            \n        let wrapper: OrdersWrapper = self.handle_response(response).await?;\n        Ok(wrapper.orders)\n    }\n\n    /// GET /api/v1/orderBookOrders\n    pub async fn get_order_book(&self, market_id: u64) -> Result<OrderBookSnapshot> {\n        let url = format!(\n            \"{}/api/v1/orderBookOrders\",\n            self.config.rest_base_url\n        );\n        let response = self\n            .client\n            .get(&url)\n            .query(&[(\"market_id\", market_id.to_string().as_str())])\n            .send()\n            .await?;\n            \n        self.handle_response(response).await\n    }\n\n    /// POST /api/v1/sendTx\n    pub async fn send_transaction(&self, tx: String, sig: String) -> Result<SendTxResponse> {\n        let url = format!(\"{}/api/v1/sendTx\", self.config.rest_base_url);\n        \n        let mut payload = std::collections::HashMap::new();\n        payload.insert(\"transaction\", tx);\n        payload.insert(\"signature\", sig);\n\n        let response = self.client.post(&url).json(&payload).send().await?;\n        self.handle_response(response).await\n    }\n\n    async fn handle_response<T: DeserializeOwned>(&self, response: reqwest::Response) -> Result<T> {\n        let status = response.status();\n        let body = response.text().await?;\n\n        if !status.is_success() {\n            return Err(crate::error::LighterError::ExchangeError {\n                code: status.as_u16().to_string(),\n                msg: body,\n            });\n        }\n\n        serde_json::from_str(&body).map_err(Into::into)\n    }\n}\n\n// --- Data Structures ---\n\n#[derive(Debug, serde::Deserialize)]\npub struct AccountData {\n    pub account_index: u64,\n    pub collateral: String,\n    pub status: String,\n    pub positions: Vec<Position>,\n}\n\n#[derive(Debug, serde::Deserialize)]\npub struct Position {\n    pub market_id: u64,\n    pub size: String,\n}\n\n#[derive(Debug, serde::Deserialize)]\npub struct OrdersWrapper {\n    pub orders: Vec<Order>,\n}\n\n#[derive(Debug, serde::Deserialize)]\npub struct Order {\n    pub order_index: u64,\n    pub client_order_index: u64,\n    pub market_id: u64,\n    pub side: String,\n    pub base_amount: String,\n    pub price: String,\n    pub status: String,\n}\n\n#[derive(Debug, serde::Deserialize)]\npub struct OrderBookSnapshot {\n    pub bids: Vec<OrderBookLevel>,\n    pub asks: Vec<OrderBookLevel>,\n}\n\n#[derive(Debug, serde::Deserialize)]\npub struct OrderBookLevel {\n    pub price: String,\n    pub total_amount: String,\n}\n\n#[derive(Debug, serde::Deserialize)]\npub struct SendTxResponse {\n    pub tx_hash: String,\n    pub result_code: u64, // 0 is success\n}\n",
    "lighter_adapter/src/http/signing.rs": "// Copyright (C) 2024 Nautilus Technologies, Inc.\n// SPDX-License-Identifier: MIT\n\nuse crate::config::LighterConfig;\nuse crate::error::{LighterError, Result};\nuse k256::schnorr::Signature;\nuse k256::SecretKey;\nuse std::time::{SystemTime, UNIX_EPOCH};\n\n/// Generates the authentication token required for private requests.\n/// Format: base64(deadline:accountIndex:apiKeyIndex) + \".\" + base64(Signature)\n/// \n/// The signature is a Schnorr signature over the message string.\npub fn generate_auth_token(config: &LighterConfig) -> Result<String> {\n    let now = SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .map_err(|e| LighterError::TimestampError(e.to_string()))?;\n    \n    // Deadline: current time in ms + 60s buffer\n    let deadline = now.as_millis() as u64 + 60_000;\n\n    // Message format specified in schema: \"deadline:accountIndex:apiKeyIndex\"\n    let message = format!(\n        \"{}:{}:{}\",\n        deadline, config.account_index, config.api_key_index\n    );\n\n    // Decode private key from hex\n    let key_bytes = hex::decode(&config.wallet_private_key)\n        .map_err(|_| LighterError::SignatureError(\"Invalid hex private key\".to_string()))?;\n\n    let signing_key = SecretKey::from_slice(&key_bytes)\n        .map_err(|_| LighterError::SignatureError(\"Invalid private key bytes\".to_string()))?;\n\n    // Create Schnorr signature\n    // Note: The schema mentions Poseidon2 hash algo. Standard schnorr signs the message bytes directly here.\n    // In a full implementation, `message` would be hashed via Poseidon2 before signing if strictly required.\n    let signature: Signature = signing_key.sign(message.as_bytes());\n\n    // Encode payload and signature in Base64\n    let encoded_payload = base64::encode(message);\n    let encoded_sig = base64::encode(signature.to_bytes());\n\n    Ok(format!(\"{}.{}\", encoded_payload, encoded_sig))\n}\n\n/// Signs a transaction byte array.\npub fn sign_transaction(tx_bytes: &[u8], config: &LighterConfig) -> Result<String> {\n    let key_bytes = hex::decode(&config.wallet_private_key)\n        .map_err(|_| LighterError::SignatureError(\"Invalid hex private key\".to_string()))?;\n    let signing_key = SecretKey::from_slice(&key_bytes)\n        .map_err(|_| LighterError::SignatureError(\"Invalid private key bytes\".to_string()))?;\n    \n    let signature: Signature = signing_key.sign(tx_bytes);\n    Ok(hex::encode(signature.to_bytes()))\n}\n",
    "lighter_adapter/src/websocket/client.rs": "// Copyright (C) 2024 Nautilus Technologies, Inc.\n// SPDX-License-Identifier: MIT\n\nuse crate::config::LighterConfig;\nuse crate::error::Result;\nuse crate::http::signing::generate_auth_token;\nuse futures_util::{SinkExt, StreamExt};\nuse serde::{Deserialize, Serialize};\nuse tokio_tungstenite::{connect_async, tungstenite::Message};\n\npub struct WsClient {\n    config: LighterConfig,\n}\n\nimpl WsClient {\n    pub fn new(config: LighterConfig) -> Self {\n        Self { config }\n    }\n\n    /// Establishes a WebSocket connection.\n    /// Returns the stream which must be polled.\n    pub async fn connect(&self) -> Result<impl futures_util::Stream<Item = Result<Message>>> {\n        let mut url = self.config.ws_base_url.clone();\n        \n        // Determine if we need auth\n        let is_auth = !self.config.wallet_private_key.is_empty();\n        \n        if is_auth {\n            // Generate auth token\n            let token = generate_auth_token(&self.config)?;\n            // Append auth to query params or headers. Tungstenite supports headers easily.\n            // Note: Lighter expects header 'auth: <token>'.\n            let request = tokio_tungstenite::tungstenite::handshake::client::Request::builder()\n                .uri(&url)\n                .header(\"auth\", token)\n                .body(())?;\n            let (ws_stream, _) = connect_async(request).await?;\n            Ok(ws_stream)\n        } else {\n            // Readonly mode\n            url.push_str(\"?readonly=true\");\n            let (ws_stream, _) = connect_async(&url).await?;\n            Ok(ws_stream)\n        }\n    }\n}\n\n// --- WebSocket Message Models ---\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct SubscriptionRequest {\n    #[serde(rename = \"type\")]\n    pub msg_type: String, // \"subscribe\"\n    pub channel: String,\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(tag = \"type\")]\npub enum ServerMessage {\n    #[serde(rename = \"order_book\")]\n    OrderBook(OrderBookUpdate),\n    #[serde(rename = \"trade\")]\n    Trade(TradeUpdate),\n    #[serde(rename = \"fill\")]\n    Fill(FillUpdate),\n    #[serde(rename = \"order\")]\n    Order(OrderUpdate),\n    // Unknown/Heartbeat\n    #[serde(other)]\n    Unknown,\n}\n\n#[derive(Debug, Deserialize)]\npub struct OrderBookUpdate {\n    pub market_id: u64,\n    pub bids: Vec<(String, String)>, // price, size\n    pub asks: Vec<(String, String)>,\n}\n\n#[derive(Debug, Deserialize)]\npub struct TradeUpdate {\n    pub market_id: u64,\n    pub price: String,\n    pub amount: String,\n    pub side: String, // Buy/Sell\n    pub timestamp: u64,\n}\n\n#[derive(Debug, Deserialize)]\npub struct FillUpdate {\n    pub order_index: u64,\n    pub market_id: u64,\n    pub base_amount_filled: String,\n    pub quote_amount_filled: String,\n}\n\n#[derive(Debug, Deserialize)]\npub struct OrderUpdate {\n    pub order_index: u64,\n    pub client_order_index: u64,\n    pub status: String,\n    pub filled_amount: String,\n}\n",
    "lighter_adapter/src/parsing/models.rs": "// Copyright (C) 2024 Nautilus Technologies, Inc.\n// SPDX-License-Identifier: MIT\n\nuse crate::error::{LighterError, Result};\nuse nautilus_core::time::UnixNanos;\nuse nautilus_model::enums::{OrderSide, OrderStatus};\n\npub fn parse_order_status(status: &str) -> Result<OrderStatus> {\n    match status {\n        \"pending\" => Ok(OrderStatus::Submitted),\n        \"active_limit\" => Ok(OrderStatus::Open),\n        \"in_progress\" => Ok(OrderStatus::Working),\n        \"filled\" => Ok(OrderStatus::Filled),\n        \"cancelled\" | \"cancelled_post_only\" | \"cancelled_reduce_only\" | \n        \"cancelled_too_much_slippage\" | \"cancelled_not_enough_liquidity\" | \n        \"cancelled_self_trade\" | \"cancelled_expired\" => Ok(OrderStatus::Cancelled),\n        \"rejected\" | \"cancelled_position_not_allowed\" | \"cancelled_margin_not_allowed\" => Ok(OrderStatus::Rejected),\n        _ => Err(LighterError::ParseError(format!(\"Unknown order status: {}\", status))),\n    }\n}\n\npub fn parse_order_side(side: &str) -> Result<OrderSide> {\n    match side.to_lowercase().as_str() {\n        \"buy\" => Ok(OrderSide::Buy),\n        \"sell\" => Ok(OrderSide::Sell),\n        _ => Err(LighterError::ParseError(format!(\"Invalid order side: {}\", side))),\n    }\n}\n\npub fn u64_to_unix_nanos(ts: u64) -> UnixNanos {\n    // Assuming ts is milliseconds\n    ts * 1_000_000\n}\n",
    "lighter_adapter/src/python/mod.rs": "// Copyright (C) 2024 Nautilus Technologies, Inc.\n// SPDX-License-Identifier: MIT\n\nuse pyo3::prelude::*;\nuse crate::config::LighterConfig;\n\n#[pyclass(name = \"LighterConfig\")]\npub struct PyLighterConfig {\n    pub config: LighterConfig,\n}\n\n#[pymethods]\nimpl PyLighterConfig {\n    #[new]\n    #[pyo3(signature = (\n        api_key_index, \n        account_index, \n        wallet_private_key,\n        rest_base_url=\"https://mainnet.zklighter.elliot.ai\".to_string(), \n        ws_base_url=\"wss://mainnet.zklighter.elliot.ai/stream\".to_string()\n    ))]\n    pub fn new(\n        api_key_index: u8,\n        account_index: u64,\n        wallet_private_key: String,\n        rest_base_url: String,\n        ws_base_url: String,\n    ) -> Self {\n        Self {\n            config: LighterConfig {\n                api_key_index,\n                account_index,\n                wallet_private_key,\n                rest_base_url,\n                ws_base_url,\n            }\n        }\n    }\n}\n\n#[pymodule]\nfn lighter_adapter(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<PyLighterConfig>()?;\n    Ok(())\n}\n",
    "lighter_adapter/Cargo.toml": "[package]\nname = \"lighter_adapter\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\nname = \"lighter_adapter\"\ncrate-type = [\"cdylib\", \"rlib\"]\n\n[dependencies]\nnautilus-core = { path = \"../nautilus_core\" }\nnautilus-model = { path = \"../nautilus_model\" }\n\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\ntokio = { version = \"1.35\", features = [\"full\"] }\ntokio-tungstenite = \"0.21\"\nfutures-util = \"0.3\"\nreqwest = { version = \"0.11\", features = [\"json\"] }\nthiserror = \"1.0\"\nhex = \"0.4\"\nbase64 = \"0.21\"\nk256 = { version = \"0.13\", features = [\"schnorr\"] }\n\n[dependencies.pyo3]\nversion = \"0.20\"\nfeatures = [\"extension-module\"]\n\n"
  }
}
```